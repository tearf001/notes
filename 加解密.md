# Aspnetcore3.x
**PasswordHasher.cs 代码分析:**

- **版本支持:**    
    - PasswordHasherCompatibilityMode.IdentityV2: 使用 PBKDF2 with HMAC-SHA1, 1000 次迭代。        
    - PasswordHasherCompatibilityMode.IdentityV3: 使用 PBKDF2 with HMAC-SHA512, 100000 次迭代（默认）。可以通过 PasswordHasherOptions 的 IterationCount 属性自定义迭代次数。        
- **HashPassword 方法:**    
    - 根据 _compatibilityMode 选择 HashPasswordV2 或 HashPasswordV3。        
    - 最终的哈希值是 Base64 编码的。
        
- **HashPasswordV2 方法 (PBKDF2-HMAC-SHA1):**    
    - 盐: 128 位 (16 字节)。        
    - 迭代次数: 1000。        
    - 哈希长度: 256 位 (32 字节)。        
    - 输出格式: { 0x00, salt, subkey }。        
- **HashPasswordV3 方法 (PBKDF2-HMAC-SHA512):**    
    - 盐: 128 位 (16 字节)。        
    - 迭代次数: _iterCount (默认为 100000，可通过选项配置)。        
    - 哈希长度: 256 位 (32 字节) -- 可以通过numBytesRequested来配置。        
    - 输出格式: { 0x01, prf (UInt32), iter count (UInt32), salt length (UInt32), salt, subkey }。        
        - prf: KeyDerivationPrf 枚举值（大端序 UInt32）。            
            - HMACSHA1: 0                
            - HMACSHA256: 1                
            - HMACSHA512: 2                
- **VerifyHashedPassword 方法:**    
    - 根据哈希值开头的字节（0x00 或 0x01）判断版本。        
    - 调用 VerifyHashedPasswordV2 或 VerifyHashedPasswordV3 进行验证。        
    - 对于 V3，如果旧的迭代次数小于当前配置的 _iterCount，或者旧的 PRF 是 SHA1 或 SHA256，则返回 SuccessRehashNeeded。        
- **关键的辅助函数**    
    - ReadNetworkByteOrder: 从字节数组中读取大端序的 UInt32。        
    - WriteNetworkByteOrder: 将 UInt32 值以大端序写入字节数组。        
    - ByteArraysEqual: .NET Standard 2.0和.NET Framework中比较两个数组是否相等的方法.        
    - CryptographicOperations.FixedTimeEquals: .NET Core中比较数组的方法.

> V3 now requires SHA512. If the old PRF is SHA1 or SHA256, upgrade to SHA512 and rehash.

# Python
**Python 验证代码 (针对 ASP.NET Core Identity V3 - PBKDF2-HMAC-SHA512):**

```python
import hashlib
import base64
import struct
import secrets

############################# 验证 #############################
def verify_password_v3(hashed_password:str, human_pwd:str):
    """
    Verifies a provided password against an ASP.NET Core Identity V3 hash  (PBKDF2-HMAC-SHA512).
    Args:
        hashed_password (str): The Base64 encoded stored hash.
        human_pwd (str): The password provided by the user (UTF-8 encoded).
    Returns: True if the password matches, False otherwise.
    """
    try:
        decoded_hash = base64.b64decode(hashed_password)
        print('decoded_hash:', decoded_hash, len(decoded_hash))
        # Unpack header values
        version = decoded_hash[0]
        if version != 0x01:
            print("Not a V3 hash")
            return False
        
        print('1-5', decoded_hash[1:5], struct.unpack(">I", decoded_hash[1:5])) # \x00\x00\x00\x01
        prf = struct.unpack(">I", decoded_hash[1:5])[0]  # >I: Big-endian unsigned int
        
        print('5-9', decoded_hash[5:9], struct.unpack(">I", decoded_hash[5:9])) # \x00\x00'\x10
        iteration_count = struct.unpack(">I", decoded_hash[5:9])[0]

        print('9-13', decoded_hash[9:13], struct.unpack(">I", decoded_hash[9:13]))# \x00\x00\x00\x10
        salt_length = struct.unpack(">I", decoded_hash[9:13])[0] # 16 to hex in 32 chars
        
        print('prf:', prf)
        print('iteration_count:', iteration_count)
        print('salt_length:', salt_length)
        print('dklen:', len(decoded_hash[13 + salt_length:])) # 32 bytes, 64 chars in hex

        if prf == 0:
            print("HMAC-SHA1 (should rehash)")
            hash_alg = 'sha1' # Not recommended
        elif prf == 1:
            print("HMAC-SHA256 (should rehash)") # for me
            hash_alg = 'sha256'
        elif prf == 2:
            print("HMAC-SHA512")
            hash_alg = 'sha512'
        else:
            print("Unknown PRF")
            return False
            
        salt = decoded_hash[13 : 13 + salt_length]
        derived_key = decoded_hash[13 + salt_length:]

        new_derived_key = hashlib.pbkdf2_hmac(
            hash_alg,
            human_pwd.encode('utf-8'),
            salt,
            iteration_count,
            dklen=len(derived_key)  # Important: Use the same length as the stored key
        )

        # Constant-time comparison (important!)
        is_valid = secrets.compare_digest(derived_key, new_derived_key)
        
        if is_valid:
          print(f"Verification successful. Iterations: {iteration_count}, Salt: {salt.hex()}, Key: {derived_key.hex()}")
        else:
          print("Verification failed")

        return is_valid

    except (ValueError, struct.error, TypeError) as e:
        print(f"Error during verification: {e}")
        return False  # Handle invalid hash format


############################# 加密 #############################
def generate_password_hash_v3(password: str, iteration_count=100000, prf=2, salt_len=16, key_len=32):
    """
    Generates an ASP.NET Core Identity V3 compatible password hash (PBKDF2-HMAC-SHA512).
    Args:
        password (str): The password to hash (UTF-8 encoded).
        iteration_count (int): The number of iterations for PBKDF2. (Default: 100000, ASP.NET Core Identity's default)
        prf (int):  The PRF identifier (0=HMACSHA1, 1=HMACSHA256, 2=HMACSHA512. Default: 2, ASP.NET Core Identity's default)
        salt_len (int): The length of the salt in bytes (Default: 16).
        key_len (int) : The length of derived key in bytes (Default: 32).
    Returns:
        str: Base64 encoded password hash string, compatible with ASP.NET Core Identity V3.
    """

    salt = secrets.token_bytes(salt_len) # get random n bytes. (16) like: b'\xebr\x17D*t\xae\xd4\xe3S\xb6\xe2\xebP1\x8b'
    if prf == 0:
        hash_alg = 'sha1'  # Not recommended
    elif prf == 1:
        hash_alg = 'sha256'
    elif prf == 2:
        hash_alg = 'sha512'
    else:
        raise ValueError("Invalid PRF value")
    
    derived_key = hashlib.pbkdf2_hmac(
        hash_alg,
        password.encode('utf-8'),
        salt,
        iteration_count,
        dklen=key_len
    )

    # Pack the header values into bytes
    header: bytes = struct.pack(">BIII", 0x01, prf, iteration_count, salt_len)  # >: Big-endian

    # Combine all parts and Base64 encode the result
    combined: bytes = header + salt + derived_key
    hashed_password: str = base64.b64encode(combined).decode('utf-8')

    return hashed_password

# Example Usage:
password = "random-pwd"
hashed_password = generate_password_hash_v3(password)
print(f"Generated PasswordHash (V3): {hashed_password}")

# Verify (using the previous verification function):
is_valid = verify_password_v3(hashed_password, password)
print(f"Verification: {is_valid}") # Should be True

# --- Example Usage (using the hash from your question) ---
hashed_password_from_db = "AQAAAAEAACcQAAAAEDjcbKUvTo/BsH/..../s5Tk8SeXIrA=="
password_to_check = "your-pwd"  # Replace with the actual password

result = verify_password_v3(hashed_password_from_db, password_to_check)
print(f"Verification result: {result}")

```

代码解释:
1. **Base64 解码:** 将从数据库中读取的 hashed_password 字符串进行 Base64 解码1。    
2. **解析头部:**    
    - version: 读取第一个字节，检查是否为 0x01 (V3 格式)。        
    - prf: 使用 struct.unpack(">I", ...) 读取接下来的 4 个字节，解析出 PRF 标识符 (大端序)。        
    - iteration_count: 读取接下来的 4 个字节，解析出迭代次数。        
    - salt_length: 读取接下来的 4 个字节，解析出盐的长度。        
3. **提取盐和哈希值:** 根据解析出的 salt_length，从字节数组中提取盐16和剩余的哈希值部分32。    (不能保证是16和32)
4. **计算新的哈希值:** 使用 hashlib.pbkdf2_hmac，根据提取的 PRF、迭代次数、盐和用户提供的密码，计算出一个新的哈希值。 重要： dklen 参数必须设置为与存储的哈希值相同的长度。    
5. **恒定时间比较:** 使用 secrets.compare_digest 比较计算出的哈希值和从数据库中提取的哈希值。    
6. **错误处理：** 捕获ValueError, struct.error和TypeError。
    

Python 代码 与ASPNETCORE3.1的 PasswordHasher.cs 代码中的 V3 验证逻辑完全一致，并且可以正确地验证 ASP.NET Core Identity 3.1 及以后版本（使用默认配置或自定义迭代次数的 PBKDF2-HMAC-SHA512）生成的密码哈希值