# 开发svelte包
以 *sveltekit-search-params*为例, 它既是一个标准的 SvelteKit 项目，又可以作为一个独立的包发布。 这种结构带来了很多好处，正如你所指出的，它极大地提升了开发体验 (DX)。

## 项目结构与双重身份
*   **SvelteKit 项目:**  整个项目是一个完整的 SvelteKit 项目。这意味着它具有 SvelteKit 项目的所有标准目录结构（如 `src/routes`、`src/lib` 等），可以像普通 SvelteKit 应用一样运行、开发和构建 这为开发者提供了一个完整的、可运行的环境来开发和测试库的核心功能。
    （`npm run dev`、`npm run build:landing`）
*   **可发布的包:**  项目可以将核心功能打包成一个独立的、可分发的包。

*  发布后，其他项目可以通过 `npm install `*sveltekit-search-params* 来安装和使用它。

## 发包
通常是 `build` 命令
> Q:  `svelte-package` 或 `svelte-kit` 但是 作为命令, 他实际由`开发依赖`提供, 那么这个是怎么被发现的, 是某种约定?
> A:  包(`packages.json`声明了 ***bin*** 字段，`npm/pnpm` 会在 node_modules/.bin 目录下创建指向该包的可执行文件的*符号链接*（symlinks）

通过 `svelte-package` (官方的包 *@sveltejs/package* )命令（在 `build` 脚本中），这个包会被输出到 `package` 目录（由 `-o package` 指定）。  

##  package.json解析
```json
	name  包的名称，发布到 npm 时的名称。
	version  包的版本号。遵循语义化版本控制 (SemVer)。
	...//
	scripts
    	dev  启动本地开发服务器。
    	version:patch/minor/major  使用 npm version 命令快速更新版本号。
    	build:landing 构建项目的展示页面（可能是一个独立的 SvelteKit 站点）。
    	build  这是关键！它做了几件事：
	        `svelte-kit sync`:  同步 SvelteKit 项目的配置。
	        `svelte-package -o package`:  使用 svelte-package 将项目打包成一个库，输出到 package 目录。 src/lib
	        `publint`:  在发布前检查包的质量，确保符合最佳实践。
    	build:playground  构建演练场项目，通常用于交互式演示。
    	preview:playground  预览构建后的演练场。
    	check、check:watch  使用 svelte-check 进行类型检查。
    	lint  代码风格检查。
    	format  代码格式化。
    	publish 发布包到 npm。它先执行 build，然后使用 changeset publish (后面会解释)。
    	test  运行各种测试。
    	changeset  运行 changeset 命令，用于版本管理和生成 changelog（后面会解释）。
    	
	devDependencies  开发时依赖的包，这些包不会包含在发布的包中。
	type "module" 表示使用 ES 模块。
	peerDependencies  重要的依赖关系！ 表示用户必须 *自己* 安装这些 peerDependencies。这是为了避免版本冲突和重复的依赖。
	 // sveltekit-search-params 对等依赖于 @sveltejs/kit 和 svelte. 但它 不 捆绑这些依赖
	exports:  { //定义了包的导出方式。	    
	    ".": "./package/index.js", // 指向包的主入口文件. build之后生成
		"./package.json": "./package.json",// 允许用户导入包的 package.json 文件（例如，获取版本号）。
	    "./sveltekit-search-params": "./package/sveltekit-search-params.svelte.js":  // 允许直接导入 Svelte 组件。
	}
	files: ['package']  // 指定哪些文件和目录应该包含在发布的包中。这里只包含 package 目录，因为所有构建后的代码都在那里。
	typesVersions: { 为 TypeScript 用户提供类型定义文件 (.d.ts) 的路径。
		">4.0": {
			"index": ["./package/index.d.ts"],
			"sveltekit-search-params": ["./package/sveltekit-search-params.d.ts"]
		}
	}
```
##  Changesets 的作用

`@changesets/cli` 和 `changeset` 命令用于管理项目的版本和自动生成 CHANGELOG。

###   工作流程
1.  开发者进行代码更改。
2.  运行 `pnpm changeset` (或者 `npx changeset`)。 这会引导开发者创建一个 "changeset" 文件，描述这次更改的类型（patch、minor、major）和一段描述。
3.  当准备发布时，运行 `pnpm changeset version`。这会根据已有的 changeset 文件自动更新 `package.json` 中的版本号，并将这些 changeset 文件的内容合并到 CHANGELOG.md 文件中。
4.  `pnpm publish` (或 `npm publish`) 将包发布到 npm。

###  Playground 的作用

`playground` 目录通常包含一个独立的 ***SvelteKit*** 项目，用于演示和测试 `sveltekit-search-params` 的功能。

*   **独立性:**  `playground` 有自己的 `package.json` 和依赖项。这确保了演示环境与库本身隔离。
*   **构建和预览:**  `build:playground` 和 `preview:playground` 脚本用于构建和预览演练场，通常部署到 Netlify 或 Vercel。
*   **集成测试:** playground 也经常用于手动测试和集成测试，确保库在实际应用中按预期工作。

**总结**

-   `sveltekit-search-params` 项目采用了一种非常现代和高效的DX开发模式。它将 SvelteKit 项目的便利性与库发布的严谨性结合起来
*   **完整的开发环境:**  SvelteKit 提供了热重载、路由等功能，方便开发。
*   **清晰的构建和发布流程:**  `svelte-package`、`publint` 和 Changesets 确保了包的质量和版本管理的自动化。
*   **独立的演练场:**  提供了一个隔离的环境来演示和测试库的功能。
*   **Peer Dependencies:** 避免了依赖冲突，确保了库的灵活性。

包生成代码
https://github.com/sveltejs/kit/blob/main/packages/package/src/cli.js
```js
const pkg = JSON.parse(fs.readFileSync(new URL('../package.json', import.meta.url), 'utf-8'));
const prog = sade('svelte-package', true).version(pkg.version);
prog.describe('Create a package')
	.option('-i, --input', '输入目录')
	.option('-o, --output', '输出目录', 'dist')
	.option('-t, --types', '发布TS类型', true)
	.option('-w, --watch', '当文件变化是重新运行', false)
	.option('--tsconfig', 'ts配置路径. When not provided, searches for the next upper path in the workspace')
	.action(async (args) => {
		try {
			const config = await load_config();
			// @ts-expect-error
			if (config.package)
				throw new Error('config.package no longer supported. https://github.com/sveltejs/kit/pull/8922');		

			const packaging = await import('./index.js');
			const options = {
				cwd: process.cwd(),
				input: args.input ?? config.kit?.files?.lib ?? 'src/lib',
				output: args.output,
				tsconfig: args.tsconfig,
				types: args.types,
				config
			};
			await (args.watch ? packaging.watch(options) : packaging.build(options));
		} catch (error) {
			handle_error(error);
		}
	});
prog.parse(process.argv, { unknown: (arg) => `Unknown option: ${arg}` });
```