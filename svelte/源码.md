
### 项目结构

Svelte 5的主要目录结构如下：

1. `/packages/svelte/` - 核心实现
    - `/src/compiler/` - 编译器实现
	    - 1-parse 完整的AST解析逻辑
		    - read
			    - style.js
			    - script.js
			    - options.js
			    - expression.js
			    - context.js
    - `/src/internal/` - 运行时实现
    - `/src/store/` - 状态管理实现
2. `/documentation/` - 官方文档
3. `/playgrounds/` - 示例和测试场景
4. `/benchmarking/` - 性能测试

## 阶段分析
1. **解析阶段 (1-parse)**    
    - 使用 `acorn` 作为基础 JavaScript 解析器
    - 主要职责：
        - 解析模板语法
        - 解析 JavaScript 表达式
        - 创建初始 AST (抽象语法树)
    - 关键技术：
        - 自定义词法分析器处理模板语法
        - 支持 HTML-like 语法解析
        - 处理特殊标签和指令
2. **分析阶段 (2-analyze)**
    - 主要职责：
        - 作用域分析
        - 变量引用追踪
        - 依赖关系分析
        - 验证语法正确性
    - 关键技术：
        - 使用 `ScopeRoot` 和 `Scope` 类管理作用域
        - 处理 Svelte 特有的语法（如 `$state`、`$props` 等符文）
        - 检测循环依赖
        - CSS 分析和作用域处理
3. **转换阶段 (3-transform)**
    - 分为客户端和服务器端两个部分：
        - `client/`: 生成客户端运行时代码
        - `server/`: 生成服务器端渲染代码
    - 主要职责：
        - 转换 Svelte 特有语法为标准 JavaScript
        - 生成响应式更新代码
        - 优化渲染性能
    - 关键技术：
        - 状态管理转换（如 `$state` 到 `$.mutable_state`）
        - 模板编译优化
        - 代码分割和优化
        - 服务端渲染支持
4. **重要的共享模块**
    - `scope.js`: 作用域管理的核心实现
    - `bindings.js`: 变量绑定处理
    - `patterns.js`: 常用正则表达式模式
    - `nodes.js`: AST 节点处理工具
5. **技术亮点**
    - 使用 `zimmerframe` 进行 AST 遍历和转换
    - 分离的客户端/服务器端转换逻辑
    - 强大的静态分析能力
    - 高效的编译时优化
    - 完善的错误处理和提示
这种分阶段的设计让 Svelte 能够：
- 提供清晰的代码组织
- 实现复杂的编译时优化
- 支持多种输出目标（客户端/服务器端）
- 方便地扩展新功能（如 Svelte 5 的符文系统）

## zimmerframe 类型
```js
type BaseNode = { type: string };
type NodeOf<T extends string, X> = X extends { type: T } ? X : never; // NodeOf<'node', {type: 'node'}>
type SpecialisedVisitors<T extends BaseNode, U> = {
	[K in T['type']]?: Visitor<NodeOf<K, T>, U, T>; // 
};
export type Visitor<T, U, V> = (node: T, context: Context<V, U>) => V | void;

export type Visitors<T extends BaseNode, U> = T['type'] extends '_'
	? never
	: SpecialisedVisitors<T, U> & { _?: Visitor<T, U, T> };

export interface Context<T, U> {
	next: (state?: U) => T | void;
	path: T[];
	state: U;
	stop: () => void;
	visit: (node: T, state?: U) => T;
}

```
# AST 命名空间
svelte 定义了AST的类型. 但是基于estree.
## 节点类
```ts
namespace AST {
	interface BaseNode {type: string;start: number;end: number;}
	// <>...nodes...</>
	interface Fragment {type: 'Fragment', metadata:{transparent: 提升scope?}, nodes:(Text|Tag|ElementLike|Block|Comment)[]}
	
	interface Root extends BaseNode {
		type: 'Root';
		/**Inline options provided by `<svelte:options>` — override options passed to `compile(...)`*/
		options: SvelteOptions | null;
		fragment: Fragment; // <></>
		/** The parsed `<style>` element, if exists */
		css: AST.CSS.StyleSheet | null;
		/** The parsed `<script>` element, if exists */
		instance: Script | null;
		/** The parsed `<script module>` element, if exists */
		module: Script | null;
		/** @internal */
		metadata: {	/*Whether the component parsed with ts*/ ts: boolean;};
	}
	interface SvelteOptions{ /*runes,css:injected, ns: html|svg|mathml, attributes*/}
	interface Text/Comment extends BaseNode{`${T}`}
	interface ExpressionTag/HtmlTag extends BaseNode{Expression} // 最重要的表达式标签{...}
	interface Identifier extends BaseNode, BaseExpression{}, BasePattern{} {type: "Identifier"; name: string;}
```
## 组件类
基于节点, 包括元素
```tsx
	 interface Fragment /*它不是NODE*/{
		type: 'Fragment';
		nodes: Array<Text | Tag | ElementLike | Block | Comment>;
		metadata: {
			/**
			 * Fragments declare their own scopes. A transparent fragment is one whose scope
			 * is not represented by a scope in the resulting JavaScript (e.g. an element scope),
			 * and should therefore delegate to parent scopes when generating unique identifiers
			 */
			transparent: boolean;
			/**
			 * Whether or not we need to traverse into the fragment during mount/hydrate
			 */
			dynamic: boolean;
		};
	}
    // 增强型元素. 有fragment
	interface BaseElement extends BaseNode {
        name: string;
        attributes: Array<Attribute | SpreadAttribute | Directive>; //组件属性序列 a=b {spread} d:x=y
        fragment: Fragment; // <></> 在基础节点 增加了 fragment
    }

    TitleElement extends BaseElement
    SlotElement  extends BaseElement
    // 常规元素 
    interface RegularElement extends BaseElement {
	    metadata: {			
			svg: boolean;			
			mathml: boolean;			
			has_spread: boolean;
			scoped: boolean;
			path: SvelteNode[];
		};
    }
    SvelteBody extends BaseElement
    SvelteDocument extends BaseElement
    SvelteFragment extends BaseElement
    SvelteBoundary extends BaseElement
    SvelteHead extends BaseElement
    SvelteOptionsRaw extends BaseElement // 解析的中间形态, 不出现在最终的AST

	// 组件. 在 element的基础上, 增加了元信息. 通常是自定义的元素, 也叫组件
	interface Component extends BaseElement { // 'Component'
        metadata: {
            scopes: Record<string, Scope>;
            dynamic: boolean;            
            snippets: Set<SnippetBlock>;/* 本地定义的snippets集合. this component tag could render it. used for CSS 剪枝 */
            path: SvelteNode[];
        };
    }
    interface SvelteSelf extends BaseElement{
		metadata: Component['metadata']
    }
    // svelte 组件
    interface SvelteComponent extend Component{
	    expression: Expression; // {组件}
    }
    // svelte 元素
    interface SvelteElement extends BaseElement{
	    tag: Expression 
	    metadata: RegularElement['metadata']
    }
    
    
```

## 指令类
```tsx
// 指令s, 通用, 全部extends BaseNode, 都包括 type, name, expression, 有的还有metadata
	type Directive = .Animate|.Bind|.Class|.Let|.On|.Style|.Transition|.Use
	
	interface AnimateDirective {animate:x={y}}
	interface ClassDirective {class:x}
	interface LetDirective {let:x={y}}
	interface OnDirective {on:x={y}}
	
	interface BindDirective { /* bind:x={y} */
		expression: Identifier | MemberExpression | SequenceExpression; // 标识符, 成员表达式, 表达式数组    
        metadata: {binding_group_name: Identifier; parent_each_blocks: EachBlock[];}
	}
	interface StyleDirective extends BaseNode{ /** `style:name={value}` */	
		value: true | ExpressionTag | Array<ExpressionTag | Text>; // style:name=value 可以堆叠
		modifiers: Array<'important'>;
	}
	export interface TransitionDirective {
        modifiers: Array<'local' | 'global'>;
        intro: boolean; // transition:name | in:name
        outro: boolean; // transition:name | out:name
    }
    interface UseDirective extends BaseNode { `use:name={expr}` }    
```

## 属性类
实现基于estree.
```tsx
// estree
export interface Program extends BaseNode {
    type: "Program";
    sourceType: "script" | "module";
    body: Array<Directive | Statement | ModuleDeclaration>;
    comments?: Comment[] | undefined;
}
function js(script, root, allow_reactive_declarations, parent) {
	/** @type {Program} */
	const ast = script?.content ?? {type: 'Program', sourceType: 'module', start: -1, end: -1,body: []	};
	const { scope, scopes } = create_scopes(ast, root, allow_reactive_declarations, parent);
	return { ast, scope, scopes };
}
interface Script extends BaseNode {
	type: 'Script';
	context: 'default' | 'module';
	content: Program;
	attributes: Attribute[]; // BaseNode[]
}
```

## Type 分组
AST 命名空间中 packages\svelte\src\compiler\types\template.d.ts
```ts
	AttributeLike = Attribute | SpreadAttribute | Directive;	
    // 块 {#blk} ... {/blk}
	Block = AST.EachBlock  AST.IfBlock | AST.AwaitBlock | AST.KeyBlock| AST.SnippetBlock;
	// 元素
	ElementLike = AST.Component | AST.TitleElement | AST.SlotElement| AST.RegularElement | AST.Svelte...
	// 标记    {...}        | {@html ...} | {@const ...} | {@debug ...} | {@render snp_foo(...)}
	Tag = AST.ExpressionTag | AST.HtmlTag | AST.ConstTag | AST.DebugTag | AST.RenderTag;
    // 模板节点. 包括根, 文本, Tag, 组件, 属性, 发散属性, 指令, 注释, 块
	TemplateNode = AST.Root |AST.Text |AST.Comment // 第一类 根, 文本, 注释
		| Block | Tag | ElementLike  // 第二类 @razor like
		| Directive | AST.Attribute | AST.SpreadAttribute; // 第三类 附着在ElementLike 上面的 属性
```

# 实际逻辑
*element*  是可以包含属性和children的*节点*

```js
/** @import { AST, ExpressionMetadata } from '#compiler' */
/** All nodes that can appear elsewhere than the top level, have 属性 and can 包含 children */
const element_nodes = ['RegularElement','Component','SvelteElement','SvelteFragment',
	'SvelteComponent',	'SvelteSelf',	'SlotElement'];

/** return node is Component | RegularElement | SlotElement | SvelteComponent | SvelteElement | SvelteFragment | SvelteSelf */
export function is_element_node(node) {
	return element_nodes.includes(node.type);
}
/** return node is {AST.RegularElement | AST.SvelteElement} */
export function is_custom_element_node(node) {
	return node.type === 'RegularElement' &&
		(node.name.includes('-') || node.attributes.some(a => a.type === 'Attribute' && a.name === 'is'));
}

/**@param {AST.Attribute['value']} value returns {AST.Attribute} */
export function create_attribute(name, start, end, value) {
	return { type: 'Attribute',
		start, end, name, value,
		metadata: {	delegated: null, needs_clsx: false } };
}

/* @returns {ExpressionMetadata} */
export function create_expression_metadata() {
	return {
		dependencies: new Set(),
		has_state: false,
		has_call: false
	};
}
```

## fragment
```ts
// packages\svelte\src\compiler\phases\1-parse\state\fragment.js
export default function fragment(parser) {
    if (parser.match('<')) {
        return element;
    }
    if (parser.match('{')) {
        return tag;
    }
    return text;
}
```

## 符文
### $state() 符文实现

根据官方文档（`documentation/docs/02-runes/02-$state.md`）和源码分析，`$state()`是Svelte 5中的新特性，用于创建响应式状态。

#### 基本用法

```js
let count = $state(0);  // 创建基础状态
let todos = $state([{ done: false, text: 'task' } ]); // 创建深度响应式状态
```

#### 实现机制
1. **编译时处理**：    
    - 在`packages/svelte/src/compiler/phases/3-transform/`中处理
    - 主要通过`PropertyDefinition`和`VariableDeclaration`访问器处理`$state`声明
    - 编译器识别`$state()`调用并转换为响应式代理
2. **运行时实现**：    
    - 使用JavaScript的Proxy API创建响应式对象
    - 对于基本类型，直接跟踪读写操作
    - 对于对象和数组，创建深度响应式代理
3. **两种模式**：    
    - 默认模式：`$state()` - 创建深度响应式状态
    - 原始模式：`$state.raw()` - 创建非深度响应式状态，需要通过重新赋值触发更新
#### 特点
1. **简单性**：
    - 不需要特殊API来操作状态
    - 直接使用普通JavaScript操作（赋值、方法调用等）
2. **深度响应**：
    - 自动代理嵌套的对象和数组
    - 支持细粒度更新，只在实际改变时触发重渲染
3. **限制**：
    - 不支持代理`Set`、`Map`等内置类类型
    - 需要从`svelte/reactivity`导入响应式版本
4. **调试支持**：
    - 提供`$state.snapshot()`用于调试
    - 开发模式下提供额外的状态跟踪

符文集合:
```ts
const RUNES = /** @type {const} */ ([
	'$state',
	'$state.raw',
	'$state.snapshot',
	'$props',
	'$props.id',
	'$bindable',
	'$derived',
	'$derived.by',
	'$effect',
	'$effect.pre',
	'$effect.tracking',
	'$effect.root',
	'$inspect',
	'$inspect().with',
	'$inspect.trace',
	'$host'
]);

```

## 转换 
转换是第三阶段, 
- client
- css
- sever
- shared

`packages\svelte\src\compiler\phases\3-transform\client\transform-client.js`
但实际上它们的差异不仅仅是 body 不同。让我解释一下这两个函数的关键区别：

1. **状态对象的差异**
```js
// client_component 的状态
const state = {
    analysis,
    options,
    scope: analysis.module.scope,
    scopes: analysis.module.scopes,
    is_instance: false,
    hoisted: [b.import_all('$', 'svelte/internal/client')],
    node: null,
    legacy_reactive_imports: [],
    legacy_reactive_statements: new Map(),
    metadata: { ... },
    events: new Set(),
    preserve_whitespace: options.preserveWhitespace,
    public_state: new Map(),
    private_state: new Map(),
    transform: {},
    in_constructor: false,
    instance_level_snippets: [],
    module_level_snippets: [],
    // 模板相关的状态
    init: null,
    update: null,
    expressions: null,
    after_update: null,
    template: null,
    locations: null
};

// client_module 的状态
const state = {
    analysis,
    options,
    scope: analysis.module.scope,
    scopes: analysis.module.scopes,
    public_state: new Map(),
    private_state: new Map(),
    transform: {},
    in_constructor: false
};
```

1. **处理流程的差异**

- `client_component`:
    
    - 处理模块代码 (`module`)
    - 处理实例代码 (`instance`)
    - 处理模板代码 (`template`)
    - 生成自定义元素定义（如果需要）
    - 处理 HMR（热模块替换）逻辑
- `client_module`:
    
    - 只处理模块代码
    - 只导入必要的运行时
    - 不涉及组件实例化和模板处理

1. **输出结构的差异** 虽然都返回 `Program` 类型，但内容不同：

```js
// client_module 输出
return {
    type: 'Program',
    sourceType: 'module',
    body: [
        b.import_all('$', 'svelte/internal/client'),
        // 可选的 tracing 导入
        ...b.imports([], 'svelte/internal/flags/tracing')
    ]
};

// client_component 输出
return {
    type: 'Program',
    sourceType: 'module',
    body: [
        // 组件定义
        // 状态管理
        // 生命周期钩子
        // 模板渲染逻辑
        // 自定义元素注册
        // ...更多组件特有的逻辑
    ]
};
```

1. **功能职责的差异**

- `client_module` 主要负责：
    
    - 处理模块级别的代码
    - 处理导出
    - 确保模块级别的代码可以被其他模块复用
- `client_component` 主要负责：
    
    - 组件的完整生命周期
    - 状态管理和响应式更新
    - 模板渲染
    - DOM 操作
    - 事件处理
    - 组件实例化

所以虽然它们的返回类型相同，但实际上处理的内容和职责有很大的区别。这种设计反映了 Svelte 中模块代码和组件代码的不同定位：模块代码是静态的、可共享的，而组件代码是动态的、实例化的。

### visitors
#server_compiled
```js
// 客户端版本
export function IfBlock(node, context) {
	context.state.template.push('<!>');
	const statements = [];
	const consequent =  context.visit(node.consequent); /** 同服务器版本, 表示后果 @type {BlockStatement} */
	const consequent_id = context.state.scope.generate('consequent'); // 在上下文作用域内, 生成后果id

	statements.push(b.var(b.id(consequent_id), b.arrow([b.id('$$anchor')], consequent)));

	let alternate_id;

	if (node.alternate) {
		const alternate = /** @type {BlockStatement} */ (context.visit(node.alternate));
		alternate_id = context.state.scope.generate('alternate');
		statements.push(b.var(b.id(alternate_id), b.arrow([b.id('$$anchor')], alternate)));
	}

	/** @type {Expression[]} */
	const args = [
		context.state.node,
		b.arrow(
			[b.id('$$render')],
			b.block([
				b.if(context.visit(node.test),b.stmt(b.call(b.id('$$render'), b.id(consequent_id))),
					alternate_id
						? b.stmt(b.call(b.id('$$render'), b.id(alternate_id), 
							node.alternate ? b.literal(false) : undefined))
						: undefined
				)
			])
		)
	];
	if (node.elseif) {
		args.push(b.literal(true));
	}
	statements.push(b.stmt(b.call('$.if', ...args)));
	context.state.init.push(b.block(statements));
}

// 服务器版本
export function IfBlock(node, context) {
	const test = (context.visit(node.test)); // Expression predicate
	const consequent = context.visit(node.consequent); // @type {BlockStatement}
	const alternate = node.alternate ? context.visit(node.alternate) : b.block([]); //@type {BlockStatement}
	
	consequent.body.unshift(b.stmt(b.assignment('+=', b.id('$$payload.out'), '<!--[-->')));
	alternate.body.unshift(
		b.stmt(b.assignment('+=', b.id('$$payload.out'), b.literal('<!--[!-->')))
	);
	context.state.template.push(b.if(test, consequent, alternate), '<!--]-->');
}
```
### hmr
```js
const accept_fn_body = [
    // 更新组件源码
    b.stmt(b.assignment('=', b.member(incoming, 'source'), b.member(existing, 'source'))),
    // 使用新的原始代码更新组件
    b.stmt(b.call('$.set', b.member(existing, 'source'), b.member(incoming, 'original')))
];

// CSS 更新处理
if (analysis.css.hash) {
    // 如果 CSS 发生变化，先清理已存在的 style 元素
    accept_fn_body.unshift(b.stmt(b.call('$.cleanup_styles', b.literal(analysis.css.hash))));
}

const hmr = b.block([
    // 创建 HMR 包装器
    b.stmt(b.assignment('=', id, b.call('$.hmr', id, b.thunk(b.member(existing, 'source'))))),
    // 注册 HMR accept 处理函数
    b.stmt(b.call('import.meta.hot.accept', b.arrow([b.id('module')], b.block(accept_fn_body))))
]);
```

hmr.js
```js
/** @import { Source, Effect, TemplateNode } from '#client' */
import { FILENAME, HMR } from '../../../constants.js';
import { EFFECT_TRANSPARENT } from '../constants.js';
import { hydrate_node, hydrating } from '../dom/hydration.js';
import { block, branch, destroy_effect } from '../reactivity/effects.js';
import { source } from '../reactivity/sources.js';
import { set_should_intro } from '../render.js';
import { get } from '../runtime.js';

export function hmr(original: Component, get_source: () => Source<Component>) {
	function wrapper(anchor: TemplateNode, props) {
		let instance = {};
		/** @type {Effect} */
		let effect;
		let ran = false;

		block(() => {
			const source = get_source();
			const component = get(source);
			if (effect) {
				// @ts-ignore
				for (var k in instance) delete instance[k];
				destroy_effect(effect);
			}
			effect = branch(() => {
				// when the component is invalidated, replace it without transitions
				if (ran) set_should_intro(false);
				// preserve getters/setters
				Object.defineProperties(
					instance,
					Object.getOwnPropertyDescriptors(
						new.target ? new component(anchor, props) : component(anchor, props)
					)
				);
				if (ran) set_should_intro(true);
			});
		}, EFFECT_TRANSPARENT);
		ran = true;
		if (hydrating) {
			anchor = hydrate_node;
		}
		return instance;
	}
	wrapper[FILENAME] = original[FILENAME];
	wrapper[HMR] = {
		// When we accept an update, we set the original source to the new component
		original,
		// The `get_source` parameter reads `wrapper[HMR].source`, but in the `accept`
		// function we always replace it with `previous[HMR].source`, which in practice
		// means we only ever update the original
		source: source(original)
	};
	return wrapper;
}

```