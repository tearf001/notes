
### 项目结构

Svelte 5的主要目录结构如下：

1. `/packages/svelte/` - 核心实现
    - `/src/compiler/` - 编译器实现
    - `/src/internal/` - 运行时实现
    - `/src/store/` - 状态管理实现
2. `/documentation/` - 官方文档
3. `/playgrounds/` - 示例和测试场景
4. `/benchmarking/` - 性能测试

### $state() 符文实现

根据官方文档（`documentation/docs/02-runes/02-$state.md`）和源码分析，`$state()`是Svelte 5中的新特性，用于创建响应式状态。

#### 基本用法

```js
let count = $state(0);  // 创建基础状态
let todos = $state([{ done: false, text: 'task' } ]); // 创建深度响应式状态
```

#### 实现机制
1. **编译时处理**：    
    - 在`packages/svelte/src/compiler/phases/3-transform/`中处理
    - 主要通过`PropertyDefinition`和`VariableDeclaration`访问器处理`$state`声明
    - 编译器识别`$state()`调用并转换为响应式代理
2. **运行时实现**：    
    - 使用JavaScript的Proxy API创建响应式对象
    - 对于基本类型，直接跟踪读写操作
    - 对于对象和数组，创建深度响应式代理
3. **两种模式**：    
    - 默认模式：`$state()` - 创建深度响应式状态
    - 原始模式：`$state.raw()` - 创建非深度响应式状态，需要通过重新赋值触发更新
#### 特点

4. **简单性**：
    
    - 不需要特殊API来操作状态
    - 直接使用普通JavaScript操作（赋值、方法调用等）
5. **深度响应**：
    
    - 自动代理嵌套的对象和数组
    - 支持细粒度更新，只在实际改变时触发重渲染
6. **限制**：
    
    - 不支持代理`Set`、`Map`等内置类类型
    - 需要从`svelte/reactivity`导入响应式版本
7. **调试支持**：
    
    - 提供`$state.snapshot()`用于调试
    - 开发模式下提供额外的状态跟踪

这是Svelte 5中的一个重要新特性，它简化了状态管理，使得响应式编程更加直观和符合JavaScript的使用习惯。相比Svelte 4的响应式系统，它提供了更好的开发体验和更强大的功能。


符文集合:
```ts
const RUNES = /** @type {const} */ ([
	'$state',
	'$state.raw',
	'$state.snapshot',
	'$props',
	'$props.id',
	'$bindable',
	'$derived',
	'$derived.by',
	'$effect',
	'$effect.pre',
	'$effect.tracking',
	'$effect.root',
	'$inspect',
	'$inspect().with',
	'$inspect.trace',
	'$host'
]);

```
# AST 命名空间
svelte 定义了AST的类型. 但是基于estree.
## 节点类
```ts
namespace AST {
	interface BaseNode {type: string;start: number;end: number;}
	// <>...nodes...</>
	interface Fragment {type: 'Fragment', metadata:{transparent: 提升scope?}, nodes:(Text|Tag|ElementLike|Block|Comment)[]}
	
	interface Root extends BaseNode {
		type: 'Root';
		/**Inline options provided by `<svelte:options>` — override options passed to `compile(...)`*/
		options: SvelteOptions | null;
		fragment: Fragment; // <></>
		/** The parsed `<style>` element, if exists */
		css: AST.CSS.StyleSheet | null;
		/** The parsed `<script>` element, if exists */
		instance: Script | null;
		/** The parsed `<script module>` element, if exists */
		module: Script | null;
		/** @internal */
		metadata: {	/** Whether the component was parsed with typescript */	ts: boolean;};
	}
	interface SvelteOptions{ /*runes,css:injected, ns: html|svg|mathml, attributs*/}
	interface Text/Comment extends BaseNode{`${T}`}
	interface ExpressionTag/HtmlTag extends BaseNode{Expression} // 最重要的表达式标签{...}
	interface Identifier extends BaseNode, BaseExpression{}, BasePattern{} {type: "Identifier"; name: string;}
```
## 组件类
基于节点, 包括元素
```tsx
	 interface Fragment /*它不是NODE*/{
		type: 'Fragment';
		nodes: Array<Text | Tag | ElementLike | Block | Comment>;
		metadata: {
			/**
			 * Fragments declare their own scopes. A transparent fragment is one whose scope
			 * is not represented by a scope in the resulting JavaScript (e.g. an element scope),
			 * and should therefore delegate to parent scopes when generating unique identifiers
			 */
			transparent: boolean;
			/**
			 * Whether or not we need to traverse into the fragment during mount/hydrate
			 */
			dynamic: boolean;
		};
	}
    // 增强型元素. 有fragment
	interface BaseElement extends BaseNode {
        name: string;
        attributes: Array<Attribute | SpreadAttribute | Directive>; //组件属性序列 a=b {spread} d:x=y
        fragment: Fragment; // <></> 在基础节点 增加了 fragment
    }

    TitleElement extends BaseElement
    SlotElement  extends BaseElement
    // 常规元素 
    interface RegularElement extends BaseElement {
	    metadata: {			
			svg: boolean;			
			mathml: boolean;			
			has_spread: boolean;
			scoped: boolean;
			path: SvelteNode[];
		};
    }
    SvelteBody extends BaseElement
    SvelteDocument extends BaseElement
    SvelteFragment extends BaseElement
    SvelteBoundary extends BaseElement
    SvelteHead extends BaseElement
    SvelteOptionsRaw extends BaseElement // 解析的中间形态, 不出现在最终的AST

	// 组件. 在 element的基础上, 增加了元信息. 通常是自定义的元素, 也叫组件
	interface Component extends BaseElement { // 'Component'
        metadata: {
            scopes: Record<string, Scope>;
            dynamic: boolean;            
            snippets: Set<SnippetBlock>;/* 本地定义的snippets集合. this component tag could render it. used for CSS 剪枝 */
            path: SvelteNode[];
        };
    }
    interface SvelteSelf extends BaseElement{
		metadata: Component['metadata']
    }
    // svelte 组件
    interface SvelteComponent extend Component{
	    expression: Expression; // {组件}
    }
    // svelte 元素
    interface SvelteElement extends BaseElement{
	    tag: Expression 
	    metadata: RegularElement['metadata']
    }
    
    
```

## 指令类
```tsx
// 指令s, 通用, 全部extends BaseNode, 都包括 type, name, expression, 有的还有metadata
	type Directive = .Animate|.Bind|.Class|.Let|.On|.Style|.Transition|.Use
	
	interface AnimateDirective {animate:x={y}}
	interface ClassDirective {class:x}
	interface LetDirective {let:x={y}}
	interface OnDirective {on:x={y}}
	
	interface BindDirective { /* bind:x={y} */
		expression: Identifier | MemberExpression | SequenceExpression; // 标识符, 成员表达式, 表达式数组    
        metadata: {binding_group_name: Identifier; parent_each_blocks: EachBlock[];}
	}
	interface StyleDirective extends BaseNode{ /** `style:name={value}` */	
		value: true | ExpressionTag | Array<ExpressionTag | Text>; // style:name=value 可以堆叠
		modifiers: Array<'important'>;
	}
	export interface TransitionDirective {
        modifiers: Array<'local' | 'global'>;
        intro: boolean; // transition:name | in:name
        outro: boolean; // transition:name | out:name
    }
    interface UseDirective extends BaseNode { `use:name={expr}` }    
```

## 属性类
实现基于estree.
```tsx
// estree
export interface Program extends BaseNode {
    type: "Program";
    sourceType: "script" | "module";
    body: Array<Directive | Statement | ModuleDeclaration>;
    comments?: Comment[] | undefined;
}
function js(script, root, allow_reactive_declarations, parent) {
	/** @type {Program} */
	const ast = script?.content ?? {type: 'Program', sourceType: 'module', start: -1, end: -1,body: []	};
	const { scope, scopes } = create_scopes(ast, root, allow_reactive_declarations, parent);
	return { ast, scope, scopes };
}
interface Script extends BaseNode {
	type: 'Script';
	context: 'default' | 'module';
	content: Program;
	attributes: Attribute[]; // BaseNode[]
}
```

## Type 分组
AST 命名空间中 packages\svelte\src\compiler\types\template.d.ts
```ts
	AttributeLike = Attribute | SpreadAttribute | Directive;	
    // 块 {#blk} ... {/blk}
	Block = AST.EachBlock  AST.IfBlock | AST.AwaitBlock | AST.KeyBlock| AST.SnippetBlock;
	// 元素
	ElementLike = AST.Component | AST.TitleElement | AST.SlotElement| AST.RegularElement | AST.Svelte...
	// 标记    {...}        | {@html ...} | {@const ...} | {@debug ...} | {@render snp_foo(...)}
	Tag = AST.ExpressionTag | AST.HtmlTag | AST.ConstTag | AST.DebugTag | AST.RenderTag;
    // 模板节点. 包括根, 文本, Tag, 组件, 属性, 发散属性, 指令, 注释, 块
	TemplateNode = AST.Root |AST.Text |AST.Comment // 第一类 根, 文本, 注释
		| Block | Tag | ElementLike  // 第二类 @razor like
		| Directive | AST.Attribute | AST.SpreadAttribute; // 第三类 附着在ElementLike 上面的 属性
```
分组实际逻辑
element  是可以包含属性和children的节点
```js
/** @import { AST, ExpressionMetadata } from '#compiler' */
/** All nodes that can appear elsewhere than the top level, have 属性 and can 包含 children */
const element_nodes = ['RegularElement','Component','SvelteElement','SvelteFragment',
	'SvelteComponent',	'SvelteSelf',	'SlotElement'];

/** return node is Component | RegularElement | SlotElement | SvelteComponent | SvelteElement | SvelteFragment | SvelteSelf */
export function is_element_node(node) {
	return element_nodes.includes(node.type);
}

/**
 * @param {AST.RegularElement | AST.SvelteElement} node
 * @returns {boolean}
 */
export function is_custom_element_node(node) {
	return (
		node.type === 'RegularElement' &&
		(node.name.includes('-') ||
			node.attributes.some((attr) => attr.type === 'Attribute' && attr.name === 'is'))
	);
}

/**
 * @param {string} name
 * @param {number} start
 * @param {number} end
 * @param {AST.Attribute['value']} value
 * @returns {AST.Attribute}
 */
export function create_attribute(name, start, end, value) {
	return {
		type: 'Attribute',
		start,
		end,
		name,
		value,
		metadata: {
			delegated: null,
			needs_clsx: false
		}
	};
}

/**
 * @returns {ExpressionMetadata}
 */
export function create_expression_metadata() {
	return {
		dependencies: new Set(),
		has_state: false,
		has_call: false
	};
}
```