
### 项目结构

Svelte 5的主要目录结构如下：

1. `/packages/svelte/` - 核心实现
    - `/src/compiler/` - 编译器实现
	    - 1-parse 完整的AST解析逻辑
		    - read
			    - style.js
			    - script.js
			    - options.js
			    - expression.js
			    - context.js
    - `/src/internal/` - 运行时实现
    - `/src/store/` - 状态管理实现
2. `/documentation/` - 官方文档
3. `/playgrounds/` - 示例和测试场景
4. `/benchmarking/` - 性能测试

## 阶段分析
1. **解析阶段 (1-parse)**    
    - 使用 `acorn` 作为基础 JavaScript 解析器
    - 主要职责：
        - 解析模板语法
        - 解析 JavaScript 表达式
        - 创建初始 AST (抽象语法树)
    - 关键技术：
        - 自定义词法分析器处理模板语法
        - 支持 HTML-like 语法解析
        - 处理特殊标签和指令
2. **分析阶段 (2-analyze)**
    - 主要职责：
        - 作用域分析
        - 变量引用追踪
        - 依赖关系分析
        - 验证语法正确性
    - 关键技术：
        - 使用 `ScopeRoot` 和 `Scope` 类管理作用域
        - 处理 Svelte 特有的语法（如 `$state`、`$props` 等符文）
        - 检测循环依赖
        - CSS 分析和作用域处理
3. **转换阶段 (3-transform)**
    - 分为客户端和服务器端两个部分：
        - `client/`: 生成客户端运行时代码
        - `server/`: 生成服务器端渲染代码
    - 主要职责：
        - 转换 Svelte 特有语法为标准 JavaScript
        - 生成响应式更新代码
        - 优化渲染性能
    - 关键技术：
        - 状态管理转换（如 `$state` 到 `$.mutable_state`）
        - 模板编译优化
        - 代码分割和优化
        - 服务端渲染支持
4. **重要的共享模块**
    - `scope.js`: 作用域管理的核心实现
    - `bindings.js`: 变量绑定处理
    - `patterns.js`: 常用正则表达式模式
    - `nodes.js`: AST 节点处理工具
5. **技术亮点**
    - 使用 `zimmerframe` 进行 AST 遍历和转换
    - 分离的客户端/服务器端转换逻辑
    - 强大的静态分析能力
    - 高效的编译时优化
    - 完善的错误处理和提示
这种分阶段的设计让 Svelte 能够：
- 提供清晰的代码组织
- 实现复杂的编译时优化
- 支持多种输出目标（客户端/服务器端）
- 方便地扩展新功能（如 Svelte 5 的符文系统）

## zimmerframe 类型
```js
type BaseNode = { type: string };
type NodeOf<T extends string, X> = X extends { type: T } ? X : never; // NodeOf<'node', {type: 'node'}>
type SpecialisedVisitors<T extends BaseNode, U> = {
	[K in T['type']]?: Visitor<NodeOf<K, T>, U, T>; // 
};
export type Visitor<T, U, V> = (node: T, context: Context<V, U>) => V | void;

export type Visitors<T extends BaseNode, U> = T['type'] extends '_'
	? never
	: SpecialisedVisitors<T, U> & { _?: Visitor<T, U, T> };

export interface Context<T, U> {
	next: (state?: U) => T | void;
	path: T[];
	state: U;
	stop: () => void;
	visit: (node: T, state?: U) => T;
}

```
# AST 命名空间
svelte 定义了AST的类型. 但是基于estree.
## 节点类
```ts
namespace AST {
	interface BaseNode {type: string;start: number;end: number;}
	// <>...nodes...</>
	interface Fragment {type: 'Fragment', metadata:{transparent: 提升scope?}, nodes:(Text|Tag|ElementLike|Block|Comment)[]}
	
	interface Root extends BaseNode {
		type: 'Root';
		/**Inline options provided by `<svelte:options>` — override options passed to `compile(...)`*/
		options: SvelteOptions | null;
		fragment: Fragment; // <></>
		/** The parsed `<style>` element, if exists */
		css: AST.CSS.StyleSheet | null;
		/** The parsed `<script>` element, if exists */
		instance: Script | null;
		/** The parsed `<script module>` element, if exists */
		module: Script | null;
		/** @internal */
		metadata: {	/*Whether the component parsed with ts*/ ts: boolean;};
	}
	interface SvelteOptions{ /*runes,css:injected, ns: html|svg|mathml, attributes*/}
	interface Text/Comment extends BaseNode{`${T}`}
	interface ExpressionTag/HtmlTag extends BaseNode{Expression} // 最重要的表达式标签{...}
	interface Identifier extends BaseNode, BaseExpression{}, BasePattern{} {type: "Identifier"; name: string;}
```
## 组件类
基于节点, 包括元素
```tsx
	 interface Fragment /*它不是NODE*/{
		type: 'Fragment';
		nodes: Array<Text | Tag | ElementLike | Block | Comment>;
		metadata: {
			/**
			 * Fragments declare their own scopes. A transparent fragment is one whose scope
			 * is not represented by a scope in the resulting JavaScript (e.g. an element scope),
			 * and should therefore delegate to parent scopes when generating unique identifiers
			 */
			transparent: boolean;
			/**
			 * Whether or not we need to traverse into the fragment during mount/hydrate
			 */
			dynamic: boolean;
		};
	}
    // 增强型元素. 有fragment
	interface BaseElement extends BaseNode {
        name: string;
        attributes: Array<Attribute | SpreadAttribute | Directive>; //组件属性序列 a=b {spread} d:x=y
        fragment: Fragment; // <></> 在基础节点 增加了 fragment
    }

    TitleElement extends BaseElement
    SlotElement  extends BaseElement
    // 常规元素 
    interface RegularElement extends BaseElement {
	    metadata: {			
			svg: boolean;			
			mathml: boolean;			
			has_spread: boolean;
			scoped: boolean;
			path: SvelteNode[];
		};
    }
    SvelteBody extends BaseElement
    SvelteDocument extends BaseElement
    SvelteFragment extends BaseElement
    SvelteBoundary extends BaseElement
    SvelteHead extends BaseElement
    SvelteOptionsRaw extends BaseElement // 解析的中间形态, 不出现在最终的AST

	// 组件. 在 element的基础上, 增加了元信息. 通常是自定义的元素, 也叫组件
	interface Component extends BaseElement { // 'Component'
        metadata: {
            scopes: Record<string, Scope>;
            dynamic: boolean;            
            snippets: Set<SnippetBlock>;/* 本地定义的snippets集合. this component tag could render it. used for CSS 剪枝 */
            path: SvelteNode[];
        };
    }
    interface SvelteSelf extends BaseElement{
		metadata: Component['metadata']
    }
    // svelte 组件
    interface SvelteComponent extend Component{
	    expression: Expression; // {组件}
    }
    // svelte 元素
    interface SvelteElement extends BaseElement{
	    tag: Expression 
	    metadata: RegularElement['metadata']
    }
    
    
```

## 指令类
```tsx
// 指令s, 通用, 全部extends BaseNode, 都包括 type, name, expression, 有的还有metadata
	type Directive = .Animate|.Bind|.Class|.Let|.On|.Style|.Transition|.Use
	
	interface AnimateDirective {animate:x={y}}
	interface ClassDirective {class:x}
	interface LetDirective {let:x={y}}
	interface OnDirective {on:x={y}}
	
	interface BindDirective { /* bind:x={y} */
		expression: Identifier | MemberExpression | SequenceExpression; // 标识符, 成员表达式, 表达式数组    
        metadata: {binding_group_name: Identifier; parent_each_blocks: EachBlock[];}
	}
	interface StyleDirective extends BaseNode{ /** `style:name={value}` */	
		value: true | ExpressionTag | Array<ExpressionTag | Text>; // style:name=value 可以堆叠
		modifiers: Array<'important'>;
	}
	export interface TransitionDirective {
        modifiers: Array<'local' | 'global'>;
        intro: boolean; // transition:name | in:name
        outro: boolean; // transition:name | out:name
    }
    interface UseDirective extends BaseNode { `use:name={expr}` }    
```

## 属性类
实现基于estree.
```tsx
// estree
export interface Program extends BaseNode {
    type: "Program";
    sourceType: "script" | "module";
    body: Array<Directive | Statement | ModuleDeclaration>;
    comments?: Comment[] | undefined;
}
function js(script, root, allow_reactive_declarations, parent) {
	/** @type {Program} */
	const ast = script?.content ?? {type: 'Program', sourceType: 'module', start: -1, end: -1,body: []	};
	const { scope, scopes } = create_scopes(ast, root, allow_reactive_declarations, parent);
	return { ast, scope, scopes };
}
interface Script extends BaseNode {
	type: 'Script';
	context: 'default' | 'module';
	content: Program;
	attributes: Attribute[]; // BaseNode[]
}
```

## Type 分组
AST 命名空间中 packages\svelte\src\compiler\types\template.d.ts
```ts
	AttributeLike = Attribute | SpreadAttribute | Directive;	
    // 块 {#blk} ... {/blk}
	Block = AST.EachBlock  AST.IfBlock | AST.AwaitBlock | AST.KeyBlock| AST.SnippetBlock;
	// 元素
	ElementLike = AST.Component | AST.TitleElement | AST.SlotElement| AST.RegularElement | AST.Svelte...
	// 标记    {...}        | {@html ...} | {@const ...} | {@debug ...} | {@render snp_foo(...)}
	Tag = AST.ExpressionTag | AST.HtmlTag | AST.ConstTag | AST.DebugTag | AST.RenderTag;
    // 模板节点. 包括根, 文本, Tag, 组件, 属性, 发散属性, 指令, 注释, 块
	TemplateNode = AST.Root |AST.Text |AST.Comment // 第一类 根, 文本, 注释
		| Block | Tag | ElementLike  // 第二类 @razor like
		| Directive | AST.Attribute | AST.SpreadAttribute; // 第三类 附着在ElementLike 上面的 属性
```

# 解析阶段 - 实际逻辑
*element*  是可以包含属性和children的*节点*

```js
/** @import { AST, ExpressionMetadata } from '#compiler' */
/** All nodes that can appear elsewhere than the top level, have 属性 and can 包含 children */
const element_nodes = ['RegularElement','Component','SvelteElement','SvelteFragment',
	'SvelteComponent',	'SvelteSelf',	'SlotElement'];

/** return node is Component | RegularElement | SlotElement | SvelteComponent | SvelteElement | SvelteFragment | SvelteSelf */
export function is_element_node(node) {
	return element_nodes.includes(node.type);
}
/** return node is {AST.RegularElement | AST.SvelteElement} */
export function is_custom_element_node(node) {
	return node.type === 'RegularElement' &&
		(node.name.includes('-') || node.attributes.some(a => a.type === 'Attribute' && a.name === 'is'));
}

/**@param {AST.Attribute['value']} value returns {AST.Attribute} */
export function create_attribute(name, start, end, value) {
	return { type: 'Attribute',
		start, end, name, value,
		metadata: {	delegated: null, needs_clsx: false } };
}

/* @returns {ExpressionMetadata} */
export function create_expression_metadata() {
	return {
		dependencies: new Set(),
		has_state: false,
		has_call: false
	};
}
```

## fragment
```ts
// packages\svelte\src\compiler\phases\1-parse\state\fragment.js
export default function fragment(parser) {
    if (parser.match('<')) {
        return element;
    }
    if (parser.match('{')) {
        return tag;
    }
    return text;
}
```

## 符文解析
### $state() 符文实现

根据官方文档（`documentation/docs/02-runes/02-$state.md`）和源码分析，`$state()`是Svelte 5中的新特性，用于创建响应式状态。

#### 基本用法

```js
let count = $state(0);  // 创建基础状态
let todos = $state([{ done: false, text: 'task' } ]); // 创建深度响应式状态
```

#### 实现机制
1. **编译时处理**：    
    - 在`packages/svelte/src/compiler/phases/3-transform/`中处理
    - 主要通过`PropertyDefinition`和`VariableDeclaration`访问器处理`$state`声明
    - 编译器识别`$state()`调用并转换为响应式代理
2. **运行时实现**：    
    - 使用JavaScript的Proxy API创建响应式对象
    - 对于基本类型，直接跟踪读写操作
    - 对于对象和数组，创建深度响应式代理
3. **两种模式**：    
    - 默认模式：`$state()` - 创建深度响应式状态
    - 原始模式：`$state.raw()` - 创建非深度响应式状态，需要通过重新赋值触发更新
#### 特点
1. **简单性**：
    - 不需要特殊API来操作状态
    - 直接使用普通JavaScript操作（赋值、方法调用等）
2. **深度响应**：
    - 自动代理嵌套的对象和数组
    - 支持细粒度更新，只在实际改变时触发重渲染
3. **限制**：
    - 不支持代理`Set`、`Map`等内置类类型
    - 需要从`svelte/reactivity`导入响应式版本
4. **调试支持**：
    - 提供`$state.snapshot()`用于调试
    - 开发模式下提供额外的状态跟踪

符文集合:
```ts
const RUNES = /** @type {const} */ ([
	'$state',
	'$state.raw',
	'$state.snapshot',
	'$props',
	'$props.id',
	'$bindable',
	'$derived',
	'$derived.by',
	'$effect',
	'$effect.pre',
	'$effect.tracking',
	'$effect.root',
	'$inspect',
	'$inspect().with',
	'$inspect.trace',
	'$host'
]);

```

# 转换 
转换是第三阶段, 
- client
- css
- sever
- shared

`packages\svelte\src\compiler\phases\3-transform\client\transform-client.js`
但实际上它们的差异不仅仅是 body 不同。让我解释一下这两个函数的关键区别：

1. **状态对象的差异**
```js
// client_component 的状态
const state = {
    analysis,
    options,
    scope: analysis.module.scope,
    scopes: analysis.module.scopes,
    is_instance: false,
    hoisted: [b.import_all('$', 'svelte/internal/client')],
    node: null,
    legacy_reactive_imports: [],
    legacy_reactive_statements: new Map(),
    metadata: { ... },
    events: new Set(),
    preserve_whitespace: options.preserveWhitespace,
    public_state: new Map(),
    private_state: new Map(),
    transform: {},
    in_constructor: false,
    instance_level_snippets: [],
    module_level_snippets: [],
    // 模板相关的状态
    init: null,
    update: null,
    expressions: null,
    after_update: null,
    template: null,
    locations: null
};

// client_module 的状态
const state = {
    analysis,
    options,
    scope: analysis.module.scope,
    scopes: analysis.module.scopes,
    public_state: new Map(),
    private_state: new Map(),
    transform: {},
    in_constructor: false
};
```

1. **处理流程的差异**

- `client_component`:
    
    - 处理模块代码 (`module`)
    - 处理实例代码 (`instance`)
    - 处理模板代码 (`template`)
    - 生成自定义元素定义（如果需要）
    - 处理 HMR（热模块替换）逻辑
- `client_module`:
    
    - 只处理模块代码
    - 只导入必要的运行时
    - 不涉及组件实例化和模板处理

1. **输出结构的差异** 虽然都返回 `Program` 类型，但内容不同：

```js
// client_module 输出
return {
    type: 'Program',
    sourceType: 'module',
    body: [
        b.import_all('$', 'svelte/internal/client'),
        // 可选的 tracing 导入
        ...b.imports([], 'svelte/internal/flags/tracing')
    ]
};

// client_component 输出
return {
    type: 'Program',
    sourceType: 'module',
    body: [
        // 组件定义
        // 状态管理
        // 生命周期钩子
        // 模板渲染逻辑
        // 自定义元素注册
        // ...更多组件特有的逻辑
    ]
};
```

1. **功能职责的差异**

- `client_module` 主要负责：
    
    - 处理模块级别的代码
    - 处理导出
    - 确保模块级别的代码可以被其他模块复用
- `client_component` 主要负责：
    
    - 组件的完整生命周期
    - 状态管理和响应式更新
    - 模板渲染
    - DOM 操作
    - 事件处理
    - 组件实例化

所以虽然它们的返回类型相同，但实际上处理的内容和职责有很大的区别。这种设计反映了 Svelte 中模块代码和组件代码的不同定位：模块代码是静态的、可共享的，而组件代码是动态的、实例化的。

### visitors
#server_compiled
```js
// 客户端版本
export function IfBlock(node, context) {
	context.state.template.push('<!>');
	const statements = [];
	const consequent =  context.visit(node.consequent); /** 同服务器版本, 表示后果 @type {BlockStatement} */
	const consequent_id = context.state.scope.generate('consequent'); // 在上下文作用域内, 生成后果id

	statements.push(b.var(b.id(consequent_id), b.arrow([b.id('$$anchor')], consequent)));

	let alternate_id;

	if (node.alternate) {
		const alternate = /** @type {BlockStatement} */ (context.visit(node.alternate));
		alternate_id = context.state.scope.generate('alternate');
		statements.push(b.var(b.id(alternate_id), b.arrow([b.id('$$anchor')], alternate)));
	}

	/** @type {Expression[]} */
	const args = [
		context.state.node,
		b.arrow(
			[b.id('$$render')],
			b.block([
				b.if(context.visit(node.test),b.stmt(b.call(b.id('$$render'), b.id(consequent_id))),
					alternate_id
						? b.stmt(b.call(b.id('$$render'), b.id(alternate_id), 
							node.alternate ? b.literal(false) : undefined))
						: undefined
				)
			])
		)
	];
	if (node.elseif) {
		args.push(b.literal(true));
	}
	statements.push(b.stmt(b.call('$.if', ...args)));
	context.state.init.push(b.block(statements));
}

// 服务器版本
export function IfBlock(node, context) {
	const test = (context.visit(node.test)); // Expression predicate
	const consequent = context.visit(node.consequent); // @type {BlockStatement}
	const alternate = node.alternate ? context.visit(node.alternate) : b.block([]); //@type {BlockStatement}
	
	consequent.body.unshift(b.stmt(b.assignment('+=', b.id('$$payload.out'), '<!--[-->')));
	alternate.body.unshift(
		b.stmt(b.assignment('+=', b.id('$$payload.out'), b.literal('<!--[!-->')))
	);
	context.state.template.push(b.if(test, consequent, alternate), '<!--]-->');
}
```
### hmr
```js
const accept_fn_body = [
    // 更新组件源码
    b.stmt(b.assignment('=', b.member(incoming, 'source'), b.member(existing, 'source'))),
    // 使用新的原始代码更新组件
    b.stmt(b.call('$.set', b.member(existing, 'source'), b.member(incoming, 'original')))
];

// CSS 更新处理
if (analysis.css.hash) {
    // 如果 CSS 发生变化，先清理已存在的 style 元素
    accept_fn_body.unshift(b.stmt(b.call('$.cleanup_styles', b.literal(analysis.css.hash))));
}

const hmr = b.block([
    // 创建 HMR 包装器
    b.stmt(b.assignment('=', id, b.call('$.hmr', id, b.thunk(b.member(existing, 'source'))))),
    // 注册 HMR accept 处理函数
    b.stmt(b.call('import.meta.hot.accept', b.arrow([b.id('module')], b.block(accept_fn_body))))
]);
```

hmr.js
```js
/** @import { Source, Effect, TemplateNode } from '#client' */
import { FILENAME, HMR } from '../../../constants.js';
import { EFFECT_TRANSPARENT } from '../constants.js';
import { hydrate_node, hydrating } from '../dom/hydration.js';
import { block, branch, destroy_effect } from '../reactivity/effects.js';
import { source } from '../reactivity/sources.js';
import { set_should_intro } from '../render.js';
import { get } from '../runtime.js';

export function hmr(original: Component, get_source: () => Source<Component>) {
	function wrapper(anchor: TemplateNode, props) {
		let instance = {};
		/** @type {Effect} */
		let effect;
		let ran = false;

		block(() => {
			const source = get_source();
			const component = get(source);
			if (effect) {
				// @ts-ignore
				for (var k in instance) delete instance[k];
				destroy_effect(effect);
			}
			effect = branch(() => {
				// when the component is invalidated, replace it without transitions
				if (ran) set_should_intro(false);
				// preserve getters/setters
				Object.defineProperties(
					instance,
					Object.getOwnPropertyDescriptors(
						new.target ? new component(anchor, props) : component(anchor, props)
					)
				);
				if (ran) set_should_intro(true);
			});
		}, EFFECT_TRANSPARENT);
		ran = true;
		if (hydrating) {
			anchor = hydrate_node;
		}
		return instance;
	}
	wrapper[FILENAME] = original[FILENAME];
	wrapper[HMR] = {
		// When we accept an update, we set the original source to the new component
		original,
		// The `get_source` parameter reads `wrapper[HMR].source`, but in the `accept`
		// function we always replace it with `previous[HMR].source`, which in practice
		// means we only ever update the original
		source: source(original)
	};
	return wrapper;
}

```

# 信号响应和DOM更新的实现
Svelte 5 Signal Reactivity and DOM Updates Implementation

Svelte 5 introduces a new reactivity system based on signals and fine-grained DOM updates. Let me explain how these three core files work together to implement this system.
## 目录

### 源码`sources.js`
Let's look at the ***reactivity*** implementation in *sources.js*:

### 副作用 `effects.js`
Let's look at the *effects.js* file to understand how reactivity is implemented:

### 衍生 `deriveds.js`
Let's also look at the *deriveds.js* file to understand how derived values work:

### 操作DOM
Let's look at the DOM *operations.js* to understand how Svelte updates the DOM:

## 1. Overall Architecture

Svelte 5's reactivity system is built around these key concepts:

- **Signals**: Reactive values that can be tracked and updated
- **Effects**: Functions that run when their dependencies (signals) change
- **Derived Values**: Computed values that depend on other signals
- **Fine-grained DOM Updates**: Updates only the parts of the DOM that need to change

## 2. Core Components

### 2.1. `index.js` - 导出点

This file serves as the main export point for all the internal APIs used by Svelte. It exports functions from various modules including:

- Reactivity primitives (`state`, `derived`, `effect`, etc.) **响应原语**
```js
export { mutable_state, mutate, set, state, update, update_pre } from './reactivity/sources.js';
export {
	effect_tracking,
	effect_root,
	legacy_pre_effect,
	legacy_pre_effect_reset,
	render_effect,
	template_effect,
	effect,
	user_effect,
	user_pre_effect
} from './reactivity/effects.js';
```
- DOM manipulation functions **DOM操作函数**
```js
export {
	child,
	first_child,
	sibling,
	$window as window,
	$document as document
} from './dom/operations.js';
```
- Event handling **事件处理**
```js
export { apply, event, delegate, replay_events } from './dom/elements/events.js';
```
- Component lifecycle management **组件生命周期管理**
```js
export { init } from './dom/legacy/lifecycle.js';
```
- Rendering utilities **渲染实用函数**
```js
export {append, comment,xx_template,template,template_with_script,text,	props_id} from './dom/template.js';
```
- 各种binding 函数 
```js
export { bind_current_time,	bind_paused, bind_seeking, ...} from './dom/elements/bindings/media.js';
export { bind_active_element } from './dom/elements/bindings/document.js';
export { bind_checked, bind_files, bind_group, bind_value } from './dom/elements/bindings/input.js';
```
It doesn't contain much implementation code itself but organizes and exposes the ***API surface***.

### 2.2. `runtime.js` - 响应引擎

This file contains the core reactivity engine that powers Svelte 5. Key features include:

1. **Signal Tracking**:
    - ***Tracks*** dependencies between signals and effects
    - Manages the reactivity ***graph*** 拓扑图
    - Handles the propagation of changes **变化*传播***
2. **Key Functions**:
    - `get()`: Reads a signal value and registers it as a dependency. 读出信号,并***注册为***依赖项
    - `check_dirtiness()`: Determines if a derived or effect is dirty 检查衍生值或副作用是否***脏***
    - `update_reaction()`: Updates a reaction (effect or derived) ***更新***衍生值或者副作用
    - `flushSync()`: Synchronously processes all pending updates ***同步处理***所有的***挂起***更新
    - `tick()`: Returns a promise that resolves after updates are applied 返回一个***promise***当所有的更新完成后
3. **Reactivity State Management**:
    - Tracks active effects and reactions
    - Manages version numbers for tracking reads and writes 给跟踪读写 管理版本号码 
    - Handles the scheduling and execution of effects 处理 副作用的计划执行

### 2.3. `render.js` - 组件渲染

This file handles the rendering of components to the DOM. Key features include:

1. **Component Mounting**:
    - `mount()`: Mounts a component to a target element
    - `hydrate()`: Hydrates a server-rendered component
    - `_mount()`: Internal function that handles the actual mounting logic
2. **Event Handling**:
    - Sets up event listeners for components
    - Manages event delegation
3. **Component Lifecycle**:
    - Manages component creation and destruction
    - Handles transitions and animations
## 3. 响应性实现细节

### 3.1. 信号创建与更新
From `sources.js`:
```js
export interface Signal {
    f: number; /** Flags bitmask */
    wv: number;  /** Write version */
}
export interface Value<V = unknown> extends Signal {
	equals: Equals;  /** Equality function. 通常是Object.is */
	reactions: null | Reaction[];	/** Signals that read from this signal */
	rv: number; /** Read version */
	v: V; /** The latest value for this signal */
	/** 开发跟踪 */
	created?: Error | null; updated?: Error | null;	 trace_need_increase?: boolean;	trace_v?: V;
	debug?: null | (() => void);
}

export interface Reaction extends Signal {
	ctx: null | ComponentContext; /**  组件上下文associated */
	fn: null | Function;  /** The reaction function */
	deps: null | Value[]; /** Signals that this signal reads from */
}
// Create a new signal
export function source(v, stack) {
  var signal = {
    f: 0, // flags
    v, // value
    reactions: null, // dependencies
    equals, // equality function
    rv: 0, // read version
    wv: 0 // write version
  };
  return signal;
}

// Update a signal
export function set(source, value) {
  // Check for unsafe mutations
  if (active_reaction !== null && 
      !untracking && 
      is_runes() && 
      (active_reaction.f & (DERIVED | BLOCK_EFFECT)) !== 0 && 
      (derived_sources === null || !derived_sources.includes(source))) {
    e.state_unsafe_mutation();
  }
  return internal_set(source, value);
}

// Internal set implementation
export function internal_set(source, value) {
  if (!source.equals(value)) {
    var old_value = source.v;
    source.v = value;
    source.wv = increment_write_version();
    
    // Mark all reactions that depend on this signal as dirty
    mark_reactions(source, DIRTY);
    
    // Handle untracked writes
    if (is_runes() && active_effect !== null && 
        (active_effect.f & CLEAN) !== 0 && 
        (active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {
      if (untracked_writes === null) {
        set_untracked_writes([source]);
      } else {
        untracked_writes.push(source);
      }
    }
  }
  return value;
}
```

### 3.2. Effects and Reactions

From `effects.js`:
```js
// Create an effect
function create_effect(type, fn, sync, push = true) {
  var is_root = (type & ROOT_EFFECT) !== 0;
  var parent_effect = active_effect;
  var effect = {
    ctx: component_context, // 组件上下文
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: type | DIRTY,
    first: null,
    fn,
    last: null,
    next: null,
    parent: is_root ? null : parent_effect,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0
  };
  
  // Run effect immediately if sync is true. 同步更新立即执行.
  if (sync) {
    try {
      update_effect(effect);
      effect.f |= EFFECT_RAN;
    } catch (e) {
      destroy_effect(effect);
      throw e;
    }
  } else if (fn !== null) { // 否则纳入计划-异步.
    schedule_effect(effect);
  }
  
  // Add effect to effect tree
  if (!inert && !is_root && push) {
    if (parent_effect !== null) {
      push_effect(effect, parent_effect);
    }
    
    // Add to derived if in a derived context
    if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {
      var derived = /** @type {Derived} */ (active_reaction);
      (derived.effects ??= []).push(effect);
    }
  }
  return effect;
}
```
### 3.3. Derived Values

From `deriveds.js`:
```js
// Create a derived value
export function derived(fn) {
  var flags = DERIVED | DIRTY;
  var parent_derived =
    active_reaction !== null && (active_reaction.f & DERIVED) !== 0
      ? /** @type {Derived} */ (active_reaction)
      : null;

  if (active_effect === null || (parent_derived !== null && (parent_derived.f & UNOWNED) !== 0)) {
    flags |= UNOWNED;
  } else {
    active_effect.f |= EFFECT_HAS_DERIVED;
  }

  const signal = {
    ctx: component_context,
    deps: null,
    effects: null,
    equals,
    f: flags,
    fn,
    reactions: null,
    rv: 0,
    v: /** @type {V} */ (null),
    wv: 0,
    parent: parent_derived ?? active_effect
  };
  return signal;
}

// Update a derived value
export function update_derived(derived) {
  var value = execute_derived(derived);
  var status = (skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null ? MAYBE_DIRTY : CLEAN;

  set_signal_status(derived, status);

  if (!derived.equals(value)) {
    derived.v = value;
    derived.wv = increment_write_version();
  }
}
```
## 4. DOM Updates

### 4.1. Text Updates

From `render.js`:

```js
export function set_text(text, value) {
  // For objects, apply string coercion
  var str = value == null ? '' : typeof value === 'object' ? value + '' : value;
  // Only update if the value has changed
  if (str !== (text.__t ??= text.nodeValue)) {
    text.__t = str;
    text.nodeValue = str + '';
  }
}
```

### 4.2. DOM 操作

From `operations.js`:

```js
// Get first child with hydration support
export function child(node, is_text) {
  if (!hydrating) {
    return get_first_child(node);
  }

  var child = get_first_child(hydrate_node);

  // Handle hydration edge cases
  if (child === null) {
    child = hydrate_node.appendChild(create_text());
  } else if (is_text && child.nodeType !== 3) {
    var text = create_text();
    child?.before(text);
    set_hydrate_node(text);
    return text;
  }

  set_hydrate_node(child);
  return child;
}
```

## 5. 响应流

Here's how the reactivity system works from start to finish:

### 5.1. 初始化阶段

1. **Component Creation**:
    - When a component is created, Svelte *initializes **signals** for all **reactive** state*
    - Creates ***effects*** for *template expressions* and *reactive statements*
2. **Mounting**:
    - The `mount()` function in `render.js` is called
    - Creates a component root effect using `component_root()` 根副作用
    - Initializes event handlers and DOM operations 初始化 事件处理器

### 5.2. 更新阶段

1. **Signal Update**:
    - When a signal is updated via `set()`, it marks all dependent ***reactions*** as ***dirty***
    - Updates the signal's value and increments the write version `wv`
2. **Effect Scheduling**:
    - Dirty effects are ***scheduled*** for update using `schedule_effect()`
    - Root effects are added to `queued_root_effects`
3. **Effect Execution**:
    - Effects are executed in ***topological*** order (*parents before children*)
    - `update_effect()` runs the ***effect function*** and ***updates*** dependencies `动态更新?`
    - If the effect creates DOM changes, those are applied
4. **Flushing Updates**:
    - `flushSync()` processes all ***pending*** updates ***synchronously***
    - `tick()` returns a promise that resolves after updates are applied

### 5.3. DOM Paint阶段

1. **Fine-grained Updates**:
    - Only the DOM nodes affected by signal changes are updated
    - Text nodes are updated using `set_text()` 文本节点
    - Elements are updated using *various* attribute and property ***setters***
2. **Transition Management**:
    - Transitions are applied when elements are added or removed
    - Managed by the effect system with special handling for animations

## 6. Complete Flow Example

Let's trace through a complete example of how a signal update flows through the system:

1. **Initial State**:
    - A component has a signal `count = state(0)` 组件信号
    - A template displays `{count}` 组件显示信号值
    - This creates a text node with an effect that depends on `count`  创建依赖于信号的***effect***
2. **Update Trigger**:
    - User code calls `count.set(1)` or `count = 1` (with the `$state` syntax)
    - This calls `set()` in `sources.js` ***sigal 写***
3. **Signal Update**:
    - `internal_set()` updates the signal value to `1` 
    - Increments the write version 增加写版本
    - Calls `mark_reactions(count, DIRTY)` to mark all dependent effects as dirty
4. **Effect Scheduling**:
    - The text ***node*** effect is marked as dirty
    - `schedule_effect()` adds it to the ***queue***
    - If *not already* flushing, a ***microtask*** is scheduled
5. **Effect Execution**:
    - When the microtask runs, `flush_queued_root_effects()` is called
    - This processes all queued effects in ***topological*** order
    - *The text node effect* runs, which calls `get(count)` to read the new value
6. **DOM Update**:
    - The effect calls `set_text(text_node, 1)`
    - This updates the text node's content to "1"
    - Only this specific text node is updated, not the entire component
7. **Completion**:
    - The update is complete, and the UI now reflects the new state
    - The system is ready for the next update

## Conclusion

Svelte 5's reactivity system represents a significant evolution from previous versions. The signal-based approach with fine-grained DOM updates allows for more efficient and predictable reactivity. The system is built around a clear separation of concerns:
1. **Signal Management** (`runtime.js`): Tracks dependencies and schedules updates
2. **Effect System** (`effects.js`): Executes code when dependencies change
3. **DOM Operations** (`operations.js`): Efficiently updates only what needs to change
4. **Component Lifecycle** (`render.js`): Manages component creation, mounting, and destruction

This architecture enables Svelte 5 to provide a reactive programming model that is both powerful and efficient, with updates that target only the specific parts of the DOM that need to change.


# Svelte 5 核心响应式引擎解析

`runtime.js` 文件包含了 Svelte 5 的核心响应式引擎，这是 Svelte 5 响应式系统的核心所在。我将从概念和实现细节两个方面详细解释这个文件的关键功能。

## 1. 核心概念

在深入了解代码之前，先理解一些核心概念：

### 1.1 信号 (Signals)

信号是响应式系统的基础单位，它们代表可追踪的值。在 Svelte 5 中，信号主要有两种类型：

- **源信号 (Source)**: 可以直接设置的原始信号
- **派生信号 (Derived)**: 依赖于其他信号的计算值

### 1.2 反应 (Reactions)

反应是对信号变化的响应。主要有两种类型：

- **效果 (Effects)**: 当依赖的信号变化时执行的函数
- **派生计算 (Deriveds)**: 基于其他信号计算得出的值

### 1.3 依赖追踪 (Dependency Tracking)

系统自动追踪信号和依赖它们的反应之间的关系，建立依赖图。

## 2. 关键模块变量

`runtime.js` 中有一些关键的模块变量，它们在概念上非常重要：

### 2.1 反应状态变量
```js
export let active_reaction = null;  // 当前活跃的"反应" (效果或派生)
export let active_effect = null;    // 当前活跃的"效果"
export let derived_sources = null;  // 派生信号中创建的源信号
export let untracked_writes = null; // 跟踪未被"效果"监听的写入
export let captured_signals = null; // 收集在"特定时间窗口内"读取的信号
```

这些变量作为全局状态，用于追踪当前执行上下文中的反应和效果。它们类似于一个动态作用域系统，让 Svelte 能够在不显式传递参数的情况下了解当前的执行环境。

### 2.2 版本控制变量
```js
let write_version = 1;  // 用于源和派生的更新处理
let read_version = 0;   // 为每次读取版本化以避免重复依赖
```

这些变量用于跟踪信号的读写操作，确保依赖关系的正确建立和更新。每当有写入操作，`write_version` 会增加，帮助系统识别哪些值已经更新。

### 2.3 效果队列
```js
let queued_root_effects = [];  // 待处理的"根效果"队列
```

这个队列存储需要更新的根效果，在系统刷新时按特定顺序处理。

## 3. 核心函数解析

### 3.1 信号读取: `get`
```js
export function get(signal) {
	var flags = signal.f;
	var is_derived = (flags & DERIVED) !== 0; // bitmask has 1
	if (captured_signals !== null)
		captured_signals.add(signal); // Set
	// Register the dependency on the current reaction signal.
	if (active_reaction !== null && !untracking) {
		if (derived_sources !== null && derived_sources.includes(signal)) {
			e.state_unsafe_local_read(); // Reading state created inside the same derived is Forbidden.
			//  Consider using `untrack` to read locally created state
		}
		var deps = active_reaction.deps; // 当前反应的依赖项.
		if (signal.rv < read_version) {
			signal.rv = read_version;
			// If the signal is 访问同样的依赖,  像上次同样的顺序, increment `skipped_deps`
			// rather than updating `new_deps`, which creates GC cost
			if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
				skipped_deps++;
			} else if (new_deps === null) {
				new_deps = [signal];
			} else if (!skip_reaction || !new_deps.includes(signal)) {
				// Normally we can push duplicated dependencies to `new_deps`, but if we're inside
				// an unowned derived because skip_reaction is true, then we need to ensure that
				// we don't have duplicates
				new_deps.push(signal);
			}
		}
	} else if (is_derived &&  signal.deps === null && signal.effects === null) {
		var derived = /** @type {Derived} */ (signal);
		var parent = derived.parent;

		if (parent !== null && (parent.f & UNOWNED) === 0) {
			// If the derived is owned by another derived then mark it as unowned
			// as the derived value might have been referenced in a different context
			// since and thus its parent might not be its true owner anymore
			derived.f ^= UNOWNED;
		}
	}

	if (is_derived) {
		derived = signal;/** @type {Derived} */
		if (check_dirtiness(derived)) {
			update_derived(derived);
		}
	}

	if (
		DEV &&
		tracing_mode_flag &&
		tracing_expressions !== null &&
		active_reaction !== null &&
		tracing_expressions.reaction === active_reaction
	) {
		// Used when mapping state between special blocks like `each`
		if (signal.debug) {
			signal.debug();
		} else if (signal.created) {
			var entry = tracing_expressions.entries.get(signal);

			if (entry === undefined) {
				entry = { read: [] };
				tracing_expressions.entries.set(signal, entry);
			}

			entry.read.push(get_stack('TracedAt'));
		}
	}

	return signal.v;
}

```

`get` 函数是响应式系统的核心，它:
1. 读取信号的当前值
2. 如果在"反应Reaction(派生或效果)"上下文中被调用，会建立信号和当前反应之间的依赖关系
3. 如果是派生信号且需要更新，会触发派生信号的重新计算

这个函数使得依赖追踪变得自动化 - 只要在效果内部使用 `get(signal)` 读取信号，依赖关系就会被建立。

### 3.2 脏检查: `check_dirtiness`
```js
/**
 * Determines whether a derived or effect is dirty. If it is MAYBE_DIRTY, will set the status to CLEAN
 */
export function check_dirtiness(reaction) {
	var flags = reaction.f;
	if ((flags & DIRTY) !== 0)
		return true;

	if ((flags & MAYBE_DIRTY) !== 0) {
		var dependencies = reaction.deps;
		var is_unowned = (flags & UNOWNED) !== 0;

		if (dependencies !== null) {
			var i;
			var dependency;
			var is_disconnected = (flags & DISCONNECTED) !== 0;
			var is_unowned_connected = is_unowned && active_effect !== null && !skip_reaction;
			var length = dependencies.length;
			// If we are working with a disconnected or an unowned signal that is now connected (due to an active effect) then we need to re-connect the reaction to the dependency
			if (is_disconnected || is_unowned_connected) {
				var derived = reaction;/** @type {Derived} */ 
				var parent = derived.parent;
				for (i = 0; i < length; i++) {
					dependency = dependencies[i];
					// We always re-add all reactions (even duplicates) if the derived was
					// previously disconnected, however we don't if it was unowned as we
					// de-duplicate dependencies in that case
					if (is_disconnected || !dependency?.reactions?.includes(derived)) {
						(dependency.reactions ??= []).push(derived);
					}
				}

				if (is_disconnected) {
					derived.f ^= DISCONNECTED;
				}
				// If the unowned derived is now fully connected to the graph again (it's unowned and reconnected, has a parent
				// and the parent is not unowned), then we can mark it as connected again, removing the need for the unowned
				// flag
				if (is_unowned_connected && parent !== null && (parent.f & UNOWNED) === 0) {
					derived.f ^= UNOWNED;
				}
			}

			for (i = 0; i < length; i++) {
				dependency = dependencies[i];

				if (check_dirtiness(/** @type {Derived} */ (dependency))) {
					update_derived(/** @type {Derived} */ (dependency));
				}

				if (dependency.wv > reaction.wv) {
					return true;
				}
			}
		}

		// Unowned signals should never be marked as clean unless they
		// are used within an active_effect without skip_reaction
		if (!is_unowned || (active_effect !== null && !skip_reaction)) {
			set_signal_status(reaction, CLEAN);
		}
	}

	return false;
}
```

这个函数检查一个反应（效果或派生信号）是否需要更新，通过检查其标志位判断状态：

- `DIRTY`: 必须更新
- `MAYBE_DIRTY`: 需要检查依赖来决定是否更新
- 其他情况：不需要更新

### 3.3 效果更新: `update_effect`
```js
/**
 * @template V
 * @param {Reaction} reaction
 * @returns {V}
 */
export function update_reaction(reaction) {
	var previous_deps = new_deps;
	var previous_skipped_deps = skipped_deps;
	var previous_untracked_writes = untracked_writes;
	var previous_reaction = active_reaction;
	var previous_skip_reaction = skip_reaction;
	var prev_derived_sources = derived_sources;
	var previous_component_context = component_context;
	var previous_untracking = untracking;
	var flags = reaction.f;

	new_deps = /** @type {null | Value[]} */ (null);
	skipped_deps = 0;
	untracked_writes = null;
	skip_reaction =
		(flags & UNOWNED) !== 0 && (untracking || !is_updating_effect || active_reaction === null);
	active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;

	derived_sources = null;
	set_component_context(reaction.ctx);
	untracking = false;
	read_version++;

	try {
		var result = /** @type {Function} */ (0, reaction.fn)();
		var deps = reaction.deps;

		if (new_deps !== null) {
			var i;

			remove_reactions(reaction, skipped_deps);

			if (deps !== null && skipped_deps > 0) {
				deps.length = skipped_deps + new_deps.length;
				for (i = 0; i < new_deps.length; i++) {
					deps[skipped_deps + i] = new_deps[i];
				}
			} else {
				reaction.deps = deps = new_deps;
			}

			if (!skip_reaction) {
				for (i = skipped_deps; i < deps.length; i++) {
					(deps[i].reactions ??= []).push(reaction);
				}
			}
		} else if (deps !== null && skipped_deps < deps.length) {
			remove_reactions(reaction, skipped_deps);
			deps.length = skipped_deps;
		}

		// If we're inside an effect and we have untracked writes, then we need to
		// ensure that if any of those untracked writes result in re-invalidation
		// of the current effect, then that happens accordingly
		if (
			is_runes() &&
			untracked_writes !== null &&
			!untracking &&
			deps !== null &&
			(reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0
		) {
			for (i = 0; i < /** @type {Source[]} */ (untracked_writes).length; i++) {
				schedule_possible_effect_self_invalidation(
					untracked_writes[i],
					/** @type {Effect} */ (reaction)
				);
			}
		}

		// If we are returning to an previous reaction then
		// we need to increment the read version to ensure that
		// any dependencies in this reaction aren't marked with
		// the same version
		if (previous_reaction !== null) {
			read_version++;
		}

		return result;
	} finally {
		new_deps = previous_deps;
		skipped_deps = previous_skipped_deps;
		untracked_writes = previous_untracked_writes;
		active_reaction = previous_reaction;
		skip_reaction = previous_skip_reaction;
		derived_sources = prev_derived_sources;
		set_component_context(previous_component_context);
		untracking = previous_untracking;
	}
}
```

当效果的依赖发生变化时，此函数负责:

1. 保存当前上下文状态
2. 将当前效果设置为活跃效果
3. 执行效果函数
4. 更新依赖关系图
5. 恢复之前的上下文状态

### 3.4 同步刷新: `flushSync`
```js
/**
 * Synchronously flush any pending updates.
 * Returns void if no callback is provided, otherwise returns the result of calling the callback.
 * @template [T=void]
 * @param {(() => T) | undefined} [fn]
 * @returns {T}
 */
export function flushSync(fn) {
	var result;
	if (fn) {
		is_flushing = true;
		flush_queued_root_effects();
		result = fn();
	}
	flush_tasks();
	while (queued_root_effects.length > 0) {
		is_flushing = true;
		flush_queued_root_effects();
		flush_tasks();
	}
	return result
}
```

强制同步处理所有挂起的更新，确保状态变更立即反映到 DOM 上。在需要立即获取最新 DOM 状态的场景下非常有用。

### 3.5 反应更新: `update_reaction`
```js
/**
 * @template V
 * @param {Reaction} reaction
 * @returns {V}
 */
export function update_reaction(reaction) {
	var previous_deps = new_deps;
	var previous_skipped_deps = skipped_deps;
	var previous_untracked_writes = untracked_writes;
	var previous_reaction = active_reaction;
	var previous_skip_reaction = skip_reaction;
	var prev_derived_sources = derived_sources;
	var previous_component_context = component_context;
	var previous_untracking = untracking;
	var flags = reaction.f;

	new_deps = /** @type {null | Value[]} */ (null);
	skipped_deps = 0;
	untracked_writes = null;
	skip_reaction = (flags & UNOWNED) !== 0 && (untracking || !is_updating_effect || active_reaction === null);
	active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;

	derived_sources = null;
	set_component_context(reaction.ctx);
	untracking = false;
	read_version++;

	try {
		var result = /** @type {Function} */ (0, reaction.fn)();
		var deps = reaction.deps;

		if (new_deps !== null) {
			var i;
			remove_reactions(reaction, skipped_deps);
			if (deps !== null && skipped_deps > 0) {
				deps.length = skipped_deps + new_deps.length;
				for (i = 0; i < new_deps.length; i++) {
					deps[skipped_deps + i] = new_deps[i];
				}
			} else {
				reaction.deps = deps = new_deps;
			}

			if (!skip_reaction) {
				for (i = skipped_deps; i < deps.length; i++) {
					(deps[i].reactions ??= []).push(reaction);
				}
			}
		} else if (deps !== null && skipped_deps < deps.length) {
			remove_reactions(reaction, skipped_deps);
			deps.length = skipped_deps;
		}

		// If we're inside an effect and we have untracked writes, then we need to
		// ensure that if any of those untracked writes result in re-invalidation
		// of the current effect, then that happens accordingly
		if (
			is_runes() &&
			untracked_writes !== null &&
			!untracking &&
			deps !== null &&
			(reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0
		) {
			for (i = 0; i < /** @type {Source[]} */ (untracked_writes).length; i++) {
				schedule_possible_effect_self_invalidation(
					untracked_writes[i],
					/** @type {Effect} */ (reaction)
				);
			}
		}

		// If we are returning to an previous reaction then
		// we need to increment the read version to ensure that
		// any dependencies in this reaction aren't marked with
		// the same version
		if (previous_reaction !== null) {
			read_version++;
		}

		return result;
	} finally {
		new_deps = previous_deps;
		skipped_deps = previous_skipped_deps;
		untracked_writes = previous_untracked_writes;
		active_reaction = previous_reaction;
		skip_reaction = previous_skip_reaction;
		derived_sources = prev_derived_sources;
		set_component_context(previous_component_context);
		untracking = previous_untracking;
	}
}
```

这个函数负责实际执行反应的更新逻辑，包括：

1. 设置适当的***上下文***
2. ***追踪依赖***关系
3. 执行***反应函数***
4. ***更新依赖图***

## 4. 信号传播机制

Svelte 5 的响应式系统采用了有向无环图 (DAG) 模型来表示信号依赖关系：

1. **信号变更**: 当源信号的值变更时，它会标记所有依赖于它的反应为"脏"状态
2. **反应调度**: 脏反应被添加到更新队列中
3. **拓扑排序**: 反应按照拓扑顺序执行（确保父反应在子反应之前更新）
4. **细粒度更新**: 只有依赖关系发生变化的反应才会重新执行

这种方法确保了高效的更新传播，避免了不必要的计算。

## 5. 批处理和时序控制

Svelte 5 使用微任务队列来批处理更新，提高性能：

1. 当信号值变化时，不会立即执行所有效果
2. 变更被收集并排入队列
3. 在当前事件循环结束时执行（通过微任务）
4. 也提供了强制同步更新的方法（`flushSync`）

这种批处理机制大大提高了性能，特别是在多个信号同时变化的情况下。

## 6. 模式和特殊功能

### 6.1 `untrack`

```js
/**
 * When used inside a [`$derived`](https://svelte.dev/docs/svelte/$derived) or [`$effect`](https://svelte.dev/docs/svelte/$effect),
 * any state read inside `fn` will not be treated as a dependency.
 *
 * ```ts
 * $effect(() => {
 *   // this will run when `data` changes, but not when `time` changes
 *   save(data, {
 *     timestamp: untrack(() => time)
 *   });
 * });
 * ```
 * @template T
 * @param {() => T} fn
 * @returns {T}
 */
export function untrack(fn) {
	var previous_untracking = untracking;
	try {
		untracking = true;
		return fn();
	} finally {
		untracking = previous_untracking;
	}
}
```

允许在反应上下文内部执行代码而不建立依赖关系，对于需要读取但不依赖的值非常有用。

### 6.2 深度读取

```js
export function deep_read(value, visited = new Set()) {
  // 深度遍历对象并读取所有属性
}
```

递归读取对象的所有属性，确保整个对象树都被正确地注册为依赖。


`runtime.js` 是 Svelte 5 响应式系统的核心，它实现了一个精细、高效的依赖追踪和更新机制。通过巧妙的依赖图构建和更新传播算法，Svelte 实现了真正的细粒度更新.

## Svelte 5 中的反应系统与DOM更新

### 反应(Reaction)的类型

在Svelte 5中，反应(Reaction)确实主要包括两种类型：

1. **派生(Derived)**: 基于其他信号计算出的值
2. **效果(Effect)**: 当依赖的信号变化时执行的副作用函数

### DOM更新与效果(Effect)的关系

DOM更新本身不是一个独立的反应类型，而是通过特殊类型的效果(Effect)来实现的。具体来说，Svelte 5使用了一种称为**渲染效果(Render Effect)**的特殊效果类型来处理DOM更新。

在`effects.js`中，我们可以看到`render_effect`函数：

```js
/* @param {() => void)} fn
 * @returns {Effect} */
export function render_effect(fn) {
    return create_effect(RENDER_EFFECT, fn, true);
}
```

这个函数创建了一个带有`RENDER_EFFECT`标志的效果，这种效果专门用于DOM更新操作。

### DOM更新的实现机制

Svelte 5中的DOM更新是通过以下步骤实现的：

1. **模板编译**:
    - 在编译阶段，Svelte将组件模板编译成包含DOM操作的JavaScript代码
    - 模板中的动态部分（如`{count}`）会被转换为依赖于相应信号的渲染效果
2. **渲染效果创建**:
    - 对于模板中的每个动态表达式，Svelte创建一个渲染效果
    - 这个效果依赖于表达式中使用的信号
3. **细粒度更新**:
    - 当信号变化时，只有依赖这个信号的渲染效果会被标记为脏(dirty)
    - 系统会调度这些脏效果进行更新
4. **DOM操作执行**:
    - 渲染效果的函数体包含直接的DOM操作代码
    - 例如，文本节点的更新使用`set_text`函数：
```js
// 在render.js中
export function set_text(text, value) {
  var str = value == null ? '' : typeof value === 'object' ? value + '' : value;
  if (str !== (text.__t ??= text.nodeValue)) {
    text.__t = str;
    text.nodeValue = str + '';
  }
}
```
### 具体实现示例

让我们通过一个简单的例子来说明整个流程：

假设有一个Svelte组件：
```html
<script>
  let count = $state(0);
  function increment() {
    count++;
  }
</script>
<button on:click={increment}>Increment</button>
<p>Count: {count}</p>
```
编译后，Svelte会为`{count}`创建一个渲染效果，大致如下：
```js
// 创建DOM元素
const p = element('p');
const text1 = text('Count: ');
const text2 = text('');
// 创建渲染效果，更新文本节点
render_effect(() => {
  set_text(text2, get(count));
});
// 挂载到DOM
append(p, text1);
append(p, text2);
```

当`count`变化时：
1. `count`信号的写入版本号增加
2. 依赖于`count`的所有反应（包括上面的渲染效果）被标记为脏
3. 系统调度更新这些脏效果
4. 渲染效果执行，调用`set_text(text2, get(count))`更新文本节点
5. 只有这个特定的文本节点被更新，而不是整个组件或页面

### 特殊的效果类型

Svelte 5中有几种特殊的效果类型，用于不同的DOM更新场景：

1. **渲染效果(RENDER_EFFECT)**: 用于基本的DOM更新
2. **模板效果(template_effect)**: 用于处理模板片段
3. **分支效果(branch)**: 用于条件渲染（如`{#if}`块）
4. **块效果(block)**: 用于处理特殊的模板块（如`{#each}`）

这些不同类型的效果协同工作，实现了Svelte的高效DOM更新系统。