# parse
```js
parse(input, { modern: true, loose: cwd.split('/').pop()!.startsWith('loose-')})
//
    source = remove_bom(source);
    state.reset_warning_filter(() => false);
    state.reset(source, { filename: filename ?? '(unknown)', rootDir });
    const ast = new Parser(source, loose).root;
    return to_public_ast(source, ast, modern);
```

## reset
```js
reset(_source, ops}
如果选项中有目录且包含文件, 把文件名改成相对路径(如果不是)
//In some situations (ie,dealing with sourcemaps), you'nd 1-based line numbers:
locator = getLocator(source, { offsetLine: 1 }); // 源代码定位器.
warnings = [];ignore_stack = []; ignore_map.clear();
```

## construtor 
 1. 创建 fragment root 其他 bare, null, or empty default, meta with lang = ts?, 
 2. root 入 stack, (后面解析的也追加入此. 这就是stack和scope的魅力)
 3. 入栈 root.fragment 到 fragments
 
### 3. 解析状态函数 ParserState
```ts
type ParserState = (parser: Parser) => ParserState | void
```
解析状态, 首先是 fragment 函数
 `let state = fragment;` 
 遍历. 迭代解析函数(ParseState).在token耗尽之前分发解析工作函数
#技巧
 ```js
while (this.index/0 < this.template.length) {
	state = state(this) || fragment; // state如果丢失, 则重新使用fragment
}
```
###  fragment
fragment 函数是高阶函数, 返回三种解析函数
```js
/** @param {Parser} parser */
export default function fragment(parser) {
	if (parser.match('<')) return element; // 元素解析阶段
	if (parser.match('{')) return tag; // tag 解析阶段
	return text; // 文本解析
}
```
### tag
```js
保留入口`{`索引, 前进, 跳过空格, 
eat # 返回 open(parser) // tag 开始令牌, 这是tag中最重要的函数
eat : 返回 next(parser)
eat @ 返回 special(parser)
匹配 '/' 如果不是 开始注释, 也不是开始 //, 那么吃掉 /, 返回close(parser)
```
### tag module.open
```js
// if 
const block = parser.append({
	type: 'IfBlock',
	elseif: false,
	start,
	end: -1,
	test: read_expression(parser), // 返回node
	consequent: create_fragment(), // 返回可能的结构?
	alternate: null
});
// append 是 builder范式函数, last fragment追加node到nodes, 并返回node
append(node) {
	this.fragments.at(-1)?.nodes.push(node);
	return node;
}
// 
```
### eat
```js
eat(str, required = false, required_in_loose = true):
	if this.match(str):
		this.index += str.length;
		return true
	if (required && (!this.loose || required_in_loose))
		e.expected_token(this.index, str);
	return false;
```

### text
```js
// 文本解析 在其他片段之前耗尽
{
		type: 'Text', start //original,
		end: parser.index, //stepped
		raw: data, // text before other fragments
		data: decode_character_references(data, F) // !is_attribute_value
		// 如果不是属性值, 可以是转义字符,正则表达式会以转义连接
			// 如果是, 则显然不能是转义字符,正则表达式会以(?!=)...连接
}
```
##  read_expression
_1-parse\read\expression.js_ 
parse_expression_at(模板, ts?, 起始位置)
返回的是 baseNode Expression (svelte 各种表达式)
### parse_expression_at
- Acorn 会尽可能解析最长的有效表达式
_\1-parse\acorn.js_ 使用轮子,装配真正的js/ts解析器. 为什么不用babel和 ts, 太重了
Acorn返回的是acorn.Expression类型
```js
type Expression = Identifier
| Literal
| ThisExpression
| ArrayExpression
| ObjectExpression
| FunctionExpression
| UnaryExpression
| UpdateExpression
| BinaryExpression
| AssignmentExpression
| LogicalExpression
| MemberExpression
| ConditionalExpression
| CallExpression
| NewExpression
| SequenceExpression
| ArrowFunctionExpression
| YieldExpression
| TemplateLiteral
| TaggedTemplateExpression
| ClassExpression
| MetaProperty
| AwaitExpression
| ChainExpression
| ImportExpression
| ParenthesizedExpression
```
源码:
```js
/** @import { Comment, Program } from 'estree' */
/** @import { Node } from 'acorn' */
import * as acorn from 'acorn';
import { walk } from 'zimmerframe';
import { tsPlugin } from 'acorn-typescript';
import { locator } from '../../state.js';
const parser = !ts ? acorn.parser : acorn.Parser.extend(tsPlugin(..))
const ast = parser.parseExpressionAt(source, index, {
        onComment,
        sourceType: 'module',
        ecmaVersion: 13,
        locations: true
    });
 返回类似于
 {
  type: "Identifier", name: "foo",
  start: 5,
  end: 8,
  loc: { start: { line: 1, column: 5}, end: { line: 1, column: 8} },
}
```
### whitespace 处理
allow_whitespace 吃掉空白
require_whitespace, 先判断再吃

### comment 处理
```js
/* Acorn doesn't add comments to the AST by itself. This factory returns the capabilities to support `svelte-ignore` comments  `prettier-plugin-svelte` doesn't remove all comments when formatting.*/

function get_comment_handlers(source)
```


# 正则表达式
`/&(#(?:x[a-fA-F\d]+|\d+)(?:;)?|/gt\b(?!=)|lt\b(?!=))/`
这个正则表达式的确有点复杂，但我们可以一步步拆解它，理解它的含义。
**整体结构**

这个正则表达式由三个主要部分组成，用 `|`（或）分隔：

1.  `&#(?:x[a-fA-F\d]+|\d+)(?:;)?`
2.  `gt\b(?!=)`
3.  `lt\b(?!=)`

这意味着正则表达式会尝试匹配这三种情况中的任意一种。

**第一部分：`&#(?:x[a-fA-F\d]+|\d+)(?:;)?`**

这一部分用于匹配 HTML 实体编码。让我们进一步分解：

*   `&#`: 匹配字符序列 "&#"，这是 HTML 实体编码的开始。
*   `(?:...)`: 非捕获分组。这意味着括号内的内容会被视为一个整体，但不会被单独记住以供后续引用（如反向引用）。
*   `x[a-fA-F\d]+|\d+`: 这又是一个“或”的关系，包含两种情况：
    *   `x[a-fA-F\d]+`:
        *   `x`: 匹配字母 "x"，表示这是一个十六进制的实体编码。
        *   `[a-fA-F\d]+`: 匹配一个或多个十六进制字符（a-f、A-F、0-9）。
    *   `\d+`: 匹配一个或多个十进制数字。
*   `(?:;)?`:
    *   `(?:;)`: 非捕获分组，匹配分号 ";"。
    *   `?`: 表示前面的非捕获分组是可选的（可以出现 0 次或 1 次）。

**总结第一部分：** 这部分匹配 HTML 实体编码，可以是十六进制（如 `&#x2F;`）或十进制（如 `&#47;`），分号可选（有些 HTML 实体编码允许省略分号）。

**第二部分：`gt\b(?!=)`**

*   `gt`: 匹配字符序列 "gt"，这可能是 HTML 实体 `&gt;` (大于号) 的一部分。
*   `\b`: 单词边界。确保 "gt" 是一个完整的单词，而不是其他单词的一部分（如 "greater"）。
*   `(?!=)`: 负向先行断言 (negative lookahead)。它断言 "gt" 后面不能紧跟着等号 "="。

**总结第二部分：** 这部分匹配单词 "gt"，但后面不能有等号。这可能是为了匹配 `&gt;` 实体，同时排除 `&gt;=` (`>=`) 的情况。

**第三部分：`lt\b(?!=)`** 与第二部分类似 匹配 `&lt;` 实体，同时排除 `&lt;=` (`<=`)的情况。

**完整正则表达式的含义**

将三个部分结合起来，这个正则表达式的含义是：

匹配以下三种情况中的任意一种：

1.  HTML 实体编码（十六进制或十进制，分号可选）。
2.  单词 "gt"（但后面不能有等号）。
3.  单词 "lt"（但后面不能有等号）。

以下是一些匹配和不匹配的示例：

**匹配：**

*   `&#x2F;` (十六进制实体编码)
*   `&#60;` (十进制实体编码)
*   `&#123`
*   `gt`
*   `lt`
*  `&#x2f` (省略分号)

**不匹配：**

*   `&gt;=`
*   `&lt;=`
*   `greater`
*   `letter`
*   `&#xyz;` (无效的十六进制)
*   `&#;` (缺少数字)

这个正则表达式通过巧妙地结合字符组、量词、非捕获分组、单词边界和负向先行断言，实现了对特定模式的精确匹配。
