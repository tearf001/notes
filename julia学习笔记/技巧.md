## 语法糖
[语法糖](语法糖)

## 抽象类型如何构造

```julia
# 率属于 Number下面的类型的构造
(::Type{T})(x::T) where {T<:Number} = x
```
## 符号和标识符的构建

### Symbol() 
Symbol()  转换成字符串后, 生成字符串的**符号**
Symbol 期待字符串, 但如果不是,则进行字符串化(格式化)
```julia
	julia> Symbol("(1, 2)") == Symbol("(1,2)")
	false
	
	julia> Symbol("(1, 2)") == Symbol((1,2))
	true
```
多个参数的时候, Symbol 简单地进行拼接字符串,形成最终的符号.
当最终的字符串能成为字面量符号, 或者**字面量标识符**, 那么就是 `:identifier`这样的符号
### Symbol.(...x) 
#broadcast 点号运算

当参数是基本类型时, 无论多少个参数, 比如数值, 字符串的时候, 等同于 Symbol()
```julia
Symbol.("ab","c") == Symbol("ab", "c") == :abc
```
Symbol. 遇到 Tuple, Vector的时候呢它会分裂成多个, 分裂的部分和已构建的符号进行拼接, 直到所有的参数都使用Symbol处理,
分裂时机, 遇到有length()| iterate()的复合类型, 比如 Tuple, Vector, 遇到Vector 则变成 符号向量
```julia
Symbol.(1.0,2.0,"-start-", (true, 3), ("x", "y"), "-end.")
# 得到
(Symbol("1.02.0-start-truex-end."), Symbol("1.02.0-start-3y-end."))

Symbol.(1.0,2.0,"-start-", (true, 3), ("l", "r"), "-", [1,2], (3, 4), "-end")
# 得到
[Symbol("1.02.0-start-truel-13-end"), Symbol("1.02.0-start-3r-24-end")]
```
## 元组
### 参数实际上是元组
#### 定长元组

##### 枚举元组
```julia
Tuple{T1, T2, ...Tn} where {T1, T2, ...Tn}
```
##### 定长同类元组

N个元组
```julia
(t1, t2, ...tN) is a NTuple{N, T} # true
```

#### 不定长元组
##### 同类不定长
```julia
Tuple{Vararg{T}}) where {T}
```
##### 混合不定长
```julia
Tuple{String, Vararg{Int}}
("x", 1, 2, 3) isa Tuple{String, Vararg{Int}} # true
```

#### 其他元组

## built-in repl
```julia

fieldnames(DataFrame) # 可访问Type的 fieldnames
(:columns, :colindex, :metadata, :colmetadata, :allnotemetadata)

propertynames(DataFrame) # 可访问Type的 propertynames
(:name, :super, :parameters, :types, :instance, :layout, :hash, :flags)

names(DataFrame) # 不能在Type上访问names
	!ERROR: MethodError: no method matching names(::Type{DataFrame})

# 访问实例的 names
names(df)
	17-element Vector{String}:
	 "VendorID"
	 "tpep_pickup_datetime"
	 "tpep_dropoff_datetime"
	 "passenger_count"
	 ...

# 访问实例的 propertynames
propertynames(df)
	17-element Vector{Symbol}:
	 :VendorID
	 :tpep_pickup_datetime
	 :tpep_dropoff_datetime
	 :passenger_count
	 ...
# 不可访问 实例的 fieldnames(df) (私有保护)
```