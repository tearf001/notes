## 前言
	Julia版本1.1.0包含 37000个方法、138个宏（0.4%）和14个生成函数（0.04%）

1. 它们可以使解决方案更简洁、更易于理解。如果不使用元编程来编写代码，那么代码看起来会很丑陋，并且很难理解。 
2. 因为可以**生成**而不是写出源代码，所以可以**减少开发时间**，尤 其是可以删除**样板代码**。 
3. 可以提高性能, 因为代码是拼写的, 而不是通过其他高级编程结构(例如循环)执行的。比如`Unrolled.jl`

什么是宏

宏是接受[表达式](表达式),对其进行操作并返回新表达式的函数。可以用图4-3来理解。
```julia
# 输入
# 表达式只是源代码的抽象语法树AST表示形式。
表达式1
表达式2
...			=> 宏表达式 -> 表达式(待eval) # 实际上也可以返回普通值
表达式N
			
```
						图4-3

Julia中的宏工具允许你获取任何源代码并生成新的源代码。
然后执行结果表达式,就好像源代码是直接在适当的地方编写的一样。


为什么我们不能编写一个`接收表达式,生成新表达式,然后执行结果表达式`的常规函数?

有两个主要原因：
- 宏扩展在编译期间发生。这意味着该宏仅在使用它的位置执行一次。例如,当从函数调用宏时,在定义函数时执行该宏,以便可以编译该函数。
- 宏的结果表达式可以在当前范围内执行。在运行时,没有其他方法可以在函数本身内执行任何动态代码,因为根据定义,该函数已经编译。因此,计算任何表达式的唯一方法是在全局范围内执行。

## @code_lowered
任何 function call 都可以调用 `@code_lowered` 比如 `1+1, print("..")`
什么是降低的代码？在将源代码编译为二进制文件之前，Julia 编译器必须经过一系列处理。第一步是将代码解析为抽象语法树 （AST）格式，我们将在4.3节中学习该格式。之后，它会经历一个降 低过程，以扩展宏并将代码转换为具体的执行步骤。
## 宏的基本用法
```julia
macro hello()
	return :(
		for _ in 1:3
			println("hello world")
		end
	)
end

 @macroexpand @hello
:(for _ = 1:3
      #= REPL[634]:4 =#
      Main.println("hello world")
      #= REPL[634]:5 =#
  end)

macro hello(n) # n 是表达式, 不是值
   return :(for i in 1:$n
	   println(i)
   end) # end of Expr
end

@macroexpand @hello 42
:(for var"#112#i" = 1:42 * 42  
      #= REPL[647]:3 =#        
      Main.println(var"#112#i") # 可能不是内置的
      #= REPL[647]:4 =#
  end)
```

## 宏的扩展
@macroexpand	获取一个或多个表达式 并 返回 一个 新 表达式 的 过程 称为 宏 扩展。

**宏调用或者扩展时, 仍然强制传入其定义的参数**


## 宏扩展的时机
当定义了**包含宏的函数**时,宏将作为函数**定义**过程的一部分进行扩展。

```julia
macro identity(ex)
	dump(ex)
	return ex # 返回原表达式
end

julia> @identity x
Symbol x
1 # eval(:x)

julia> @identity :x
QuoteNode
  value: Symbol x
:x

julia> @identity 1+1
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Int64 1
    3: Int64 1
2 # eval(1 + 1)
```

```julia
function foo()
	return @identity 1 + 2 + 3 # 函数定义时就执行宏
end
@code_lower foo()
CodeInfo(
1 ─ %1 = 1 + 2 + 3
└──      return %1
)

function foo(x)
	return @identity x + 1 + 2 + 3 # 函数定义时就执行宏
end
foo(11) 返回的是 Main.x + 1 + 2 + 3

############## 挑战 任务 #################
macro ident(ex)
	dump(ex)
	return :($(esc(ex))) # 返回原表达式
end

function foo2(x)
	return @ident x + 1 + 2 + 3 # 函数定义时就执行宏
end
foo(11) 返回的是 :(11) + 1 + 2 + 3
```

显然, 编译器已经确定该宏用于 foo 函数 的 定义 中, 并且 为了 编译 foo 函数, 它 必须 了解@ identity 宏 的 作用。 因此,它 扩展 宏并将其融入到函数定义中.
> 定义时就已经展开, 因此重新修改了宏, 函数并不同步更新

## 宏的开发/表达式操作

> 以下代码有命名空间的问题

```julia
macro square(ex)
	return :($(ex), $(ex))
end

macro sq(ex)
	return :($ex, $ex)
end
```

看起来OK,但是有一个问题, 当宏使用变量的时候, 却使用的是当前模块的变量(非函数local变量)
```julia
function foo() 
	x_x = rand(); 
	return @square x_x 
end

@code_lowered foo()
CodeInfo(
	1 ─ x_x = Main.rand()
	└── return Main.x_x * Main.x_x # 简化等效代码
)
```

解决此问题的`简单方法`是在`插值`期间使用`esc函数`,以便将表达式直接放置在语法树中,而无须让编译器对其进行解析。以下是它的完成方式：

```julia
# 正确写法
macro squre_right(sym)
	return :($(esc(sym)) * $(esc(sym)))
end

julia> @code_lowered squre_right()
CodeInfo(
	1 ─      x_x = Main.rand()
	└──      return x_x * x_x # 简化等效代码
)
```

## 卫生宏
C 语言无法保证宏卫生

```julia
macro ntimes(n, ex)
	quote # 块表达式
		times = $(esc(n)) # 使用传入的n, 而非外部空间
		for i in 1 : times
			$(esc(ex))
		end
	end
end

# 等效
macro ntimes(n, ex)
	return :(begin
		times = $(esc(n)) # 使用传入的n, 而非外部空间
		for i in 1 : times
			$(esc(ex))
		end
	end)
end
```
函数中展开宏
```julia
function foo()
	times = 0
	@ntimes 3 println("hello world")
	println("times=",times)
end
```
## 自定义字符串字面量宏

`julia>typeof(r"hello")` #Regex
改进
```julia
DataFrame(x1 = rand(Float64, 1000), x2= rand(Int16, 1000), var"#3"=rand(Float32, 1000))

1000×3 DataFrame
  Row │ x1          x2      #3
      │ Float64     Int16   Float32
──────┼───────────────────────────────
    1 │ 0.100061     20486  0.765053
    2 │ 0.575128    -31735  0.982723
    3 │ 0.392644       740  0.988019
  ⋮   │     ⋮         ⋮         ⋮


macro ndf_str(s)
	nstr,spec = split(s,":")
	n = parse(Int,nstr) # number of rows
	types = split(spec, ",") # column type specifications
	num_columns = length(types)
	mappings =Dict(
		"f64"=>Float64,
		"f32"=>Float32,
		"i64"=>Int64,
		"i32"=>Int32,
		"i16"=>Int16,
		"i8"=>Int8
	)
	column_types=[mappings[t] for t in types]
	column_names=[Symbol("x$i") for i in 1:num_columns]
	
	# DataFrame(["a$i" =>rand(Int32, 2) for i in 1: 3]...)

	DataFrame([
		column_names[i] => rand(column_types[i],n) 
			for i in 1 : num_columns
	]...)	
end
```

为什么 我们 不能 为此 创建 一个 常规 函数？ 对于 这个 虚拟 示例, 我们 当然可以 这样做。 
但是, 在 某些 情况下(`r"hello"`), 使用 字符串 字面 量 可以 提高 性能。

## 生成函数的元编程工具

### Why
我们之前已经解释了如何创建返回表达式对象的宏。
由于宏在**语法级别**起作用,因此它们只能通过检查代码的**外观**来操纵代码。
但是,Julia是一个动态系统,其中在**运行时确定数据类型**。因此,Julia提供了创建生成函数的功能,使你可以**检查函数调用的数据类型**并返回表达式,就像宏一样。

返回表达式后, 将在调用站点对其进行求值。
为了了解为什么需要生成函数,让我们重新回顾宏的工作方式。假设我们创建了一个宏使它的参数
值加倍,如下所示：
```julia
macro doubled(ex)
	return :(2*$(esc(ex)))
end
#= 无论我们将什么表达式传递给该宏,它都将盲目地重写代码,从而使原始表达式加倍。假设有一天,
开发了一款超级计数器软件,它使我们可以快速计算两倍的浮点数。在这种情况下,我们可能希望系统仅针对浮点数切换到该功能,而不是使用标准乘法运算符。=#
#! 尝试改进, 但是不行!
macro doubled(ex)
	if typeof(ex) isa AbstractFloat
		return :(double_super_duper($(esc(ex))))
	else
		return :(2*S(esc(ex)))
	end
end
但宏无法做到这一点, 因为宏只能访问AST, 这是编译管道的较早部分,没有可用的类型信息.
ex 变量仅仅是一个表达式对象.这个问题可以用生成函数解决。
```
### What
**@generated**
```julia
@generated function doubled(x)
	return :(2*x)
end
```

- **普通函数**的参数接受**实际值**.
- **宏**的参数接受**表达式**
- **自定义字符串字面量宏** 特殊宏
- **生成函数**的参数包含**数据类型**, 而不是**实际值** . 如下:
```julia
typeof(Arg1)\
typeof(Arg2) > 生成函数   -> 表达式
typeof(ArgN)/

@generated function doubled(x)
	@show x # x = typeof(@runtime `x`)
	println(typeof(x)) # DataType
	return :(2 * x) # 返回表达式
end

@generated function doubled(x)
    if x<: AbstractFloat
        return :(println("doubled(x) with ", x))
    else
        return :(2 * x)
    end
end
```

## 问题
### 例子1 使用 unroll
```julia
using Unrolled
@unroll function hello_unroll(xs)
	@unroll for i in xs # 不能用 1:xs AssertionError: Can only unroll a loop over one of the function's arguments
	println("hello, at ", i)
	end
end
```

### 例子2——调整抽象语法树

假设我们要设计一个名为`@compose_twice`的宏,该宏采用一个简单的函数调用表达式,然后再次使用结果来调用同一函数。例如,如果我们运行`@compose_twice(sin(x))`,则应将其转换为`sin(sin(x))`。

```julia
# 简单实现
macro compose_twice(f, sym)
	return :( $(esc(f))
		(
			$(esc(f))($(esc(sym))))
		)
end
# 该宏 调用如下  @compose_twice(sin, 1) 或者 @compose_twice (-) 2
```

正式实现
```julia
macro f_twice(ex)
	@assert ex.head == :call
	@assert length(ex.args) == 2
	first = copy(ex) # 对象拷贝
	ex.args[2] = first
	return ex
end
```

