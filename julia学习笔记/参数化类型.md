在设计应用程序时，我们经常创建**复合类型**以方便地容纳多个字段元素。在最简单的形式中，复合类型**仅**充当**字段的容器**。
- 当创建越来越多的复合类型，这些类型中的某些看起来几乎相同。
- 在这些类型上运行的函数也可能非常相似。我们可能会得到很多样板代码。

"参数化类型"可以让我们为特定用途自定义常规复合类型，这不是很酷吗？
## 基础认识
```julia
# Parametric type examples
abstract type Asset end # 资产
abstract type Investment <: Asset end # 投资
abstract type Equity <: Investment end # 权益 

struct Stock <: Equity #股票
    symbol::String
    name::String
end

struct StockHolding{T <: Real} # 股票持有
    stock::Stock
    quantity::T
end
  
julia> stock = Stock("AAPL", "Apple, Inc.");
julia> holding = StockHolding(stock, 100 | 100.0 | 100//3)

StockHolding{Int64}(Stock("AAPL", "Apple, Inc."), 100 || 100.0 || 100//3)

# 扩展1, 基于参数化进行增强的复合类型
struct MarketStockHolding{T <: Real, P <: AbstractFloat}
    stock::Stock
    quantity::T
    price::P
    marketvalue::P
end

julia> holding = MarketStockHolding(stock, 100, 180.00, 18000.00) # Argu推理
MarketStockHolding{Int64,Float64}(Stock("AAPL", "Apple, Inc."), 100, 180.0, 18000.0)

julia> holding = MarketStockHolding(stock, 100, 180.00, 18000)
!!!ERROR: MethodError: no method matching MarketStockHolding(::Stock, ::Int64, ::Float64, ::Int64)

MarketStockHolding{Int, Float32}(stock, 1, 111, 222) # P-Type
MarketStockHolding{Int64, Float32}(Stock(:AAPL, "Apple Inc"), 1, 111.0f0, 222.0f0)

# 另一种扩展 基于参数化进行增强的抽象类型(而非复合类型)
abstract type Holding{P} end
# 参数化类型 的 扩展关系
Holding{Float64} <: Holding # true

!# 这里不使用扩展复合类型(包含price 和 marketvalue); 获得Holding{P}的扩展
mutable struct MarketStockHolding2{T, P} <: Holding{P}
    stock::Stock
    quantity::T
    price::P
    marketvalue::P
end

mutable struct CashHolding{P} <: Holding{P}
    currency::String
    amount::P
    marketvalue::P
end

julia> stock = Stock("AAPL", "Apple, Inc.");
julia> holding_the_safe = MarketStockHolding2(stock, 100, 180.00, 18000.00)

MarketStockHolding2{Int64,Float64}(Stock("AAPL", "..."), 100, 180.0, 18000.0)

# 类型关系
Holding{Int} <: Holding
MarketStockHolding2{Int64,Float64} <: Holding{Float64} # true
holding_the_safe isa Holding{Float64} # true   
```

## 进阶
类型参数是 #第一类实体 因此可以在函数主体内对其进行检查.

 Julia 中, 类型参数（例如 Array{T, N} 中的 T 和 N）不仅仅是简单的占位符，而是可以在运行时访问和操作的实际值。 这意味着你可以在函数内部检查和使用类型参数，就像使用普通变量一样。
 **示例:**

```julia
function my_function(x::Array{T, N}) where {T, N}
    println("元素类型: ", T)
    println("维度: ", N)
    # ... 其他操作 ...
end
!# 使用 Argu-Infer
my_function(ones(Int, 3, 4)) # 输出: 元素类型: Int64, 维度: 2.
my_function(zeros(Float32, 3)) # 输出: 元素类型: Float32, 维度: 1
```

在这个例子中：

- `::Array{T, N}` 定义了 x 的类型为 Array，并引入了类型参数 T 和 N。    
- `where {T, N}` #where 语法将 T 和 N 绑定到函数的签名中，使它们可以在函数体内访问。    

**对比其他语言：**

在一些其他语言中，例如 C++ 或 Java，类型参数通常只在编译时使用(部分使用RTTI)，用于类型检查和代码生成。 在运行时，类型参数的信息可能会丢失或难以访问。 而在 Julia 中，类型参数是第一类实体，这意味着它们在运行时仍然可用，并且可以像其他值一样进行操作。

**更进一步：**

由于类型参数是运行时值，你还可以根据类型参数的值进行条件逻辑或其他操作：

```julia
function my_function(x::Array{T}) where {T}
    if T <: Integer
        println("x 是整数数组", T)
    elseif T <: AbstractFloat
        println("x 是浮点数数组", T)
    else
        println("x 是其他类型的数组", T)
    end
end

my_function([1, 2, 3])       # 输出: x 是整数数组
my_function([1.0, 2.0, 3.0]) # 输出: x 是浮点数数组
my_function(["a", "b"])     # 输出: x 是其他类型的数组
```

# 扩展
#第一类实体 概念

 "第一类实体" (first-class citizen/object/entity/value) 的概念并非特定于类型系统，而是编程语言设计中更广泛的概念。

**"第一类实体" 的含义:**

一个实体被称为 "第一类实体"，如果它满足以下条件：
1. **可以在运行时创建:** 可以在程序执行过程中动态创建该实体。    
2. **可以赋值给变量:** 可以将该实体存储在变量中。    
3. **可以作为参数传递给函数:** 可以将该实体作为参数传递给函数。    
4. **可以作为函数的返回值:** 可以从函数中返回该实体。    

在 Julia 中，类型参数满足所有这些条件，因此被称为 "第一类实体"。 这与 C#、C++ 和 Java 等语言中的泛型/模板参数不同，后者主要在编译时使用，在运行时通常无法直接访问。

**"第一类实体" 的好处:**

- **更高的灵活性:** 在运行时根据类型参数的值实现更动态和灵活的代码。    
- **更好的代码重用:** 编写更通用的函数，处理不同类型的参数，而无需为每种类型编写单独的函数.
- **更强大的元编程能力:** 可以使用类型参数进行元编程，例如生成代码或进行代码特化。    

**Julia 的 "实" 类型 vs. TypeScript 的 "虚" 类型：**

你提到 Julia 的类型更 "实"，而 TypeScript 的类型更 "虚"。 这是对两种语言类型系统之间差异的很好的总结。

- **Julia:** 类型信息在运行时可用，可以用于优化性能、进行类型检查和实现动态调度。    
- **TypeScript:** 类型信息主要用于编译时的类型检查和代码提示，在编译成 JavaScript 后会被擦除，在运行时不可用。    

**三种设计的评价：**

- **Julia 的 "实" 类型:**    
    - **优点:** 运行时访问和操作，提供更大的灵活性; 性能优化、运行时类型安全、动态调度.
    - **缺点:** 可能会增加运行时开销，对类型系统的理解要求较高。        
- **传统编译型语言 (如 C++, Java, C#):** 类型信息主要用于编译时：    
    - **类型检查:** 编译器使用类型信息来检查代码的类型正确性，并在发现错误或发出警告.
    - **代码优化:** 编译器可以利用类型信息进行代码优化，例如生成更高效的机器码。        
    - **运行时类型信息 (RTTI):** 一些语言（Java/C#）支持 RTTI,允许在运行时获取对象类型信息.
      > RTTI 的功能通常有限，主要用于类型判断和反射等操作。 C++ 的 RTTI 更加强大，但也带来了额外的开销。
- - **TypeScript:** 类型信息主要用于开发阶段"虚":    
    - **类型检查:** TypeScript 编译器使用类型信息进行类型检查，帮助开发者在编写时发现错误。  
    - **代码提示:** 类型信息可以提供更好的代码提示和自动补全功能，提高开发效率。        
    - **编译到 JavaScript:** TypeScript 的类型信息在运行时会被擦除。


# 更多的例子
## 股票交易示例 Trade 

```julia
abstract type Asset end
abstract type Investment <: Asset end
abstract type Equity <: Investment end

struct Stock <: Equity
	symbol::Symbol
	name::String
end

@enum CallPut Call Put
struct StockOption <: Equity # 优先认股权，在指定时期内定价定额购股权
	symbol::Symbol
	type::CallPut
	strike:: Float64
	expiration::Date
end


# 交易
abstract type Trade end
@enum LongShort Long Short
struct StockTrade<:Trade
	type::LongShort
	stock::Stock
	quantity::Int
	price::Float64
end

struct StockOptionTrade <: Trade
	type::LongShort
	option::StockOption # 优先认股权
	quantity::Int
	price::Float64
end
```

![[Pasted image 20241120153605.png]]

代码重复
```julia
Base.sign(t::StockTrade) = t.type==Long ? 1 : -1
Base.sign(t::StockOptionTrade) = t.type==Long ? 1 : -1
#market value of a trade is simply quantity times price
payment(t::StockTrade) = sign(t) * t.quantity * t.price
payment(t::StockOptionTrade) = sign(t) * t.quantity * t.price
```

测试
```julia
stock=Stock(:AAPL,"Apple Inc")
option=StockOption(:AAPLC, Call,200,Date(2019,12,20))
# StockTrade
StockTrade(Long,Stock(:AAPL,"Apple Inc"),100,188.0)
# StockOptionTrade
StockOptionTrade(Long,StockOption(:AAPLC,Call, 200.0,Date(2019,12,20)),100,3.5)

```
设计参数化类型
为了简化此设计，我们可以参数化交易商品的类型。这是什么意思呢？意思是我们可以在这里利用抽象类型。Stock的超类型是Equity，而Equity的超类型是Investment。由于我们要保持泛型代码，并且购买/出售投资产品是相似的，因此我们可以选择接受作为Investment子类型的任何类型：

> instrument
> 器械; 乐器; 仪器; 工具; 促成某事的人/物; 受利用的人; 文据

```julia
struct SingleTrade{T} <:Trade where {T <: Investment}
	type::LongShort
	instrument::T
	quantity::Int
	price::Float64
end
# 简化写法
struct SingleTrade!{T <: Investment} <:Trade 
	type::LongShort
	instrument::T
	quantity::Int
	price::Float64
end

# 由于
SingleTrade{Stock} <: SingleTrade
SingleTrade{StockOption} <: SingleTrade

# 函数简化为
Base.sign(t::SingleTrade) = t.type == Long ? 1 : -1
#market value of a trade is simply quantity times price
payment(t::SingleTrade) = sign(t) * t.quantity * t.price

# 测试
SingleTrade(Long,stock,100,188.0) |> payment
SingleTrade(Long,option,1,3.50) |>payment
```

扩展
> 每个期权合药实上代表100股相关股票

```julia
# Calculate payment amount foroption trades (1oo shares per contract)
payment(t::SingleTrade{StockOption}) = sign(t) * t.quantity * 100 * t.price
```

迭代
到目前为止，我们对重构感到非常满意。但是，我们的老板刚刚打电话说，我们必须在下一个版本中支持配对交易。这个新需求为我们的设计增添了新的变化！
```julia
struct PairTrade{T<:Investment,S<:Investment} <: Trade
	leg1::SingleTrade{T}
	leg2::SingleTrade{S}
end

payment(t::PairTrade) = payment(t.leg1) + payment(t.leg2)

# 测试
pt=PairTrade(SingleTrade(Long,stock,100,188.0),SingleTrade(Short,option,1,3.5));
payment(pt)
```

## 开源包中找到参数化类型的使用

###  [ColorTypes.jl](https://github.com/JuliaGraphics/ColorTypes.jl)

![[colorstypes.jl.png]]

```julia
"""`Colorant(T,N)` is the abstract supertype of all types in ColorTypes, and refers to both (opaque) colors and colors-with-transparency (alpha channel) information. {T} is the element type (extractable with eltype) and N is the number of *meaningful* entries (extractable with length),that is,the number of arguments for the constructor.
"""
abstract type Colorant{T,N} end
#Colors (no transparency)
"""
Color{T,N} the abstract supertype of color/grayscale (opaque)
"""
abstract type Color{T,N} <: Colorant{T,N} end
"""
AbstractRGB(T) is an abstract supertype for rgb color types that can be constructed as C(r,g,b) and for which the elements can be extracted as red(c),green(c),blue(c).You should not! make ssumptions about internal storage order, number of fields,or representation.
RGB24 (AbstractRGB) is not parametric and has no fields named `r`,`g`,`b`.
"""
abstract type AbstractRGB{T} <: Color{T, 3} end # 三色

struct RGB24  <: AbstractRGB{N0f8}   color::UInt32 end
struct ARGB32 <: AbstractARGB{N0f8}  color::UInt32 end
struct Gray24 <: AbstractGray{N0f8}  color::UInt32 end

"""
RGB is the standard Red-Green-Blue (sRGB) colorspace.Values of the individual color channels range from 0 to 1 (black to saturated).If you want "Integer"(0~255) storage types,use `N0f8(1)` instead (see FixedPointNumbers).
"""
@source Fractional = Union{AbstractFloat, FixedPoint}
struct RGB{T<:Fractional} <: AbstractRGB{T}
	r::T # Red [0,1]
	g::T # Green [0,1]
	b::T # Blue [0,1]
	RGB{T}(r::T, g::T, b::T) where {T} = new{T}(r,g，b)
end
```

### [NamedDims.jl](https://github.com/invenia/NamedDims.jl)

For working with dimensions of arrays by name

让我们看一下NamedDimsArray的定义:
```julia
""" The NamedDimsArray constructor takes a list of names as Symbols,
one per dimension,and an array to wrap. """
struct NamedDimsArray(L, T, N, A <: AbstractArray{T,N}} <: AbstractArray{T, N}
	#L is for labels, it should be an NTuple{N,Symbol}
	data::A
end
```

不要被它的签名吓到，实际非常简单。
`NamedDimsArray`是抽象数组类型`AbstractArray{T,N}`的子类型。
- 它仅包含单个字段data，用于跟踪基础数据。
- 由于T和N已经是A中的参数，因此还需要在NamedDimsArray的签名中指定它们。
- L参数用于跟踪维度名称. 请注意: L未在任何字段中使用，但可方便地存储在类型签名本身中
- 主要**构造函数**定义如下:
```julia
@inline 
function NamedDimsArray{L}(orig::AbstractArray{T,N}) where {L,T,N}
    # 检查L是否包含N个符号的元组. 类型参数是第一类实体因此可以在函数主体内对其进行检查。
    if !(L isa NTuple{N,Symbol}) 
        throw(ArgumentError("A $N dim array needs a $N-tuple of dim names."))
    end
    return NamedDimsArray{L,T,N,typeof(orig)} (orig)
end
NamedDimsArray{(:x, :y)} # NamedDimsArray{(:x, :y), T, N} where {T, N}

```
