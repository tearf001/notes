```
             ----------------------------
             |         Asset             |
             ----------------------------
                 /          |         \      
              /             |            \
           /                |               \
 ------------------    ------------------    ----------
 |     Property    |   |   Investment    |   |   Cash  |
 ------------------    ------------------    ----------
       /        \               /        \
      /          \             /          \
 ----------  ------------   -------------   ----------
 |  House  | | Apartment|   | FixedIncome|  | Equity |
 ----------  ------------   -------------   ----------
								|               |
							-------         --------  
							| Bond|         | Stock |
							-------	        --------  
```

## 12.1 继承
  继承允许子类从其**超类**继承**字段** 和**方法**
## 12.2 行为子类型话

行为**子类型化**有时也称为接口继承(不使用是为避免与重载的单词继承混淆)。行为子类型化表示子类型仅从超类型继承**行为**。

#里氏替换原则 接受T类型的函数也可以接受T的任何子类型S并继续正常工作。

- OOP通常使用**接口**来实现行为子类型化. 
- Julia 将选择最具体的一种进行分派来实现**行为继承**(行为子类型化).
- 继承的问题
	- 正方形-矩形问题, 圆-椭圆问题
		- 继承在功能上可行，但在可维护性, 内存, 性能使用方面很糟糕的解决方案。
		- 继承不是扩展, 而是限制(private ?)
	- 脆弱的基类问题, 白盒继承
- 名义扩展 结构扩展 (此处**扩展**可以用继承, 子类型化替代)
	- julia 支持名义扩展; OOP通常使用名义扩展
	- 结构扩展, 隐式扩展, 也叫 #鸭子类型
	- #鸭子类型 的约束增强 通过 Holy Traits 来完成 (python不能)

## 12.3 协变, 不变 和 逆变
协变 (Covariance), 不变 (Invariance), 逆变 (Contravariance) 和双变 (Bivariance) 这四个概念描述的是**类型系统**中，当涉及到**更复杂的类型**（例如泛型类型`List<T>`、函数类型`Function[T, U]`）时，类型之间的子类型关系是如何保持或变化的。 

**核心概念：子类型关系 (Subtyping)** 通常指的就是 #里氏替换原则

**四个变性的定义：**

假设我们有两个类型 `T` 和 `S`，其中 `S <: T` (S 是 T 的子类型)。 现在考虑一个更复杂的类型构造器 `F`，它可以接受一个类型参数（例如，`List<T>` 或 `Function1[T, U]`）。

1. **协变 (Covariance):** 如果 `F[S] <: F[T]`，那么 `F` 在其类型参数上是协变的。
   * **直观理解:**  如果我有一个装满动物的笼子，那么一个装满狗的笼子也可以被认为是装满动物的笼子。 你可以安全地将 `List<Dog>` 赋值给 `List<Animal>` 类型的变量。

2. **逆变 (Contravariance):**  `F[T] <: F[S]`
   * **直观理解:**  考虑一个处理动物的函数 (`Function1[Animal,...]`)。 一个处理所有动物的函数，肯定也能处理狗。 因此，一个处理动物的函数可以被安全地传递给一个期望处理狗的函数的地方。 你可以安全地将 `Function1[Animal, ...]` 赋值给 `Function1[Dog, ...]` 类型的变量。

3. **不变 (Invariance):** 如果 `F[S]` 和 `F[T]` 之间没有任何子类型关系（除了自身），那么 `F` 在其类型参数上是不变的。  
   * **直观理解:**  一个装满狗的笼子 (`List<Dog>`) 和一个装满动物的笼子 (`List<Animal>`) 是不同的东西。  你不能直接将 `List<Dog>` 赋值给 `List<Animal>`，反之亦然。

4. **双变 (Bivariance):** 通常不存在。

**不同语言的处理方式:**
* **早期语言 (如 C):**  早期的编程语言通常没有复杂的类型系统，因此这些变性的概念并没有明确地被讨论和处理。  指针和结构体可以模拟一些类似的行为，但缺乏类型系统的保证。
* **Java:**  泛型默认是不变的。  通过通配符 (`? extends T`, `? super T`) 实现使用点变性。  数组是协变的（这是一个历史遗留问题，可能会导致运行时错误）。
* **C#:**  支持在接口和委托的声明处显式声明变性 (`out`, `in`)。  数组也是协变的。
* **Scala:**  支持在类或特质的声明处显式声明变性 (`+`, `-`)。
* **Kotlin:**  类似于 Scala，支持声明处变性 (`out`, `in`)。
* **TypeScript:**  函数参数逆变，返回值协变。 泛型类型变性取决于上下文，并且可以**显式**声明。
* **Python (动态类型):**  由于 Python 是动态类型的，类型检查发生在运行时，因此协变、逆变等概念在静态类型语言中的重要性在 Python 中相对较低。  但类型提示会考虑这些概念。
* **C++:**  模板（Templates）的行为类似于泛型，但它们在编译时进行实例化，并且默认是不变的。  可以使用更复杂的模板元编程技巧来模拟协变或逆变的行为。


### 12.3.1理解不同种类的变体

假设S是T的子类型，有四种不同的方法可以推断**参数化类型**P{S}和P{T}之间的关系:

- 协变：P{S}是P{T}的子类型（co variant中的co在此处表示相同的方向)
- 逆变：P{T}是P{S}的子类型（contra variant中的contra在此处表示相反的方向)
- 不变：既不是协变也不是逆变
- 双变