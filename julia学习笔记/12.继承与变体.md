```
             ----------------------------
             |         Asset             |
             ----------------------------
                 /          |         \      
              /             |            \
           /                |               \
 ------------------    ------------------    ----------
 |     Property    |   |   Investment    |   |   Cash  |
 ------------------    ------------------    ----------
       /        \               /        \
      /          \             /          \
 ----------  ------------   -------------   ----------
 |  House  | | Apartment|   | FixedIncome|  | Equity |
 ----------  ------------   -------------   ----------
								|               |
							-------         --------  
							| Bond|         | Stock |
							-------	        --------  
```

## 12.1 继承
  继承允许子类从其**超类**继承**字段** 和**方法**
## 12.2 行为子类型话
行为**子类型化**有时也称为接口继承(不使用是为避免与重载的单词继承混淆).行为子类型化表示子类型仅从超类型继承**行为**.

#里氏替换原则 接受T类型的函数也可以接受T的任何子类型S并继续正常工作.

- OOP通常使用**接口**来实现行为子类型化. 
- Julia 将选择最具体的一种进行分派来实现**行为继承**(行为子类型化).
- 继承的问题
	- 正方形-矩形问题, 圆-椭圆问题
		- 继承在功能上可行,但在可维护性, 内存, 性能使用方面很糟糕的解决方案.
		- 继承不是扩展, 而是限制(private ?)
	- 脆弱的基类问题, 白盒继承
- 名义扩展 结构扩展 (此处**扩展**可以用继承, 子类型化替代)
	- julia 支持名义扩展; OOP通常使用名义扩展
	- 结构扩展, 隐式扩展, 也叫 #鸭子类型
	- #鸭子类型 的约束增强 通过 Holy Traits 来完成 (python不能)

## 12.3 协变, 不变 和 逆变
协变 (Covariance), 不变 (Invariance), 逆变 (Contravariance) 和双变 (Bivariance) 这四个概念描述的是**类型系统**中,当涉及到**更复杂的类型**(例如泛型类型`List<T>`,函数类型`Function[T, U]`)时,类型之间的子类型关系是如何保持或变化的. 

**核心概念:子类型关系 (Subtyping)** 通常指的就是 #里氏替换原则

**四个变性的定义:**

假设我们有两个类型 `T` 和 `S`,其中 `S <: T` (S 是 T 的子类型). 现在考虑一个更复杂的类型构造器 `F`,它可以接受一个类型参数(例如,`List<T>` 或 `Function1[T, U]`).

1. **协变 (Covariance):** 如果 `F[S] <: F[T]`,那么 `F` 在其类型参数上是协变的.
   * **直观理解:**  如果我有一个装满动物的笼子,那么一个装满狗的笼子也可以被认为是装满动物的笼子. 你可以安全地将 `List<Dog>` 赋值给 `List<Animal>` 类型的变量.

2. **逆变 (Contravariance):**  `F[T] <: F[S]`
   * **直观理解:**  考虑一个处理动物的函数 (`Function1[Animal,...]`). 一个处理所有动物的函数,肯定也能处理狗. 因此,一个处理动物的函数可以被安全地传递给一个期望处理狗的函数的地方. 你可以安全地将 `Function1[Animal, ...]` 赋值给 `Function1[Dog, ...]` 类型的变量.

3. **不变 (Invariance):** 如果 `F[S]` 和 `F[T]` 之间没有任何子类型关系(除了自身),那么 `F` 在其类型参数上是不变的.  
   * **直观理解:**  一个装满狗的笼子 (`List<Dog>`) 和一个装满动物的笼子 (`List<Animal>`) 是不同的东西.  你不能直接将 `List<Dog>` 赋值给 `List<Animal>`,反之亦然.

4. **双变 (Bivariance):** 通常不存在.

**不同语言的处理方式:**
* **早期语言 (如 C):**  早期的编程语言通常没有复杂的类型系统,因此这些变性的概念并没有明确地被讨论和处理.  指针和结构体可以模拟一些类似的行为,但缺乏类型系统的保证.
* **Java:**  泛型默认是不变的.  通过通配符 (`? extends T`, `? super T`) 实现使用点变性.  数组是协变的(这是一个历史遗留问题,可能会导致运行时错误).
* **C#:**  支持在接口和委托的声明处显式声明变性 (`out`, `in`).  数组也是协变的.
* **Scala:**  支持在类或特质的声明处显式声明变性 (`+`, `-`).
* **Kotlin:**  类似于 Scala,支持声明处变性 (`out`, `in`).
* **TypeScript:**  函数参数逆变,返回值协变. 泛型类型变性取决于上下文,并且可以**显式**声明.
* **Python (动态类型):**  由于 Python 是动态类型的,类型检查发生在运行时,因此协变,逆变等概念在静态类型语言中的重要性在 Python 中相对较低.  但类型提示会考虑这些概念.
* **C++:**  模板(Templates)的行为类似于泛型,但它们在编译时进行实例化,并且默认是不变的.  可以使用更复杂的模板元编程技巧来模拟协变或逆变的行为.



### 12.3.1理解不同种类的变体
假设S是T的子类型,有四种不同的方法可以推断**参数化类型**P{S}和P{T}之间的关系:

- 协变:P{S}是P{T}的子类型(co variant中的co在此处表示相同的方向)
- 逆变:P{T}是P{S}的子类型(contra variant中的contra在此处表示相反的方向)
- 不变:既不是协变也不是逆变
- 双变
### 12.3.3 函数/方法参数是协变的
### 12.3.2 参数化类型不变
Julia 做出这个选择的主要原因是为了:

* **性能 (Performance):**  允许协变或逆变通常需要在运行时进行类型检查或者生成更复杂的代码.避免这些额外的开销.使得编译器能够更直接地理解类型信息,并进行更积极的优化.
* **避免运行时错误 (Avoiding Runtime Errors):**  在涉及到可变容器时,协变会带来潜在的类型错误.不变性避免了这种潜在的运行时风险.
* **类型推断的简化 (Simplifying Type Inference):** 不变性简化了类型推断的过程.当类型参数是不变的时,编译器更容易确定表达式的类型.
 
### 12.3.4 剖析函数类型
在Julia中,函数是第一类实体.这意味着函数可以作为变量传递
```julia
julia> all(
# tuple
all(x::Tuple{}) # @ Base tuple.jl:662
all(x::Tuple{Bool}) #@ Base tuple.jl:663
all(x::Tuple{Bool, Bool}) #@ Base tuple.jl:664
all(x::Tuple{Bool, Bool, Bool}) # @ Base tuple.jl:665
# reducedim
all(a::AbstractArray; dims) # @ Base reducedim.jl:994
all(f::Function, a::AbstractArray; dims) #@ Base reducedim.jl:995
# reduce
all(itr) # @ Base reduce.jl:1193
all(f, itr::Tuple) # @ Base reduce.jl:1323
all(f, itr) # @ Base reduce.jl:1301
# bitarray
all(B::BitArray) # @ Base bitarray.jl:1722
```
all函数可用于检查数组中所有元素的某个条件是否true 或**被运算**为true.
```julia
all(isodd, [1, 2, 3,4, 5])
typeof(isodd) <: Function # true
typeof(isodd) # typeof(isodd) (singleton of function isodd, subtype of Function)
typeof(isodd) |> supertype # Function
isabstracttype(Function) # true
```
函数作为参数的时候是协变
函数作为类型是逆变的

### 12.3.5确定函数类型的变体
Julia在推断函数类型或形式化函数类型方面没有提供太多帮助.
在某些强类型的静态0OP语言中,函数类型更正式地定义为**方法参数**和**返回类型**的**组合**.
假设一个函数接受三个参数并返回一个值.然后我们可以用以下符号描述该函数:
$$Tuple(T1, T2, T3) → T4$$
让我们继续动物界的例子,
> 本节目的: 确定`meet_partner`(finder) 的 `finder`的函数类型定义

定义一些新的变量和函数,如下所示:
```julia
abstract type Creature end
abstract type Mammal <: Creature end 

struct Cat <: Mammal name end
struct Dog <: Mammal name end
struct Crocodile <: Creature name end

female_dogs = [Dog("Pinky"), Dog("Pinny"), Dog("Moonie")]
female_cats = [Cat("Minnie"), Cat("Queenie"), Cat("Kittie")]

select(::Type{Dog}) = rand(female_dogs)
select(::Type{Cat}) = rand(female_cats)

Base.match(m::Mammal) = select(typeof(m))
Base.match(Dog("Astro")) # Dog~x
Base.match(Cat("Garfield")) # Cat~x
```

鉴于match函数只能返回Dog或Cat,我们可以按以下方式推断函数类型:
```julia
	typeof(finder) : Tuple(Mammal) → Mammal
```
假设我们再定义两个函数,如下所示:

```julia
#It's ok to kiss mammals :-)
kiss(m::Mammal) = "$m kissed!"
# Meet a partner
function meet_partner(finder::Function, self::Mammal)
	partner = finder(self)
	kiss(partner)
end

# 测试
meet_partner(match, Cat("Felix")) # "Cat Kittie kissed!
```

从meet_partner函数的角度来看,它期望finder函数接受Mammal 返回 Mammal
```julia
neighbor(::Mammal) = Crocodile()
```
鳄鱼,而不是哺乳动物, 函数失败; 函数类型的**返回类型**是协变的.

现在,函数类型的参数如何呢?meet_partner函数有望将任何哺乳动物传递给finder函数, 但更严格的finder函数会发生什么:
```julia
buddy(cat::Cat) = rand([Dog("Astro"),Dog("Goofy"),Cat("Lucifer")])
```

在这里,buddy函数接受猫并返回哺乳动物.如果我们将其传递给met_partner函数
```julia
meet_partner(buddy, Cat("Felix")) # "Cat Lucifer kissed!"
meet_partner(buddy, Dog("Chef")) # ERROR: MethodError:no method matching
```
因此,函数类型的参数**不是**协变的.它会是逆变的吗?
```julia
# SuperFinder = Tuple(Creature) → Mammal

super_finder(::Creature) = rand([Dog("rog"),Cat("kat")])
subtype_of_super_finder(::Crocodile) = Crocodile() # subtype of SuperFinder
```
好吧,如果`finder`的`参数`要成为逆变的, 必须接受Mammal的超类型, 假设是`Creatue`. 那么就是假设`subtype_of_super_finder`类型符合`Tuple(Mammal) → Mammal` 显然不是.

因此`函数类型`的`参数类型`是不变的.

更正式的表述如下所示:
```julia
Fun : Tuple(Mammal) → Mammal
SubFun : Tuple(T) → S where {T=Mammal, S<:Mammal}
```

只要T是Mammal, 而S是Mammal的子类型, 则类型`SubFun`是`Fun`类型的子类型.
<strike>有这样的说法, **在接受的东西上保持自由,在生产的东西上保持保守**</strike>

进行这种分析虽然很有趣,但考虑到Julia运行时**不支持**我们所看到的那样精细的函数类型

### 12.3.6 实现自己的函数类型分派
如之前所述,Julia为每个函数创建一个唯一的函数类型,它们都是Function抽象类型的子类型.我们似乎错过了多重分派的机会.
```julia
struct PredicateFunc{T}
	f::Function # 类型参数T和S用于表示f函数参数的类型
end
struct PredFunc f::Function end

# PredicateFunction{Number}(iseven) 
```
那么, `PredicateFunc{Number}(iseven)` 来构造`f`的`wrapper`.
由于Julia支持`可调用的结构`,像调用函数本身一样调用 PredicateFunc 结构:
```julia
(pred::PredicateFunc{T})(x::T;kws...) where {T} = pred.f(x; kws...)
(pred::PredFunc)(arg...;kws...) = pred.f(arg...;kws...)
```
> 简单的应用一下

```julia
struct Power x end
(p::Power)(y::Number) = p.x ^ y
Power(3)(4) == 3 ^ 4 # true
```
	
此函数仅将调用转发给pred.f包装的函数.看它是如何工作的.
```julia
PredicateFunc{Number}(iseven)(1) # false
PredicateFunc{Number}(iseven)(2) # true
(1:3;) .|> PredFunc(iseven)
```
让我们定义自己的all函数的安全版本,如下所示:
```julia
function safe_all(pred::PredicateFunc{T}, a::AbstractArray) where{T}
	all(pred, a)
end
function safe_all(pred::PredFunc, a::AbstractArray)
	all(pred, a)
end
```
safe_all函数将PredicteFunction{T,S}作为第一个参数,其约束条件为T是Any的子类型,而S是Bool的子类型.这正是我们希望断言函数使用的函数类型签名.
```julia
safe_all(PredicateFunc{Number}(iseven),[2,4,6]) # true
safe_all(PredicateFunc{Number}(iseven),[2,4,6,7]) # false
# 错误的类型传递
safe_all(println,[2,4,6,7]) # MethodError
# 但是注意 并不会成功! julia无法约束返回类型
safe_all(PredicateFunc{Number}(println),[2,4,6,7]) # 2 TypeError

# 错误的类型
safe_all(println,[2,4,6,7])
safe_all(PredFunc(println),[2,4,6,7]) # 2 TypeError ..
```
采用严格的类型匹配并参与多重分派,而不是采用普通的Function参数.关于变体就到这里了.

接下来,我们将继续并再谈参数化方法分派的规则.

## 12.4再谈参数化方法
### 12.4.1 指定类型变量
定义参数化方法时,我们使用where子句引入类型变量.
```julia
triple(x::Array{T,1} where {T <: Real}) = 3x
triple(x::Array{T,1}) where {T <: Real} = 3x # 更好的写法
```
更好的写法
- 在方法主体内部可以访问类型变量T.
- 如果类型变量T用于多个方法参数,则T可用于强制执行相同的值.

事实证明,第二点导致了Julia的分派系统中一个有趣的功能

### 12.4.2匹配类型变量
类型变量在方法签名中多次出现,来确定相同的类型.考虑以下函数:
```julia
add(a::Vector{T}, x::T) where {T <: Real} = (T, a .+ x)
add([1,2,3,4], 100) # (Int64, [101, 102, 103, 104])

add(Signed[1,2,3],Int8(1)) # (Signed,[2,3,4]) Signed 属于整数,包括所有的有符号
add(Unsigned[1,2,3],UInt8(1)) # (Unsigned, UInt64[0x000002, 0x3, 0x4])
```

### 12.4.3理解对角线规则
对角线规则表示,当`类型变量`在`协变位置`(即方法参数)多次出现时,它将被限制为仅与`具体`类型匹配.

请看以下函数:
```julia
diagonal(x::T,y::T) where {T <: Number} = T
diagonal(1,2) # Int64
diagonal(1.0, 2.0) # Float64
diagonal(Real(1), Real(2)) # Int64
diagonal(Real(1), Real(2.0)) # MethodError

diagonal(1::Real, 2.0::Real) # 失败 强制也不行 TypeError:typeassert
```


### 12.4.4 对角线规则的例外
当类型变量是明确确定在一个`不变`的位置时, 则允许它是`抽象`类型而不是具体类型.
```julia
not_diagonal(A::Vector{T},x::T,y::T) where {T <: Number} = T
not_diagonal([1,2,3],4,5) # Int64
not_diagonal(Signed[1,2,3],4,5) # Signed
```
参数化类型是`不变`的,因此我们`确定`T是Signed.由于Int64是Signed的子类型,因此所有内容都匹配.

### 12.4.5 类型变量的可用性
参数化方法的一个重要特征是where子句中`指定`的类型变量也可以从`方法主体`访问.
类型变量在`运行时`不可用的情况.考虑以下函数:
```julia
mytypes1(a::Vector{T},x::S) where (S<:Number, T<:S} = T
mytypes2(a::Vector{T},x::S) where {S<:Number, T<:S} = S
mytypes1([1,2,3],4) # Int64
mytypes2([1,2,3],4) # Int64
```

但是,情况并不总是乐观的.在其他情况下,它可能无法100%地工作.以下是一个例子.
```julia
mytypes1(Signed[1,2,3], 4) # Signed
mytypes2(Signed[1,2,3], 4) # UndefVarError S .. S 无法判定 是哪个超类
```
ERRoR:UndefVarError: S not defined
为什么在这里未定义S？首先，我们已经知道T是Signed，因为参数化类型是不变的。
作为where子句的一部分，我们还知道T是S的子类型。因此，S可以是Integer、Real、
Number甚至是任意类型。由于可能的答案太多，因此Julia运行时决定不向S分配任何值。
结论就是不要假设类型变量总是定义的，并且可以从方法中访问类型变量，尤其是对
于像这样的更复杂的情况。