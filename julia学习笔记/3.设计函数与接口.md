# 函数与参数
## 可选参数
```julia
function make_asteroids2(N::Int, pos_range=0:200, size_range=10:30)
	...
```
>和python不同,可选参数不能使用kw调用(explicit assign)

## 关键字参数
```julia
function make_asteroids2(N::Int; pos_range=0:200, size_range=10:30)
	pos_rand() = rand(pos_range)
	sz_rand() = rand(size_range)
	return [Widget("Asteroid#si",
				Position(pos_rand(),pos_rand()),
				Size(sz_rand(), sz_rand()))
	for i in 1:N]
end
```
>调用方式和python几乎一样
## 可变参数
`x::Vararg{T} 相当于x::T...where{T}`
## 匿名函数
```julia
function fire(f::Function, spaceship::Widget)
	if healthy(spaceship)
		f(spaceship)
	else
		println("operation aborted as spaceship isnot healthy")
	end
	return nothing
end
```
如何更优雅的调用`fire`?
```julia
# 定义匿名函数
f(fn,args...) = fn(args...)
# 测试
f(println, :a, "b", 'c') # OK
# MethodError: no method matching (::var"#13#14")(::Symbol, ::String, ::Char)
f(x->println(x), :a, "b", 'c') # 3参数进args即(::var"#13#14")(::Symbol, ::String, ::Char)

f(x...->println(x...), :a, "b", 'c')#语法错误

#友好写法
f(:a,"B",'c') do s... println(s...) end # 这里不写begin

#原始写法
f(s->begin
	move_up!(s, 100)
	println(s, "launched missile!")
	move_down!(s, 100)
end, spaceship)

# 推荐写法
fire(spaceship) do s
	move_up!(s,100)
	println(s, "launched missile!")
	move_down!(s,100)
end
```
# 多重分派

一个函数有多个方法,方法匹配规则:
**匹配最窄类型**

## 歧义检测
```julia
module Foo
	foo(x,y)=1
	foo(x::Integer,y)=2
	foo(x,y::Integer)=3
end
#
Test.detect_ambiguities(Foo)
```
## 原理
这种动态行为与在面向对象的编程语言中的多态非常相似。主要区别在于Julia支持多重分派，利用所有参数在**运行时**进行分派。相反，在Java中，只有**被调用的对象**才用于动态分派。一旦确定了适当的类以进行分派，那么当存在多个具有相同名称的重载方法时，方法参数将用于静态分派。

多重分派是一项强大的功能。与自定义数据类型结合使用时，它使开发人员可以控制针对不同场景调用的方法。如果你对多重分派有更多兴趣，可以在YouTube上观看标题为[The Unreasonable Effectiveness ofMultipleDispatch](https://www.youtube.com/watch?v=kc9HwsxE1OY)的视频。这是StefanKarpinski在JuliaCon2019会议上的演讲录像。接下来，我们将研究如何对函数参数进行参数化以提高灵活性和表达能力。

## 基于类型参数(泛型)
 ```julia
function explode(things::AbstractVector{T} ) where {T}
	for t in things
		println("Exploding"，t）
	end
end
```

请注意， Vector{ Asteroid} 实际上 是 AbstractVector{ Asteroid} 的 子 类型。 通常， 只要 B 是 A 的 子 类型， 我们 就 可以说 B{T} 是 A{T} 的 子 类型。
```julia
Vector{Asteroid} <: AbstractVector{Asteroid} # true
```
## 类型参数 vs 抽象类型
```julia
#specifying abstract/concrete types in method signature
function tow(A::Spaceship,B::Thing)
	"tow 1"
end
```
参数形式
```julia
julia> methods(tow)
# 1 method for generic function "tow" from Main:
 [1] tow(A::Spaceship, B::Thing)
     @ REPL[36]:1
```
类型参数
```julia
function tow(A::Spaceship, B::T) where {T <: Thing}
	"tow2"
end
# 直接替换前一个定义
methods(tow)
# 1 method for generic function "tow" from Main:
 [1] tow(A::Spaceship, B::T) where T<:Thing
     @ REPL[38]:1
```
# 设计和开发接口

创建 一个 名为 Vehicle 的 模块。
> 注意这里的 Vehicle 是模块, 不是模型

```julia
module Vehicle
#1.Export/Imports 导入导出
#2.Interface documentation 文档
#3.Generic definitions for the interface 面对未来的接口
end #module
```
1. 导入导出
```julia
# 1. Export/Imports
export go!
```
2. 文档
```julia
# 2 Interface documentation
# A Vehicle(v) must implement the following functions:
# power_on!(v) -turn on the vehicle's engine
# power_off!(v) -turn off thevehicle's engine
# turn!(v，direction)-steer the vehicle to the specifieddirection
# move!(v,distance)=move the vehicleby the specified distance
# position(v)-returns the （x,y）position of the.vehicle
```
3. 包含函数的**泛型**定义
	泛型函数，即没有任何签名或主体的函数
```julia
#3.Generic definitions for the interface
function power_on!end
function power_off!end
function turn! end
function move! end
function position end
```
 
4. 核心逻辑, 含测试代码
```julia
# 4.Game 1ogic
#Returns a travel plan from current position to destination
function travel_path(position, destination)
	return round(π/6,digits=2), 1000 #justa test
end
# Space travel logic
function go!(vehicle,destination)
	power_on!(vehicle)
	direction,distance=travel_path(position(vehicle),destination)
	turn!(vehicle,direction)
	move!(vehicle,distance)
	power_off!(vehicle)
	nothing
end
```