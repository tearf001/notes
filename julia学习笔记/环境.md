和其他lang相比, Julia的环境更轻量级, 通过toml元文件来管理julia和其包的版本
# Julia 环境
Julia 有
- **版本**环境 `@v_var`
- **项目**环境 `activate var` 
	在项目下生成 `Project.toml`, `Manifest.toml` (前者的补充)
	
```toml
[deps]
Example = "7876af07-990d-54b4-ab0e-23690620f79a"
JSON = "682c06a0-de6a-54ab-a142-c8b1cf79cde6"
```
> 不管哪个环境, 都在julia的[主目录]中生成引用包对应的结构树(多版本集中式), 类似于c#, pnpm 

自从 Julia 1.5, `https://pkg.julialang.org` is used as the **default** pkg server for JuliaLang.
### 在环境中执行Julia
#### 项目环境
```bash
julia --project=path/to/project/from/[current]
```
#### 临时环境
  结束时删除
```
activate --temp
```
#### Shared environments 共享环境
	只是存在于 `~/.julia/environments` 中的环境
	可以创建自定义共享环境
	`activate --shared mysharedenv` `@`
## [使用开源项目包](https://pkgdocs.julialang.org/v1/environments/#Using-someone-else's-project)
```
shell> git clone https://github.com/JuliaLang/Example.jl.git
Cloning into 'Example.jl'...
...

(@v1.9) pkg> activate Example.jl
Activating project at `~/Example.jl`

(Example) pkg> instantiate
  No Changes to `~/Example.jl/Project.toml`
  No Changes to `~/Example.jl/Manifest.toml`
```
如果项目包含清单`manifest.toml`，则安装的包将锁定版本。否则，它将解析与项目兼容的最新版本的依赖项。
`activate` 本身并不会安装, 它只是创建上下文环境. `instantiate` 则根据`Project.toml`(如果无`Manifest.toml`), 在当前上下文环境中解析Pkgs.


# 其他环境

## 设置源码编辑器
```bash 
#  ~/.julia/config/startup.jl OR REPL
ENV["JULIA_EDITOR"] = "vim"
```