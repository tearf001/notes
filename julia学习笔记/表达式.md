## 入门示例 低代码生成
```julia
using Unrolled

@unroll function hello(xs)
@unroll for i in xs
	println("hello:",i)
	end
end
```
假设 `seq = (1,2,3) #(1:3...)`

检查[其低代码](分析低代码), 发现并未循环 
>如果使用 seq = 1:3 可以发现其循环结构

## 表达式
Ast
```julia
struct Expr ...
end
```
分析结构
可以使用`Meta.parse`(接受字符串)分析, `dump(Any)`打印其结构

表达式字面量 以`:` 开头

当`:(`的对象是字面量 `(` 可以省略
	就是字面量本身, 比如 `:(1) , :("x")`	等同于	`:2 = 2, :"x" == "x"`
		
当`:(` 的 参数是标识符时
	`:(what_ever_is_it) = :what_ever_is_it`
当`:(` 的参数 是符号Symbol时, 
	不变
```julia
julia> :(:$) # 求值
:(:$)

julia> :(:=) # 已经移除,但是保留Symbol
:(:=)

julia> :(:(=)) # 赋值
:(:(=))

julia> :(:(x))
:(:x)
```

当`:(` 接的是

### 调用式
```julia
Meta.parse("x+1") |> dump
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Symbol x
    3: Int64 1

julia> Meta.parse("!x") |> dump
Expr
  head: Symbol call # 头参数
  args: Array{Any}((2,))
    1: Symbol !
    2: Symbol x
    
# 进阶 字面量
:(x + 1) |> dump
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Symbol x
    3: Int64 1
# 反过来构造则是 Expr(:call, :+ , :x, 1)
```
### 单式
```julia
Meta.parse("2") |> dump # 2 |> dump 就是 Int64 2
Meta.parse("x") |> dump # Symbol x
```

### 赋值式
```julia
:(x=1) |> dump
Expr
  head: Symbol = # 赋值
  args: Array{Any}((2,))
    1: Symbol x
    2: Int64 1
```
### 元组式及其他
```julia
:(+, x, 1) |> dump
Expr
  head: Symbol tuple # [] 则是 vect
  args: Array{Any}((3,))
    1: Symbol +
    2: Symbol x
    3: Int64 1
```
### 更多头节点或嵌套
![[Pasted image 20241101180218.png]]

### 源码 与 原理
```julia
quot(expr) = Expr(:quote, expr) # meta.jl

macro nospecialize(x)
    _expr(:meta, :nospecialize, x)
end

Expr(@nospecialize args...) = _expr(args...)
```
## 构造表达式

**表达式** 只是 一种数据结构， 以编程方式**构造**它们。它涉及**动态创建**新的代码结构。 
　 
Expr 构造函数具有以下函数 签名： 
`Expr(head::Symbol,args...)`
头节点 **始终** 带有 一个 符号(Symbol)。参数包含头节点期望的值

```julia
1. Expr(:(=), :x, 1)
:(x = 1)

2. Expr(:call, :x)
:(x())

3. Expr(:call, :x, 4, :y)
:(x(4, y))

4. Expr(:quote, :x)
:(:x)

5. Expr(:..., :x)
:(x...)

6. Expr(:function, :x)
:(function x end)

7. :(:(x+1)) # :(:expr_non_QuoteNode...)
# 这里的 expr_non_QuoteNode 不是符号, 否则 :(:expr_non_QuoteNode) 是 QuoteNode
   :($(Expr(:quote, :(x + 1))))

8. Expr(:quote, :(x+1)) == :(:(x + 1))
   true # 本质上是相同的表达式
   更多地, 
   # Expr(:quote, :expr_non_QuoteNode)) == :(:expr_non_QuoteNode) 非 QuoteNode
   打印 需要加上  :($(Expr(略)))
   :($(Expr(:quote, :(x + 1))))
 
```

### 0. 自述表达式(quote)
在 Julia 中，构造 quote 表达式 可用 `:($(Expr(:quote, 表达式expr)))` 的形式。自述
或者 `Meta.quot(...)`
源代码: `quot(expr) = Expr(:quote, expr) # meta.jl`
### 1. 简单表达式 
	:(x + y)
	Expr(:call, :+, :x, :y) 即 :(x + y)
### 2. 元组表达式
	简单元组 `Expr(:tuple, 1, 2) 即 :(1,2)
	命名元组
```julia
:(x=1, y=2) # 注意 (x=1, y=2) 则是 @NamedTuple{x::Int64, y::Int64}
:((x = 1, y = 2))	
```
### 3. 赋值表达式
	`Expr(:(=), :x, 1)` 即 `:(x=1)`
### 4. 嵌套表达式 
	`Expr(:call,:sin, Expr(:call, :*, :x, :y))` 即 `:(sin(x * y))`
### 5. quote 表达式
1. 作为 keyword:
	作为字面量关键字
	- 字面量值`:(2) == 2`
	- 特殊Symbol `:(=)  :($)` 
	- 当参数是标识符的时候, 可以省略`()`,`:(x)` 就是 `:x` 

2. quote 创建 多表达式(**block**), 而**不**使用Expr构造器
	#### 等效形式
	注意以下不同的表达式的含义, 以及 quote/end 的等效形式
	 ```julia
	julia> :(x=1;y=2) # 但不能写成 :(x=1 \n y=2) 后面这种写法必须使用begin..end包裹
	quote
	    x = 1
	    #= REPL[141]:1 =#  !!源代码信息
	    y = 2
	end
	```
	`(x=1; y=2)`的等效形式
	```julia
	:(x=1; y=2;) # 加不加`;`不影响
	:(begin x =1;y =2 end) 2 后面可以跟`;`但是end后面加,则意义略有区别.后者无返回
	:(begin x =1
		y=2
	  end)
```
	深入, quote/end结构如下
```julia
# queto/end
julia> :(x=1; y=2) |> dump
Expr
  head: Symbol block # 块
  args: Array{Any}((3,))
    1: Expr
      head: Symbol = # 赋值
      args: Array{Any}((2,))
        1: Symbol x
        2: Int64 1
    2: LineNumberNode # 源代码信息
      line: Int64 1
      file: Symbol REPL[142]
    3: Expr
      head: Symbol = # 赋值
      args: Array{Any}((2,))
        1: Symbol y
        2: Int64 2

julia> :(x=1, y=2) |> dump
Expr
  head: Symbol tuple # 命名元组
  args: Array{Any}((2,)) ... 嵌套, 略
```
	使用 quote/end 创建表达式
```julia
quote x =1; y=2 end # 块表达式 和 block略有区别(是inline, 且没有begin)
```

3. 作为 Expr的头节点
	`Expr(:quote, :x) => :(:x)` 类型是表达式
	`Expr(:quote, x)` 则是插值后表达式
		如果x是 符号, 则替换.
		如果是字面量值, 则构造出`:($(Expr(:quote, 1)))` 这样的字面量引用(eval之后 =1) 
4. 和`QuoteNode`区分
	 - `Expr(:quote, :x)` 的结果看起来和`QuoteNode(:x)` 一样, 都是`:(:x)`但是类型不同
	 - `:(:x)` 里面的`:x`就是 `QuoteNode(:x)` 注意只在表达式中:x 才是 `QuoteNode`		
	 -  对比**符号变量**插值和**quote变量**的插值	
	 ```julia
	 q_sym = QuoteNode(:hello)
	 :(x = $q_sym) # :(x = :hello)
	 
	 sym = :hello
	 :(x = $sys) # :(x=hello)
	 ```
### 6. block 表达式
```julia
:(begin
	println("hello")
	println("world")
  end) |> dump
Expr
	head: block
	args: Array{Any} ((4,))
		1. LineNumberNode 
		   args: 
     		   1. line: Int64 2
     		   2. file: Symbol REPL[43]
		2. Expr	
		    head: call
			args: 1. Symbol println 2.String "hello"
		3. LineNumberNode # 类似于1
		4. Expr # 类似于2
```
### 7. 构造条件式
if 也是 head 节点
```julia
julia>:(if2>1
	"good"
else
	"bad"
end)|>dump

Expr
	head:Symbol if
args: Array{Any}((3,))
	1:Expr
		head: Symbol call
		args: Array{Any}((3,))
			1:Symbol>
			2:Int642Condition
			3:Int64 1
	2:Expr # then 分支 block
		head: Symbol block
		args:Array{Any}((2,))
		1:LineNumberNode # Path #
			line:Int64 2
			file: Symbol REPL[45]
		2:String "good"
	3:Expr # else 分支 block
		head: Symbol block
		args:Array{Any}((2,))
			1:LineNumberNode # Path #2
				line:Int64 4
				file: Symbol REPL[45]
			2:String "bad"
```
### 8.循环表达式
```julia
:(for i in 1:5
	println("hello world")
end)|>dump
# 
Expr
head: Symbol for
args:Array[Any}((2,))
	1:Expr
		head:Symbol =
		args:Array{Any}((2,))
			1:Symbol i # Loop variable
			2:Expr
				head:Symbol call # 1:n 是range调用
				args:A3
					1. Symbol :
					2. Int64 1
					3. Int64 5
	2: Expr
		head: Symbol block
		args: A2
			1. LineNumberNode (line: Int64 n \n file: Symbol REPL[n2])
			2. Expr
				head: call
				args: A2
					1. Symbol println
					2. String "hello, world"
```
### 9. 函数表达式
```julia
julia>:(function foo(x;y=1)
return x + y + 1
end)|>dump
# 
Expr
head: Symbol function #
args:A2
	1:Expr
	head: Symbol call
	args: A3
		1:Symbol foo # Function name
		2:Expr
			head: Symbol parameters # Keyword arguments 注意这里不包括x
			args:A1 
				1:Expr
				head: Symbol kw # kw
				args: A2
					1:Symbol y
					2:Int64 1
		3:Symbol x # Arguments
	2:Expr
	head: Symbol block
	args: A2
		1:LineNumberNode
			line:Int642
			file: Symbol REPL[48]
		2:Expr
		head: Symbol return # Return value			
		args: A1
			1:Expr
			head:Symbol call # Function call
			args:A4
				1:Symbol + # 因为是连加,优化了
				2:Symbol x
				3:Symbol y
				4:Int64 1
```
### 10. 求值/插值表达式(高级)
本节内容应推迟到 `计算表达式\表达式变量插值`之后, 但是插值本身也可以是表达式.

求值表达式
`:$` 本身也是Symbol, 但是不能跳出 quote 表达式, 可以存在于 Expr 和 QuoteNode之中
`Expr(:$, :v)`  本质是`:($(Expr(:$, :v)))`,
	
其他表达式:
	可以把 `:( <:表达式> ) ` 视为 `:($Expr(:quote, <:表达式>)`
```julia
:(:(x = $v)) # 并不会对 v 求值
实际是 :($(Expr(:quote, :(x = $(Expr(:$, :v)))))) # 第一层并不求值

julia> :(:(x = $($v))) # 和Quote深度匹配
:($(Expr(:quote, :(x = $(Expr(:$, 2))))))

```

### 计算表达式
```julia
eval(:(x = 1))
```
#### 作用域
请注意表达式的计算实际上发生在全局范围内。我们可以通过在函数中运行eval来证明这一点。
更准确的说, 该 表达式在**模块上下文**中求值。(在**模块上下文**中被定义为副作用)


```julia
module WhereItHappen
function foo()
	eval(:(y=1))
end
end # module
# 
foo (generic function with 1 method)
julia> foo()
1
julia>WhereItHappen.y = 1
1
```
#### 表达式变量
##### 基本插值
```julia

```

# 问题 
## 问题1. 以 `:` 开头的有哪些类型?
答: 主要四种类型, 包括`标量`, `Symbol`, `QuoteNode`, `Expr` 
    其中 `Symbol`, `Expr`最常见, 标量不需要, QuoteNode 通常使用构造式
1. : 后面接 标量(数字, 字符串等字面量) 直接求值, 还是**标量**
2. : 后面接 标识符 是 Symbol 
	比如 
	```julia
	# 标识符 符号
	:x == :(x)
	# 特殊符号
	:... ==  :(...)
	:$  == :($)
	# 特殊符号的特殊情况
	:= 语法错误, 在高级版本中, julia移除了 :=(比值赋值)
	:(=) 赋值符号		
	```
	
3. : 后面接 必须要括号 包起来的表达式, 则有不同的情况
		- `:(:x)` QuoteNode
		- `:(其他)` 表达式 Expr

## 问题2 `:x` 在表达式(`:`)内部是什么
`QuoteNode{ value: Symbol x  }`

```julia
:(println(:x)) |> dump
####################
Expr
  head: Symbol call
  args: Array{Any}((2,))
    1: Symbol println
    2: QuoteNode
      value: Symbol x
```
## 问题3.  解析赋值表达式 `:(x = 1 + 1)`
```julia

julia>:(x=1+1) |> dump
Expr
	head: Symbol = 
	args:Array{Any}((2,))
		1:Symbol x
		2:Expr
			head: Symbol call # 注意这里不是 + 而是call (+, 1, 1)
			args: Array{Any}((3,))
				1:Symbol +
				2:Int64 1
				3:Int64 1

```
## 问题4 解析函数式 
```julia
dump(:(function foo(x;y=1)
       return x + y - 1
       end),maxdepth=10)
#
Expr
  head: Symbol function #
  args: A2
    1: Expr
      head: Symbol call
      args: A3
        1: Symbol foo
        2: Expr
          head: Symbol parameters
          args: A1
            1: Expr
              head: Symbol kw
              args: A2
                1: Symbol y
                2: Int64 1
        3: Symbol x
    2: Expr
      head: Symbol block
      args: A3
        1: LineNumberNode
          line: Int64 1
          file: Symbol REPL[189]
        2: LineNumberNode
          line: Int64 2
          file: Symbol REPL[189]
        3: Expr
          head: Symbol return
          args: A1
            1: Expr
              head: Symbol call
              args: A3 # (- (+ x y) 1)
                1: Symbol -
                2: Expr
                  head: Symbol call
                  args: A3
                    1: Symbol +
                    2: Symbol x
                    3: Symbol y
                3: Int64 1
```

## 问题5: 表达式自述
`:(:(1+1))`

最外层的`:()` 是表达式,  如果里面不是`数字, 字符串, 符号($, =, identifier symbol)`, 而是 `Expr`, 那么`:()`就是 **表达**里面的**表达式**. 

```julia
1. :(:(1+1)) # Expr
:( $( Expr(:quote, :(1+1)) ))

2. Expr(:quote, :(1+1)) # Expr
:($(Expr(:quote, :(1 + 1))))

3. Meta.quot(: (1+1))
:($(Expr(:quote, :(1 + 1))))
3. 检查
:(:(1+1)) == Expr(:quote, :(1+1)) # true
```

## 问题6 构建 #broadcast 表达式

```julia
:(Float64.(a)) |> dump
Expr
  head: Symbol .
  args: Array{Any}((2,))
    1: Symbol Float64
    2: Expr
      head: Symbol tuple
      args: Array{Any}((1,))
        1: Symbol a

 Expr(:., :Float64, Expr(:tuple, :a)) # 或者
 Expr(:., Float64, :(a,))  # 这个最好
```

## 高级
## 问题7 #refargs
```julia
Expr(:(=), Expr(:(::), nm, T), Expr(:ref, nm)) # :($nm::$T = $nm[])
```
实现CSV.jl的 #refargs 引用参数 [源代码](https://github.com/JuliaData/CSV.jl/blob/main/src/utils.jl#L610)
它有两种调用形式
1. `@refargs Context(a, b)` 变成 `Context(CSV.Arg(a), CSV.Arg(b))`
2. `@refargs function Context(a, b::Tb)` 变成 
	```julia
	function Context(a::CSV.Arg, b::CSV.Arg) begin a::Any = a[], b::Tb=b[]; $body end
	```
模拟实现
```julia
argerr(x...) = throw(ArgumentError(x...))
macro refargs(ex)
	ex isa Expr || argerr("pass expr to @refargs")
	ex.head == :call || ex.head == :function || argerr("expect function or definition")
	if ex.head == :call # :call {Any}[:Context, 参数1, 参数2]
		for i in 2:length(ex.args)
			ex.args[i] = Expr(:call, :(CSV.Arg), ex.args[i])
		end
		return esc(ex)
	else # ex.head = :function | args = {Any}[:Context(a, b), $body]
		refs = Expr(:block)
		ex.args[1].args # 同:call 即是 {Any}[:Context, 参数1, 参数2]
		fargs = ex.args[1].args
		for i in 2: length(fargs)
			arg = fargs[i]
			arg isa Symbol || arg.head == :(::) || argerr("不支持的参数表达式$arg")		
			(nm, T) = arg isa Symbol ? (arg, :Any) : arg.args # 解构
			# ref the arg. 准备放在body的前面
			push!(refs.args, Expr(:(:=), Expr(:(::), nm, T), Expr(:ref, nm)))
			# 同时注解farg为 CSV.Arg 而不是象:call (ie, wrap farg with CSV.Arg)
			fargs[i] = Expr(:(::), nm, :(CSV.Arg))
		end		
		pushfirst!(ex.args[2].args, refs) # block 参数通常是 [LNN节点, $line, LNN, $line]
		return esc(ex)
end
```
实操测试
```julia
# y = @refa function Stru(a, b::AbstractFloat) a + b end
argerr(x...) = throw(ArgumentError(x...))
macro refa(ex)
    ex isa Expr || argerr("must pass an expression to @refa")
    ex.head == :call || ex.head == :function || argerr("ex to be function/definition")
    if ex.head == :call
        println(":call ", ex.head, " ",ex.args) # :call Any[:Context, 参数1, 参数2]
        for i = 2:length(ex.args)
            println("arg$i is ", ex.args[i], " ", typeof(ex.args[i])) # 实参字面量的类型
            ex.args[i] = Expr(:call, :(CSV.Arg), ex.args[i])
        end
        return esc(ex) # 返回实例
    else # ex.head == :function
        println(":function ", ex.head, ex.args) # Any[:(Ctor(...)), quote ..body.. end]
        refs = Expr(:block)
        fargs = ex.args[1].args # 函数参数 [:(Ctor(a1, a2..)), quote$body$]		
        for i = 2:length(fargs) # 2:end = 构造函数参数
            arg = fargs[i]
            println("$i function arg is ", arg, ", ",typeof(arg), " has ")
            arg isa Symbol || arg.head == :(::) || argerr("!argument `$arg`")
            println("#$i")
            nm = arg isa Symbol ? arg : arg.args[1]
            T = arg isa Symbol ? :Any : arg.args[2]
            # nm::T = nm[]
            push!(refs.args, Expr(:(=), Expr(:(::), nm, T), Expr(:ref, nm)))
            fargs[i] = Expr(:(::), nm, :(Base.DataType)) # 将(a1..)转换为 (a1::CSV.Arg..)
            println("refs.args is ", refs.args, ",fargs[i] is ", fargs[i])
        end
        println("pushfirst $(ex.args[2].args), refs ", refs)
        pushfirst!(ex.args[2].args, refs)
        println(":最终 ", esc(ex))
        return esc(ex)
    end
end
```
测试
```julia
ex.head =:function 
ex.args = [:(Stru(a, b::AbstractFloat)), quote
    #= REPL[#xx]:1 =#   #= REPL[#xx]:1 =#
    a + b
end] # Any 数组
ex.args[1] = :(Stru(a, b::AbstractFloat))
ex.args[1].head = :call
ex.args[1].args = Any[:Stru, a, b::AF] # => fargs
#####
fargs[2] 即 (function 2th arg) is a, Symbol
refs.args is Any[:(a::Any = a[])]
fargs[i] is a::CSV.Arg # 重写注解
#####
fargs[3] 即 3th function arg is b::AbstractFloat, Expr
refs.args is [:(a::Any = a[]), :(b::AbstractFloat = b[])] # Any 数组
fargs[i] is b::CSV.Arg # 重写注解
#! pushfirst之前 !#
ex.args[2].args 是 Any[:(#= REPL[94]:1 =#), :(#= REPL[94]:1 =#), :(a + b)]
refs 是 begin
    a::Any = a[]
    b::AbstractFloat = b[]
end
# 最终 返回esc(ex)
$(Expr(:escape, ex => :(function Stru(a::CSV.Arg, b::CSV.Arg)
      begin
          a::Any = a[]
          b::AbstractFloat = b[]
      end
      #= REPL[94]:1 =#
      #= REPL[94]:1 =#
      a + b
  end)))
```
宏展开测试
```julia
@macroexpand  @refa test(a, 1) # :(test(CSV.Arg(a), CSV.Arg(1)))
@macroexpand @refa function test(a, b::AbstractFloat) a + b end
:(function test(a::CSV.Arg, b::CSV.Arg)
      begin
          a::Any = a[]
          b::AbstractFloat = b[]
      end
      #= 两行注释 =#
      a + b
  end)
```
或者
```julia
@refa function test(a, b::AbstractFloat) a + b end
function test(a, b::AbstractFloat) 
begin
  a:: Any = a[]
  b::AbstractFloat = b[]
end
a + b
end
√ test(1, 2.0) # 3.0
a = Ref(0) # Base.RefValue{Int64}(0)
√ test(a, 2.0) # 3.0
! a + 2.0 # MethodError: no method matching +(::Base.RefValue{Int64}, ::Float64)

```

## 柯里化 & 偏函数
```julia
struct FullyCurried end

macro curried(fdef)
    f = fdef.args[1].args[1]
    fargs = fdef.args[1].args[2:end]
    arity = length(fargs)
    body = fdef.args[2]
    err_str = "Too many arguments. Function $f only takes $arity arguments"
    quote 
        begin 
            function $f(args...)
                if length(args) < $arity
                    x -> $f((args..., x)...)
                elseif length(args) == $arity
                    $f(FullyCurried(), args...)
                else
                    throw($err_str)
                end
            end
            $f(::FullyCurried, $(fargs...)) = $body
        end
    end |> esc
end
julia> @curried foo(x, y, z) = (x^2 + y^2)/(x^2 + y^2 +z^2) 
foo (generic function with 2 methods) 
foo(1)(2)(3) # 0.35714285714285715 
foo(1, 2, 3) # 0.35714285714285715
```
### 支持kw的版本

> @curried fc(x, y, z; a, b=2)  =  x^2 + y^2 + z^2 + a + b
> 支持任意切割如 `fc(1, a=1)(2,3, a=2, b=4)`
 
```julia
struct FullyCurried end

macro curried(fdef)
    f = fdef.args[1].args[1]  # 函数名
    fargs = fdef.args[1].args[2:end]  # 函数参数，包括位置参数和关键字参数
    
    pos_args = [] # 位置参数
    kw_args = [] # 关键字参数
    for arg in fargs
        if isa(arg, Expr) && arg.head == :parameters
           for kwarg in arg.args
               push!(kw_args,kwarg)
           end
        else
            push!(pos_args, arg)
        end
    end

    arity = length(pos_args) #位置参数的数量
    body = fdef.args[2]  # 函数体
    err_str = "Too many args for func $f. Expected $arity positional args."

    quote
        begin
            function $f(args...; kwargs...)
                if length(args) < $arity
                    # 返回一个可以接收剩余参数的偏函数
                    (x...; kw...) -> $f((args..., x...)...; merge(kwargs, kw)...)
                elseif length(args) == $arity
                  # 位置参数已满，调用真正的函数
                  $f(FullyCurried(), args...; kwargs...)
                else
                    throw($err_str)
                end
            end

            # 真正执行的函数
            function $f(::FullyCurried, $(pos_args...); $(kw_args...))
               $body
            end
        end
    end |> esc
end
```

### python 版本
```python
# 基础版
from functools import partial

def curry(func):
    def curried(*args):
        print(f'{args}')
        if len(args) == func.__code__.co_argcount:
            return func(*args)
        else:
            return lambda x: curried(*(args + (x,)))
    return curried

@curry
def prod3(x, y, z):
    return x + y + z

prod3(3)(4)(5)
# 高级 注意这个版本实现的有问题
def arimean(*args):
    return sum(args) / len(args)

def curry(func):
    # to keep the name of the curried function:
    curry.__curried_func_name__ = func.__name__
    f_args, f_kwargs = [], {}
    def f(*args, **kwargs):
        nonlocal f_args, f_kwargs
        if args or kwargs:
            f_args += args
            f_kwargs.update(kwargs)
            return f
        else:
            result = func(*f_args, *f_kwargs)
            f_args, f_kwargs = [], {}
            return result
    
    return f
        
curried_arimean = curry(arimean)
curried_arimean(2)(5)(9)(5)

def fc(a,b,c,*,x=1,y):
  return a*a + b*b + c*c + x + y
cf = curry(fc)
```