# 第11章 传统的面向对象模式

有些人可能会问,我已经学习并适应了面向对象编程(OOP)的范式.如何在Julia中应用相同的概念?

`普遍的答案是,你不会以相同的方式解决问题.`

用Julia编写的解决方案看起来会有所不同,反映出不同的编程范式.尽管如此,  我们将涵盖GoF的$<Design Patterns:Elements of Reusable Object-Oriented Software>$ 中所有23种设计模式.

- 创建型模式
- 行为型模式
- 结构型模式

## 11.2创建型模式
创建型模式是指构造和实例化对象的各种方式.由于OOP将数据和行为组合在一起,并且一个类可以继承祖先类的结构和行为,因此在构建大型系统时,还涉及其他级别的复杂性.
通过设计"不允许字段以抽象类型声明,也不允许从具体类型创建新的子类型",Julia已经避免了许多问题.但是,其中某些模式在某些情况下可能会有所帮助.

创建模式包括工厂方法模式,抽象工厂模式,单例模式,建造者模式和原型模式.

### 11.2.1 工厂方法模式
工厂方法模式的思想是提供一个单一的接口,以创建与接口兼容的不同类型的对象,同时向客户端隐藏实际的实现.这种抽象使客户端与功能提供者的基础实现脱钩.例如,程序可能需要在输出中格式化一些数字.在Julia中,我们可能要使用Printf包来格式化数字,如下所示.
```julia
using Printf
@sprintf("%d", 1234) # "1234"
@sprintf("%.2f",1234.567) # "1234.57"
```
也许我们不想与Printf包结合使用,因为我们将来希望切换并使用其他格式化包.为了使应用程序更加灵活,我们可以设计一个接口,可以根据数字的类型进行格式化.doc字符串中描述了以下接口:
```julia
# format(::Formatter, x::T) where {T <: Number}
# Format a numberxusing the specified formatter.Returns a string.
function format end
```
format函数采用formatter和数值x,然后返回格式化的字符串.Formatter类型定义如下:
```julia
abstract type Formatter end
struct IntegerFormatter <: Formatter end
struct FloatFormatter <: Formatter end
```
然后,工厂方法基本上会创建用于分派目的的单例类型:
```julia
formatter(::Type{T}) where {T <: Integer} = IntegerFormatter()
formatter(::Type{T}) where {T <: AbstractFloat} = FloatFormatter()
formatter(::Type{T}) where T =error("No formatter defined for type $T")
```
利用Printf包,默认实现如下所示:
```julia
using Printf
format(nf::IntegerFormatter, x) = @sprintf("%d",x)
format(nf::FloatFormatter, x) = @sprintf("%.2f",x)
# 将所有内容放入FactoryExample模块中,我们可以运行以下测试代码:
function test()
	intf=formatter(Int)
	println(format(intf,1234))
	ff=formatter(Float64)
	println(format(ff,1234))
end

[Int, Float64] .|> formatter .|> y -> format(y,1234)
[Int, Float64] .|> x -> formatter(x) |> y->format(y,1234) # -> 优先级高于 |>
# 等效于 
[Int, Float64] .|> x -> (#==# formatter(x) |> y->format(y,1234)#==#)

@curried fmt(T; value) = format(formatter(T), value)
@curried fmt2(value, T) = format(formatter(T), value)
[Int, Float64] .|> fmt(value=1234)
[Int, Float64] .|> fmt2(1234)
```

### 11.2.2 抽象工厂模式
抽象工厂模式用于通过一组工厂方法创建对象,这些方法从具体实现中抽象出来.抽象工厂模式可以看作是一个工厂中的工厂.
我们可以探索一些示例,构建支持Microsoft Windows和macOS的多平台GUI库.当我们要开发跨平台的代码时,我们可以利用这种设计模式.图11-1的UML图描述了这种设计.
```
                  ------------
                  |  Client  |
                  ------------
                        |
                        |  uses
                        V
         ----------------------
         |   Abstract Factory |
         |--------------------|
         |   createButton()   |
         |   createLabel()    |
         ----------------------
                /           \
               /             \
     -------------------      -------------------
     |  MacOSFactory   |      | WindowsFactory  |
     |-----------------|      |-----------------|
     | createButton()  |      | createButton()  |
     | createLabel()   |      | createLabel()   |
     -------------------      -------------------
              |                          |
              |    return                |    return
              V                          V
  --------------   -------------   ------------  --------------
  |  MacOSBtn  |  | MacOSLabel |  | WindowsBtn| | WindowsLabel|
  --------------   -------------   ------------  --------------
       (Button)      (Label)          (Button)       (Label)
```
这里介绍两种GUI对象:Button和Label.它们在Microsoft Windows和macOS平台的概念相同.客户端不在乎如何实例化这些对象.相反,它要求抽象工厂GUIFactory返回工厂(MacOSFactory或WindowsFactory),该工厂支持多个工厂方法来创建依赖于平台的GUI对象的工厂.
Julia的实现可以简单地用适当的抽象和具体类型建模.让我们从操作系统级别开始:
```julia
abstract type OS end
struct MacOS <: OS end
struct Windows<: OS end
```
我们打算在之后将MacOS和Windows用作单例类型以进行分派.现在,让我们继续并按如下所示定义抽象类型Button和Label.此外,我们分别为每种类型定义了show方法:
```julia
abstract type Button end
Base.show(io::IO,x::Button) = print(io,"'$(x.text)' button")
abstract type Label end
Base.show(io::IO,x::Label)  = print(io,"'$(x.text)' label")

#Buttons
struct MacOSButton <:Button
	text::String
end
struct WindowsButton <:Button
	text::String
end
#Labels
struct MacOSLabel <:Label
	text::String
end
struct WindowsLabel <:Label
	text::String
end
```
由于工厂方法依赖于平台, 利用OS特性和多个分派来调用正确的make_button或make_label函数:
```julia
# Generic implementation using traits
current_os() = MacOS() # should get from system
make_button(text::String) = make_button(current_os(),text)
make_label(text::String) = make_label(current_os(),text)
```
为了进行测试,我们对current_os函数进行硬编码, 最后,我们需要为每个平台实现以下特定函数:
```julia
# Macos implementation
make_button(T::MacOS, text::String)= begin println(T);MacOSButton(text) end
make_label(::MacOS,  text::String)=MacOSLabel(text)
# Windows implementation
make_button(T::Windows,text::String)=begin println(T);WindowsButton(text) end
make_label(::Windows, text::String)=WindowsLabel(text)
```
我们的简单测试仅涉及调用make_button函数.
```julia
button = make_button("Click")
```

### 11.2.3 单例模式
单例模式用于创建对象的单个实例.通常在应用程序启动时或在首次访问时**延迟创建**它.对于多线程应用程序,如何考虑不当, 可能会违背**单例对象的实例化必须仅发生一次**规则.
假设我们要创建一个称为AppKey的单例,该单例用于在应用程序中进行加密:
```julia
# AppKey contains an app id and encryption key
struct AppKey
	appid::String
	value::UInt128
end
```
最初,我们可能会想使用全局变量.既然我们已经了解了全局变量对性能的影响,就可以应用在第6章中学习的全局常量模式.本质上, 将Ref对象创建为占位符,如下所示:
```julia
# placeholder for AppKey object.
const appkey = Ref{AppKey}() # Base.RefValue{AppKey}(#undef)
```
首先创建appkey全局常量而不为其分配任何值,但是可以在实例化单例时对其进行更
新.单例的构造可以如下进行:
```julia
function construct()
	global appkey
	if !isassigned(appkey)
		ak = AppKey("myapp", rand(UInt128))
		println("constructing $ak")
		appkey[]=ak
	end
	return nothing
end
```
只要有一个线程,此代码就可以正常工作.如果我们使用多个线程对其进行测试,则$isassigned$检查是有问题的.例如,两个线程可能会检查是否同时分配了键,并且两个线程都可能认为单例对象需要实例化.在这种情况下,我们最终构造了两次单例. 测试代码如下所示:
```julia
# $ JULIA_NUM_THREADS=4 julia # --project=.
# julia -t 4
struct AppKey
	appid::String
	value::UInt128
end
const appkey = Ref{AppKey}() # Base.RefValue{AppKey}(#undef)
function construct()
	global appkey
	if !isassigned(appkey)
		ak = AppKey("myapp", rand(UInt128))
		println("constructing $ak")
		appkey[]=ak
	end
	return nothing
end
function test_multithreading()
	println("Number of threads: ", Threads.nthreads())
	global appkey
	Threads.@threads for i in 1:8
		construct()
	end
end
```
我们可以如下演示问题,让我们用四个线程启动Julia REPL.
```julia
Number of threads: 4 # 有几个线程, 创建几个实例
constructing AppKey("myapp", 0xf6e0d97ec75b380053b23699241df05f)
constructing AppKey("myapp", 0x747405110d80b905dbbeb97e6b59aabc)
constructing AppKey("myapp", 0x5889c70ee693ffd806e4b0d73e1bd27a)
constructing AppKey("myapp", 0xd7137ea0f181fd6a15e9ed0b9a361bfc)
```

要使用锁,我们可以如下修改construct函数.
```julia
# 注意, appkey_lock 和 appkey不同, 它是创建时候就分配了单例. 而后者是延迟创建.
const appkey_lock=Ref(ReentrantLock()) # 直接使用defined lock contructed

# change construct() to acquire lock before construction, and release it finally
function construct()
	global appkey
	global appkey_lock
	lock(appkey_lock[]) # Acquire lock
	try
		if !isassigned(appkey)
			ak = AppKey("myapp",rand(UInt128))
			println("constructing $ak")
			appkey[] = ak
		else
			println("skipped construction")
		end
	finally
		unlock(appkey_lock[]) # Release lock
		return appkey[]
	end
end
```
在检查是否已分配`appkey[]`之前,我们必须首先获取锁.当我们完成构造单例时
```julia
test_multithreading()
Number of threads: 4
constructing AppKey("myapp", 0x400e3916c8d1624001d01334a7f40e3f)
skipped construction
skipped construction
skipped construction
skipped construction
skipped construction
skipped construction
skipped construction
```

### 11.2.4 建造者模式
建造者模式用于通过**逐步构建**简单的组件来构建复杂对象.我们可以想象工厂组装线以类似的方式工作.在这种情况下,产品会越来越多地逐步组装在一起,并且在组装线的末端,产品就会完成并准备就绪.
这种模式的一个好处是,建造者代码看起来像线性数据流,并且对于某些人来说更易
于阅读.在Julia中,我们可能想编写如下代码:
```julia
car = Car() |>
	add(Engine("4-cylinder 1600cc Engine")) |>
	add(Wheels("4x20-inch wide wheels")) |>
	add(Chassis("Roadster Chassis"))
```
本质上,这正是第9章中描述的函数管道模式.对于此示例,我们可以开发用于构建每个零件(例如轮子,引擎和底盘)的高阶函数.以下代码说明了如何构建用于创建轮子的柯里化(高阶)函数:
```julia
function add(wheels::Wheels)
	return function (c::Car)
		c.wheels=wheels
		return c
	end
end
```
add函数仅返回一个匿名函数,该匿名函数将Car对象作为输入并返回增强的Car对象.同样,我们可以为Engine和Chassis类型开发类似的函数.一旦这些函数准备就绪,我们就可以通过简单地将这些函数调用链接在一起来制造汽车.接下来,我们将讨论原型模式.

### 11.2.5原型模式
原型模式用于通过克隆现有对象或原型对象中的字段来创建新对象.当因为**构造有些对象很难或很费时**,所以制作该对象的副本并通过进行**少量修改**将其称为新对象时,原型模式很有用.

由于Julia将数据和逻辑分开,因此对象的副本与复制内容实际上是一样的.这听起来很容易,但是我们不应忽视浅拷贝和深拷贝之间的区别.一个对象的浅拷贝只是一个所有字段都从另一个对象复制而来的对象.通过递归地进入对象的字段并复制其底层字段来创建对象的深拷贝.这样,由于某些数据可以与原始对象共享,因此可能不希望使用浅拷贝.
为了说明这一点,让我们考虑一个银行账户示例的以下结构定义:
```julia
mutable struct Account
	id::Int
	balance::Float64
end
struct Customer
	name::String
	savingsAccount::Account
	checkingAccount::Account
end
```
现在,假设我们有一个从以下函数返回的Customer对象数组:
```julia
function sample_customers()
	a1=Account(1,100.0)
	a2=Account(2,200.0)
	c1=Customer("John Doe", a1, a2)
	a3=Account(3,300.0)
	a4=Account(4,400.0)
	c2=Customer("Brandon King", a3, a4)
	return [c1,c2]
end
```
sample_customer函数返回两个客户的数组.为了进行测试,让我们构建一个测试工具来更新第一个客户的余额,如下所示:
```julia
function test(copy_function::Function)
	printin("--- testing ",string(copy_function, " ---")
	customers = sample_customers()
	c = copy_function(customers)
	c[1].checkingAccount.balance +=500
	println("orig: ",customers[1].checkingAccount.balance)
	println("new: ",c[1].checkingAccount.balance)
end
```
如果我们使用内置的copy和deepcopy对测试工具进行测试,则会得到以下结果.
```julia
test(copy)
--- testing copy ---
orig:700.0
new:700.0
test(deepcopy)
--- testing deepcopy ---
orig:200.0
new:700.0
```
使用copy函数时,从客户数组中生成了浅拷贝.深拷贝可能更安全.

## 11.3 行为型模式
行为型模式是指对象如何设计为相互协作和通信.OOP范式中有11种GoF模式.

### 11.3.1 责任链模式
责任链(CoR)模式用于使用处理程序链来处理请求,而每个处理程序都有其自己独立的职责.这种模式在许多应用程序中很常见.例如,Web服务器通常使用所谓的中间件来处理HTTP请求.每个中间件都负责执行特定任务,例如验证请求(authenticating request和validating request),维护cookie和执行业务逻辑.

有关CoR模式的特定要求是,链的任何部分都可以在任何时间断开,从而导致该过程提前退出.在前面的Web服务器示例中,身份验证中间件可能已经确定用户尚未经过身份验证,因此,应将用户重定向到单独的网站进行登录.这意味着除非用户通过身份验证步骤,否则将跳过其余中间件.

我们如何在Julia中设计类似的东西?让我们看一个简单的例子:DepositRequest对象包含客户想要在其账户中存入的金额.如果存款金额大于100000美元,表示感谢:
```julia
mutable struct DepositRequest
	id::Int
	amount::Float64
end

@enum Status CONTINUE HANDLED

# update_account_handler函数负责使用新的存款更新账户
function update_account_handler(req::DepositRequest)
	println("Deposited $(req.amount) to account $(req.id)")
	return CONTINUE
end
# send_gift_handler函数负责向客户发送大量存款的感谢信
function send_gift_handler(req::DepositRequest)
	req.amount >100_000 && println("=> Thank you for your business")
	return CONTINUE
end
# notify_customer函数负责在存款后通知客户
function notify_customer(req::DepositRequest)
	println("deposit is finished")
	return HANDLED
end
```
函数还返回一个CONTINUE 继续 或HANDLED 结束运行.因此, 我们可以建立函数数组:
```julia
handlers=[
	update_account_handler,
	send_gift_handler,
	notify_customer]
# 我们还可以有一个函数来按顺序执行这些处理程序:
function apply(req::DepositRequest, handlers::AbstractVector{Function})
	for f in handlers
		status = f(req)
		status == HANDLED && return nothing
	end
end

function test()
	println("Test:customer depositing a lot of money")
	amount=300_000
	apply(DepositRequest(1,amount),handlers)
	println("\nTest:regular customer")
	amount=1000
	apply(DepositRequest(2,amount),handlers)
end

test()
#=======================================
Test:customer depositing a lot of money
Deposited 300000.0 to account 1
=> Thank you for your business
deposit is finished

Test:regular customer
Deposited 1000.0 to account 2
deposit is finished
========================================#
```

### 11.3.2 中介者模式
中介者模式用于促进应用程序中不同组件之间的通信.这样做的方式是使各个组件彼此分离.在大多数应用程序中,一个组件的更改会影响另一个组件.有时,还有级联效应.中介者可以负责在一个组件发生更改时得到通知,并且可以将事件通知给其他组件,以便进行进一步的下游更新.

作为示例,我们可以考虑图形用户界面(GUI)的用例.假设我们有一个屏幕,其中包含我们喜欢的银行业务应用程序的三个字段:
- 金额:账户中的当前余额.
- 利率:当前利率,以百分比表示.
- 利息金额:利息金额.只读
它们如何相互影响?如果金额发生变化,则需要更新利息金额.同样,如果利率发生变化,那么利息金额也需要更新.
为了对GUI进行建模,我们可以为屏幕上的各个GUI对象定义以下类型:
```julia
abstract type Widget end
mutable struct TextField <: Widget
	id::Symbol
	value::String
end
```
Widget是抽象类型,可以用作所有GUI对象的超类型.

$Getter; Setter;$
```julia
# extract numeric value from a text field
get_number(t::TextField) = parse(Float64, t.value)
# set text field from a numericvalue
function set_number(t::TextField, x::Real)
	println("* $(t.id) is being updated to $x")
	t.value = string(x)
	return nothing
end
```
应用程序:
```julia
Base.@kwdef struct App
	amount_field::TextField
	interest_rate_field::TextField
	interest_amount_field::TextField
end

```
对于此示例,我们将实现一个notify函数来模拟一个事件,该事件在用户输入一个值后发送到文本字段小部件.实际上,GUI平台通常执行该函数.让我们将其称为on_change_event,如下所示:
```julia
function on_change_event(widget::Widget)
	notify(app, widget)
end
```
on_change_event函数不执行任何其他操作,只是向中介者(应用程序)传达通知:
```julia
# Mediator logic-handling changes to the widget in this app
function Base.notify(app::App, widget::Widget)
	if widget in (app.amount_field, app.interest_rate_field)
		new_interest = get_number(app.amount_field) *
			get_number(app.interest_rate_field)/100
		set_number(app.interest_amount_field, new_interest)
	end
end
```
如你所见,它只是检查要更新的小部件是"金额"还是"利率"字段, 快速测试:
```julia
function test()
	# Show current state before testing
	print_current_state()
	#double principal amount from 100 to 200
	set_number(app.amount_field, 200)
	on_change_event(app.amount_field)
	print_current_state()
end
```
test函数显示应用程序的初始状态,更新金额字段,并显示新状态. 测试程序的输出如下所示.
```julia
function print_current_state()
    println("current amount = ", get_number(app.amount_field))
    println("current interest rate = ", get_number(app.interest_rate_field))
    println("current interest amount = ", get_number(app.interest_amount_field))
    println()
end
test()
#=================================
current amount = 100.0
current interest rate = 5.0
current interest amount =5.0
* amount is being updated to 200
* interest_amount is being updated to 10.0
current amount = 200.0
current interest rate = 5.0
current interest amount = 10.0
==================================#
```
使用2个中介者的好处是,每个对象都可以专注于自己的职责,而不必担心下游影响.
一个主要中介者负责组织活动以及处理事件和交流.
接下来,我们将看看备忘录模式.
