# 第11章 传统的面向对象模式

有些人可能会问,我已经学习并适应了面向对象编程(OOP)的范式.如何在Julia中应用相同的概念?

`普遍的答案是,你不会以相同的方式解决问题.`

用Julia编写的解决方案看起来会有所不同,反映出不同的编程范式.尽管如此,  我们将涵盖GoF的$<Design Patterns:Elements of Reusable Object-Oriented Software>$ 中所有23种设计模式.

- 创建型模式
- 行为型模式
- 结构型模式

## 11.2创建型模式
创建型模式是指构造和实例化对象的各种方式.由于OOP将数据和行为组合在一起,并且一个类可以继承祖先类的结构和行为,因此在构建大型系统时,还涉及其他级别的复杂性.
通过设计"不允许字段以抽象类型声明,也不允许从具体类型创建新的子类型",Julia已经避免了许多问题.但是,其中某些模式在某些情况下可能会有所帮助.

创建模式包括工厂方法模式,抽象工厂模式,单例模式,建造者模式和原型模式.

### 11.2.1 工厂方法模式
工厂方法模式的思想是提供一个单一的接口,以创建与接口兼容的不同类型的对象,同时向客户端隐藏实际的实现.这种抽象使客户端与功能提供者的基础实现脱钩.例如,程序可能需要在输出中格式化一些数字.在Julia中,我们可能要使用Printf包来格式化数字,如下所示.
```julia
using Printf
@sprintf("%d", 1234) # "1234"
@sprintf("%.2f",1234.567) # "1234.57"
```
也许我们不想与Printf包结合使用,因为我们将来希望切换并使用其他格式化包.为了使应用程序更加灵活,我们可以设计一个接口,可以根据数字的类型进行格式化.doc字符串中描述了以下接口:
```julia
# format(::Formatter, x::T) where {T <: Number}
# Format a numberxusing the specified formatter.Returns a string.
function format end
```
format函数采用formatter和数值x,然后返回格式化的字符串.Formatter类型定义如下:
```julia
abstract type Formatter end
struct IntegerFormatter <: Formatter end
struct FloatFormatter <: Formatter end
```
然后,工厂方法基本上会创建用于分派目的的单例类型:
```julia
formatter(::Type{T}) where {T <: Integer} = IntegerFormatter()
formatter(::Type{T}) where {T <: AbstractFloat} = FloatFormatter()
formatter(::Type{T}) where T =error("No formatter defined for type $T")
```
利用Printf包,默认实现如下所示:
```julia
using Printf
format(nf::IntegerFormatter, x) = @sprintf("%d",x)
format(nf::FloatFormatter, x) = @sprintf("%.2f",x)
# 将所有内容放入FactoryExample模块中,我们可以运行以下测试代码:
function test()
	intf=formatter(Int)
	println(format(intf,1234))
	ff=formatter(Float64)
	println(format(ff,1234))
end

[Int, Float64] .|> formatter .|> y -> format(y,1234)
[Int, Float64] .|> x -> formatter(x) |> y->format(y,1234) # -> 优先级高于 |>
# 等效于 
[Int, Float64] .|> x -> (#==# formatter(x) |> y->format(y,1234)#==#)

@curried fmt(T; value) = format(formatter(T), value)
@curried fmt2(value, T) = format(formatter(T), value)
[Int, Float64] .|> fmt(value=1234)
[Int, Float64] .|> fmt2(1234)
```

### 11.2.2 抽象工厂模式
抽象工厂模式用于通过一组工厂方法创建对象,这些方法从具体实现中抽象出来.抽象工厂模式可以看作是一个工厂中的工厂.
我们可以探索一些示例,构建支持Microsoft Windows和macOS的多平台GUI库.当我们要开发跨平台的代码时,我们可以利用这种设计模式.图11-1的UML图描述了这种设计.
```
                  ------------
                  |  Client  |
                  ------------
                        |
                        |  uses
                        V
         ----------------------
         |   Abstract Factory |
         |--------------------|
         |   createButton()   |
         |   createLabel()    |
         ----------------------
                /           \
               /             \
     -------------------      -------------------
     |  MacOSFactory   |      | WindowsFactory  |
     |-----------------|      |-----------------|
     | createButton()  |      | createButton()  |
     | createLabel()   |      | createLabel()   |
     -------------------      -------------------
              |                          |
              |    return                |    return
              V                          V
  --------------   -------------   ------------  --------------
  |  MacOSBtn  |  | MacOSLabel |  | WindowsBtn| | WindowsLabel|
  --------------   -------------   ------------  --------------
       (Button)      (Label)          (Button)       (Label)
```
这里介绍两种GUI对象:Button和Label.它们在Microsoft Windows和macOS平台的概念相同.客户端不在乎如何实例化这些对象.相反,它要求抽象工厂GUIFactory返回工厂(MacOSFactory或WindowsFactory),该工厂支持多个工厂方法来创建依赖于平台的GUI对象的工厂.
Julia的实现可以简单地用适当的抽象和具体类型建模.让我们从操作系统级别开始:
```julia
abstract type OS end
struct MacOS <: OS end
struct Windows<: OS end
```
我们打算在之后将MacOS和Windows用作单例类型以进行分派.现在,让我们继续并按如下所示定义抽象类型Button和Label.此外,我们分别为每种类型定义了show方法:
```julia
abstract type Button end
Base.show(io::IO,x::Button) = print(io,"'$(x.text)' button")
abstract type Label end
Base.show(io::IO,x::Label)  = print(io,"'$(x.text)' label")

#Buttons
struct MacOSButton <:Button
	text::String
end
struct WindowsButton <:Button
	text::String
end
#Labels
struct MacOSLabel <:Label
	text::String
end
struct WindowsLabel <:Label
	text::String
end
```
由于工厂方法依赖于平台, 利用OS特性和多个分派来调用正确的make_button或make_label函数:
```julia
# Generic implementation using traits
current_os() = MacOS() # should get from system
make_button(text::String) = make_button(current_os(),text)
make_label(text::String) = make_label(current_os(),text)
```
为了进行测试,我们对current_os函数进行硬编码, 最后,我们需要为每个平台实现以下特定函数:
```julia
# Macos implementation
make_button(T::MacOS, text::String)= begin println(T);MacOSButton(text) end
make_label(::MacOS,  text::String)=MacOSLabel(text)
# Windows implementation
make_button(T::Windows,text::String)=begin println(T);WindowsButton(text) end
make_label(::Windows, text::String)=WindowsLabel(text)
```
我们的简单测试仅涉及调用make_button函数.
```julia
button = make_button("Click")
```

### 11.2.3 单例模式
单例模式用于创建对象的单个实例.通常在应用程序启动时或在首次访问时**延迟创建**它.对于多线程应用程序,如何考虑不当, 可能会违背**单例对象的实例化必须仅发生一次**规则.
假设我们要创建一个称为AppKey的单例,该单例用于在应用程序中进行加密:
```julia
# AppKey contains an app id and encryption key
struct AppKey
	appid::String
	value::UInt128
end
```
最初,我们可能会想使用全局变量.既然我们已经了解了全局变量对性能的影响,就可以应用在第6章中学习的全局常量模式.本质上, 将Ref对象创建为占位符,如下所示:
```julia
# placeholder for AppKey object.
const appkey = Ref{AppKey}() # Base.RefValue{AppKey}(#undef)
```
首先创建appkey全局常量而不为其分配任何值,但是可以在实例化单例时对其进行更
新.单例的构造可以如下进行:
```julia
function construct()
	global appkey
	if !isassigned(appkey)
		ak = AppKey("myapp", rand(UInt128))
		println("constructing $ak")
		appkey[]=ak
	end
	return nothing
end
```
只要有一个线程,此代码就可以正常工作.如果我们使用多个线程对其进行测试,则$isassigned$检查是有问题的.例如,两个线程可能会检查是否同时分配了键,并且两个线程都可能认为单例对象需要实例化.在这种情况下,我们最终构造了两次单例. 测试代码如下所示:
```julia
# $ JULIA_NUM_THREADS=4 julia # --project=.
# julia -t 4
struct AppKey
	appid::String
	value::UInt128
end
const appkey = Ref{AppKey}() # Base.RefValue{AppKey}(#undef)
function construct()
	global appkey
	if !isassigned(appkey)
		ak = AppKey("myapp", rand(UInt128))
		println("constructing $ak")
		appkey[]=ak
	end
	return nothing
end
function test_multithreading()
	println("Number of threads: ", Threads.nthreads())
	global appkey
	Threads.@threads for i in 1:8
		construct()
	end
end
```
我们可以如下演示问题,让我们用四个线程启动Julia REPL.
```julia
Number of threads: 4 # 有几个线程, 创建几个实例
constructing AppKey("myapp", 0xf6e0d97ec75b380053b23699241df05f)
constructing AppKey("myapp", 0x747405110d80b905dbbeb97e6b59aabc)
constructing AppKey("myapp", 0x5889c70ee693ffd806e4b0d73e1bd27a)
constructing AppKey("myapp", 0xd7137ea0f181fd6a15e9ed0b9a361bfc)
```

要使用锁,我们可以如下修改construct函数.
```julia
# 注意, appkey_lock 和 appkey不同, 它是创建时候就分配了单例. 而后者是延迟创建.
const appkey_lock=Ref(ReentrantLock()) # 直接使用defined lock contructed

# change construct() to acquire lock before construction, and release it finally
function construct()
	global appkey
	global appkey_lock
	lock(appkey_lock[]) # Acquire lock
	try
		if !isassigned(appkey)
			ak = AppKey("myapp",rand(UInt128))
			println("constructing $ak")
			appkey[] = ak
		else
			println("skipped construction")
		end
	finally
		unlock(appkey_lock[]) # Release lock
		return appkey[]
	end
end
```
在检查是否已分配`appkey[]`之前,我们必须首先获取锁.当我们完成构造单例时
```julia
test_multithreading()
Number of threads: 4
constructing AppKey("myapp", 0x400e3916c8d1624001d01334a7f40e3f)
skipped construction
skipped construction
skipped construction
skipped construction
skipped construction
skipped construction
skipped construction
```

### 11.2.4 建造者模式
建造者模式用于通过**逐步构建**简单的组件来构建复杂对象.我们可以想象工厂组装线以类似的方式工作.在这种情况下,产品会越来越多地逐步组装在一起,并且在组装线的末端,产品就会完成并准备就绪.
这种模式的一个好处是,建造者代码看起来像线性数据流,并且对于某些人来说更易
于阅读.在Julia中,我们可能想编写如下代码:
```julia
car = Car() |>
	add(Engine("4-cylinder 1600cc Engine")) |>
	add(Wheels("4x20-inch wide wheels")) |>
	add(Chassis("Roadster Chassis"))
```
本质上,这正是第9章中描述的函数管道模式.对于此示例,我们可以开发用于构建每个零件(例如轮子,引擎和底盘)的高阶函数.以下代码说明了如何构建用于创建轮子的柯里化(高阶)函数:
```julia
function add(wheels::Wheels)
	return function (c::Car)
		c.wheels=wheels
		return c
	end
end
```
add函数仅返回一个匿名函数,该匿名函数将Car对象作为输入并返回增强的Car对象.同样,我们可以为Engine和Chassis类型开发类似的函数.一旦这些函数准备就绪,我们就可以通过简单地将这些函数调用链接在一起来制造汽车.接下来,我们将讨论原型模式.

### 11.2.5原型模式
原型模式用于通过克隆现有对象或原型对象中的字段来创建新对象.当因为**构造有些对象很难或很费时**,所以制作该对象的副本并通过进行**少量修改**将其称为新对象时,原型模式很有用.

由于Julia将数据和逻辑分开,因此对象的副本与复制内容实际上是一样的.这听起来很容易,但是我们不应忽视浅拷贝和深拷贝之间的区别.一个对象的浅拷贝只是一个所有字段都从另一个对象复制而来的对象.通过递归地进入对象的字段并复制其底层字段来创建对象的深拷贝.这样,由于某些数据可以与原始对象共享,因此可能不希望使用浅拷贝.
为了说明这一点,让我们考虑一个银行账户示例的以下结构定义:
```julia
mutable struct Account
	id::Int
	balance::Float64
end
struct Customer
	name::String
	savingsAccount::Account
	checkingAccount::Account
end
```
现在,假设我们有一个从以下函数返回的Customer对象数组:
```julia
function sample_customers()
	a1=Account(1,100.0)
	a2=Account(2,200.0)
	c1=Customer("John Doe", a1, a2)
	a3=Account(3,300.0)
	a4=Account(4,400.0)
	c2=Customer("Brandon King", a3, a4)
	return [c1,c2]
end
```
sample_customer函数返回两个客户的数组.为了进行测试,让我们构建一个测试工具来更新第一个客户的余额,如下所示:
```julia
function test(copy_function::Function)
	println("--- testing ",string(copy_function, " ---")
	customers = sample_customers()
	c = copy_function(customers)
	c[1].checkingAccount.balance +=500
	println("orig: ",customers[1].checkingAccount.balance)
	println("new: ",c[1].checkingAccount.balance)
end
```
如果我们使用内置的copy和deepcopy对测试工具进行测试,则会得到以下结果.
```julia
test(copy)
--- testing copy ---
orig:700.0
new:700.0
test(deepcopy)
--- testing deepcopy ---
orig:200.0
new:700.0
```
使用copy函数时,从客户数组中生成了浅拷贝.深拷贝可能更安全.

## 11.3 行为型模式
行为型模式是指对象如何设计为相互协作和通信.OOP范式中有11种GoF模式.

### 11.3.1 责任链模式
责任链(CoR)模式用于使用处理程序链来处理请求,而每个处理程序都有其自己独立的职责.这种模式在许多应用程序中很常见.例如,Web服务器通常使用所谓的中间件来处理HTTP请求.每个中间件都负责执行特定任务,例如验证请求(authenticating request和validating request),维护cookie和执行业务逻辑.

有关CoR模式的特定要求是,链的任何部分都可以在任何时间断开,从而导致该过程提前退出.在前面的Web服务器示例中,身份验证中间件可能已经确定用户尚未经过身份验证,因此,应将用户重定向到单独的网站进行登录.这意味着除非用户通过身份验证步骤,否则将跳过其余中间件.

我们如何在Julia中设计类似的东西?让我们看一个简单的例子:DepositRequest对象包含客户想要在其账户中存入的金额.如果存款金额大于100000美元,表示感谢:
```julia
mutable struct DepositRequest
	id::Int
	amount::Float64
end

@enum Status CONTINUE HANDLED

# update_account_handler函数负责使用新的存款更新账户
function update_account_handler(req::DepositRequest)
	println("Deposited $(req.amount) to account $(req.id)")
	return CONTINUE
end
# send_gift_handler函数负责向客户发送大量存款的感谢信
function send_gift_handler(req::DepositRequest)
	req.amount >100_000 && println("=> Thank you for your business")
	return CONTINUE
end
# notify_customer函数负责在存款后通知客户
function notify_customer(req::DepositRequest)
	println("deposit is finished")
	return HANDLED
end
```
函数还返回一个CONTINUE 继续 或HANDLED 结束运行.因此, 我们可以建立函数数组:
```julia
handlers=[
	update_account_handler,
	send_gift_handler,
	notify_customer]
# 我们还可以有一个函数来按顺序执行这些处理程序:
function apply(req::DepositRequest, handlers::AbstractVector{Function})
	for f in handlers
		status = f(req)
		status == HANDLED && return nothing
	end
end

function test()
	println("Test:customer depositing a lot of money")
	amount=300_000
	apply(DepositRequest(1,amount),handlers)
	println("\nTest:regular customer")
	amount=1000
	apply(DepositRequest(2,amount),handlers)
end

test()
#=======================================
Test:customer depositing a lot of money
Deposited 300000.0 to account 1
=> Thank you for your business
deposit is finished

Test:regular customer
Deposited 1000.0 to account 2
deposit is finished
========================================#
```

### 11.3.2 中介者模式
中介者模式用于促进应用程序中不同组件之间的通信.这样做的方式是使各个组件彼此分离.在大多数应用程序中,一个组件的更改会影响另一个组件.有时,还有级联效应.中介者可以负责在一个组件发生更改时得到通知,并且可以将事件通知给其他组件,以便进行进一步的下游更新.

作为示例,我们可以考虑图形用户界面(GUI)的用例.假设我们有一个屏幕,其中包含我们喜欢的银行业务应用程序的三个字段:
- 金额:账户中的当前余额.
- 利率:当前利率,以百分比表示.
- 利息金额:利息金额.只读
它们如何相互影响?如果金额发生变化,则需要更新利息金额.同样,如果利率发生变化,那么利息金额也需要更新.
```julia
module MediatorExample

abstract type Widget end
mutable struct TextField <: Widget
    id::Symbol
    value::Union{String, Nothing}
end

Base.@kwdef struct App
    amount_field::TextField
    interest_rate_field::TextField
    interest_amount_field::TextField
    function App(amount_field::TextField, 
	    interest_rate_field::TextField, 
	    interest_amount_field::TextField
	)
        app = new(amount_field, interest_rate_field, interest_amount_field)
        correct!(app)
        app
    end

end

get_number(t::TextField) = t.value isa String ? tryparse(Float64, t.value) : nothing

function set_number(t::TextField, x::Real)
    println("* ", t.id, " is being updated to ", x)
    t.value = string(x)
    return nothing
end

correct!(app::App) = begin
    amount = get_number(app.amount_field)
    rate = get_number(app.interest_rate_field)
    if !isnothing(amount) && !isnothing(rate)
        interest = amount * rate / 100.0
        set_number(app.interest_amount_field, interest)
    else
        app.interest_amount_field.value = nothing
    end
end

const app = App(
    interest_rate_field = TextField(:interest_rate, nothing),
    amount_field = TextField(:amount, "1001.00"),
    interest_amount_field = TextField(:interest_amount, nothing))

function on_change_event(widget::Widget)
    notify(app, widget)
end
# Notify the mediator `app` about a change in the `widget`.
function notify(app::App, widget::Widget)
    if widget in (app.amount_field, app.interest_rate_field)
        correct!(app)
    end
end
# For testing purpose
function print_current_state()
    println("current amount = ", get_number(app.amount_field))
    println("current interest rate = ", get_number(app.interest_rate_field))
    v = get_number(app.interest_amount_field)
    println("current interest amount = ", v isa Nothing ? nothing : v)
    println()
end

function test()
    # Show current state before testing
    print_current_state()
    # double interest rate
    set_number(app.interest_rate_field, 30)
    on_change_event(app.interest_rate_field)
    print_current_state()

    # double principal amount from 100 to 200
    set_number(app.amount_field, 200)
    on_change_event(app.amount_field)
    print_current_state()
end

end # module

using .MediatorExample
MediatorExample.test()
```
使用2个中介者的好处是,每个对象都可以专注于自己的职责,而不必担心下游影响. 
### 11.3.3备忘录模式

备忘录模式是一种状态管理技术,可用于在需要时将工作还原到以前的状态.一个常见的示例是文字处理器应用程序的撤销功能或记住最近打开的文件:
```julia
using Dates
struct Post
	title::String
	content::String
end
struct Blog
	author::String
	posts::Vector{Post}
	date_created::DateTime
end
```
如上所示,Blog对象包含Post对象的数组.按照惯例,数组中的最后-个元素是博客帖子的当前版本.如果数组中有五个帖子,则表示到目前为止已进行了四个更改.创建新博客很容易,如以下代码所示:
```julia
function Blog(author::String, post::Post)
	return Blog(author, [post],now())
end
```
默认情况下,新博客对象仅包含一个版本.随着用户进行更改,新版本推入数组中.
```julia
version_count(blog::Blog)=length(blog.posts)
#要获取当前帖子,我们可以简单地获取数组的最后一个元素:
current_post(blog::Blog)=blog.posts[end]
```
以下是我们用来使用新标题或内容更新博客的函数:
```julia
# update!函数接受Blog对象,并且可以选择接受更新的title和/或content.它将创建一个新的Post对象,并将其推入posts数组.
function update!(blog::Blog;
	title=nothing,
	content=nothing
)
	post = current_post(blog)
	new_post = Post(
		something(title, post.title),
		something(content, post.content)
	)
	push!(blog.posts, new_post) # 入栈
	return new_post
end
# 撤销操作如下所示:
function undo!(blog::Blog)
	if version_count(blog) > 1
		pop!(blog.posts)
		return current_post(blog)
	else
		error("Cannot undo...no more previous history.")
	end
end
# 我们可以使用以下test函数对其进行测试:
function test()
	blog = Blog("Tom",Post("Why is Julia so great?", "Blah blah...(nothing yet)"))
	println("creating a blog ", blog)
	update!(blog, content="The reasons are.")
	println("Number of versions: ",version_count(blog))

	println("Current post")
	println(current_post(blog))

	println("Undo#1")
	undo!(blog)
	println(current_post(blog))
	println("Undo #2") #expect failure
	undo!(blog)
	println(current_post(blog))
end
```

### 11.3.4 观察者模式
观察者模式对于将观察者注册到对象非常有用,这样该对象中的所有状态更改都会触发向观察者的通知发送.在支持第一类实体函数的语言(例如Julia)中,可以通过维护在对象状态改变之前或之后调用的函数列表来轻松实现此类功能.这些函数可称为钩子.

Julia中观察者模式的实现可以包括两个部分:
1.  扩展`setproperty!`函数用于监控状态变化并通知观察者.
2. 维护一个词典,该词典可用于查找要调用的函数.
对于以下演示,我们将再次显示银行账户示例:
```julia
mutable struct Account
	id::Int
	customer::String
	balance::Float64
end
```
以下是用于维护观察者的数据结构:
```julia
const OBSERVERS = IdDict{Account, Vector{Function}}();
```
IdDict是一种特殊类型,它使用Julia的内部对象ID作为字典键.为了注册观察者,我们提供以下函数:
```julia
function register(a::Account, f::Function)
	fs = get!(OBSERVERS, a, Function[])
	println("Account $(a.id): registered observer function $(Symbol(f))")
	push!(fs, f)
end
```
现在,让我们扩展setproperty!函数:
```julia
function Base.setproperty!(a::Account, field::Symbol, value)
	previous_value = getfield(a, field)
	fs = get!(OBSERVERS, a, Function[])
	setfield!(a, field, value)
	foreach(f->
		f(a, field, previous_value, value),
		fs)
end
```
这个新的setproperty!会在字段更新后**调用**观察者函数.为了进行测试,创建一个观察者函数:
```julia
function test_observer_func(a::Account,field::Symbol, prev_value, cur_value)
	println("Account $(a.id): $field was changed from $prev_value to $cur_value")
end
function test_observer_func2(a::Account,field::Symbol, prev_value, cur_value)
	println("$field was changed 从 $prev_value 到 $cur_value")
end
```
我们的测试函数编写如下:
```julia
function test()
	a1=Account(1,"John Doe", 100.00)
	register(a1, test_observer_func)
	a1.balance += 10.00
	a1.customer = "John Doe Jr."
	return nothing
end
test()
```
运行测试程序时,我们可以看到每次更新属性时都会调用`test_observer_func`

### 11.3.5 状态模式
状态模式用于对象的行为取决于其内部状态的情况.
网络服务就是一个很好的例子.基于网络的服务的典型实现是**监听**特定的端口号.当网络服务当前处于监听状态时,它应允许打开新连接;当远程进程连接到服务时,它将建立一个连接,并且这些进程使用该连接彼此通信直到会话结束.但是,在打开连接之前,不允许数据传输; 相反,连接关闭不应允许连接或数据发送.
在Julia中,我们可以使用多个分派来实现状态模式.首先,定义对网络连接有意义的以下类型:
```julia
abstract type AbstractState end
struct ListeningState <: AbstractState end
struct EstablishedState <: AbstractState end
struct ClosedState <: AbstractState end

const LISTENING = ListeningState()
const ESTABLISHED = EstablishedState()
const CLOSED = ClosedState()
```

在这里,我们利用了单例类型模式.至于网络连接本身,我们可以如下定义类型:
```julia
struct Connection{T <: AbstractState, S}
	state::T
	conn::S
end
```

现在,让我们开发一个send函数,该函数用于通过连接发送消息.在我们的实现中,send函数除了收集连接的当前状态, 并将调用转发到特定于状态的send函数外,不执行其他任何操作:
```julia
send(c::Connection, msg) = _send(c.state, c.conn, msg)
# Use multiple dispatch
# Implementsendmethod for each state
_send(::ListeningState, conn, msg) = error("No connection yet")
_send(::EstablishedState, conn, msg) = write(conn, msg * "\n")
_send(::ClosedState, conn, msg) = error("Connection already closed")
```
你可能会将此视为Holy Traits模式.对于单元测试,我们可以开发一个test函数,以使用指定的消息创建一个新的Connection并将消息发送到Connection对象:
```julia
function test(state, msg)
	c = Connection(state, stdout)
	try
		send(c, msg)
	catch ex
		println("$(ex) for message $msg")
	end
end
```
然后,测试代码简单地运行test函数三次,每种可能的状态测试一次:
```julia
function test()
	test(LISTENING, "hello world 1")
	test(CLOSED, "hello world 2")
	test(ESTABLISHED, "hello world 3")
end
```
运行测试函数时,我们得到以下输出.
```julia
StateExample.test()
ErrorException("No connection yet") for message 'hello world 1'
ErrorException("Connection closed") for message 'hello world 2'
hello world 3

```

因为连接处于ESTABLISHED状态,所以仅成功发送了第三条消息.

💕注意💕
```julia
write(stdout, "sdf") # sdf
```

### 11.3.6 策略模式
策略模式使客户端可以选择最佳算法以在运行时使用.除了将客户端与预定义的算法结合之外,可以在必要时为客户端配置特定的算法(策略).

此外,有时无法提前确定算法的选择,因为该决定可能取决于输入数据,环境或其他因素.在Julia中,我们可以使用多重分派解决问题.

让我们考虑斐波那契数列生成器的情况.正如我们从第6章中学到的那样,第n个斐波那契数的计算在递归实现时可能很棘手,因此我们的第一个算法(策略)可能是记忆.另外,我们也可以使用迭代算法来解决相同的问题,而无须使用任何递归. 为了支持**记忆**和**迭代**算法,让我们创建一些新类型,如下所示:
```julia
abstract type Algo end
struct Memoized <: Algo end
struct Iterative <: Algo end
```

Algo抽象类型是所有斐波那契算法的超类型.目前,我们只有两种算法可供选择`Memoized`或`Iterative`.现在,我们可以如下定义`fib`函数的记忆版本:
```julia
using Memoize
@memoize function _fib(n)
	n <= 2 ? 1 : _fib(n - 1) + _fib(n - 2)
end

function fib(::Memoized, n)
	println("Using memoization algorithm")
	_fib(n)
end
```
相应的迭代算法可以如下实现:
```julia
function fib(algo::Iterative, n)
	n <= 2 && return 1
	prev1, prev2 = 1,1
	local curr
	for i in 3:n
		curr = prev1 + prev2
		prev1, prev2 = curr, prev1
	end
	return curr
end
```
由于第一个参数是Iterative对象,因此我们知道将相应地分派此函数.从客户端的角度来看,它可以根据需要选择记忆版本或迭代版本.由于记忆版本以O(1)速度运行,因此当n越大时速度应该更快.但是,对于较小的n值,迭代版本会更好.我们可以通过以下方式之一调用fib函数:
```julia
fib(Memoized(), 10)
fib(Iterative(),10)

```
如果客户端选择实现算法选择过程,则可以轻松完成,如下所示:
```julia
function fib(n)
	algo = n>50 ? Memoized(): Iterative()
	return fib(algo, n)
end
```

实现策略模式非常容易.多重分派的效果再次拯救了我们!接下来,我们将介绍另一种称为模板方法
### 11.3.7 模板方法模式

模板方法模式用于创建可以使用**不同种类**的**算法**或**操作**的**明确定义的过程**.作为模板,可以使用客户端所需的任何算法或函数对其进行自定义.在这里,我们将探讨如何在机器学习(ML)管道用例中利用模板方法模式.对于不熟悉ML管道的用户,提供简单版本.
```
+--------+     +--------+    +-----+    +--------+    +-------+
|  数据  | --> |  划分   | -> | 训练 | -> |Fit data| -> | 模型  |
+--------+     +--------+ |  +-----+    +--------+    +---o---+
						  |                               ↓
						  |  +-----+                  +-------+    +----------+
						  -> | 测试 | -------------->  | 验证  | -->| 准确率结果 |
							 +-----+                  +-------+    +----------+
```
$$图11-2$$
首先将数据集**划分**为两个单独的数据集以进行**训练和测试**. **训练数据集**被输入到将数据**拟合为统计模型**的过程中.然后,validate函数使用该模型**预测**测试集中的响应(也称为目标)变量.最后它将预测值与实际值进行比较,并确定模型的准确率.
假设我们已经按照以下步骤建立了管道:
```julia
using DataFrames, LinearAlgebra
# Run machine learning pipeline
function ml_run(data::DataFrame, response::Symbol, predictors::Vector{Symbol})
	train, test = split_data(data, 0.7)
	model = fit(train, response, predictors)
	validate(test, model, response)
end
```
为简洁起见,此处提供`split_data,fit`和`validate`简单实现
```julia
using DataFrames, GLM
# Split randomly to dfs for (train, test) `keep` as per% of records kept to test.
split_data(df::DataFrame, keep::Float64) = 
	let b = rand(size(df,1)) .< keep
	    (df[b, :], df[.!b, :])
	end

# Return a model for predicting the `response` var from the `predictors` vars.
function fit(df::DataFrame, response::Symbol, predictors::Vector{Symbol})
    formula = Term(response) ~ +(Term.(predictors)...)
    return GLM.lm(formula, df)
end

# Predict response variable using the model and validate accuracy of model.
function validate(df, model, response)
    yhat = GLM.predict(model, df)
    y = df[:, response]
    return (result = [y yhat], rmse = rmse_fn(yhat .- y))
end

"Root mean square error."
rmse_fn(ys) = GLM.norm(ys) / sqrt(length(ys))
```
管道概念在前面的逻辑中得到了证明. 让我们快速预测一下波士顿的房价.
```julia
using RDatasets
# Using original template
boston = RDatasets.dataset("MASS", "Boston");
result, rmse = ml_run(boston, :MedV, [:Rm, :Tax, :Crim]);
println(rmse)
```
在此示例中,响应变量为:MedV,我们将基于:Rm,:Tax和:Crim建立一个统计模型波士顿住房数据集包含美国人口普查局收集的有关马萨诸塞州波士顿地区住房的数据.许多统计分析教育文献都广泛使用它.我们在此示例 使用的变量是:
- MedV: 自有住房的中位数价值为1000美元
- Rm: 每个住宅的平均房间数
- Tax: 每10000美元的全额房产税率
- Crim: 按城镇划分的人均犯罪率
模型的准确率记录在`rmse`变量中(意味着均方根误差).默认实现使用**线性回归**作为拟合函数.

为了实现模板方法模式,我们允许插入过程的**任何部分**.因此,我们可以使用**关键字参数**修改函数:
```julia
# Run machine learning pipeline (template version w/ keyword args)
function ml_run2(data::DataFrame, response::Symbol, predictors::Vector{Symbol};
            fit = fit, split_data = split_data, validate = validate)
    train, test = split_data(data, 0.7)
    model = fit(train, response, predictors)
    validate(test, model, response)
end
```
在这里,我们添加了三个关键字参数:`fit,split_data和validate`. 为了说明其工作方式,让我们创建一个使用广义线性模型(GLM)的新拟合函数:
```julia
using GLM
# Custom fitting function
function fit_glm(df::DataFrame, response::Symbol, predictors::Vector{Symbol})
    formula = Term(response) ~ +(Term.(predictors)...)
    return glm(formula, df, Normal(), IdentityLink())
end
```

现在我们已经自定义了拟合函数，我们可以通过`fit`关键字参数传递程序来重新运行该程序。

```julia
result, rmse = MLPipeline.run2(boston, :MedV, [:Rm, :Tax, :Crim], fit = fit_glm);
println(rmse)
```
客户端只需传递函数即可轻松自定义管道，这是可行的，因为Julia支持第一类实体函数。