# 第11章 传统的面向对象模式

有些人可能会问,我已经学习并适应了面向对象编程(OOP)的范式.如何在Julia中应用相同的概念?

`普遍的答案是,你不会以相同的方式解决问题.`

用Julia编写的解决方案看起来会有所不同,反映出不同的编程范式.尽管如此,  我们将涵盖GoF的$<Design Patterns:Elements of Reusable Object-Oriented Software>$ 中所有23种设计模式.

- 创建型模式
- 行为型模式
- 结构型模式

## 11.2创建型模式
创建型模式是指构造和实例化对象的各种方式.由于OOP将数据和行为组合在一起,并且一个类可以继承祖先类的结构和行为,因此在构建大型系统时,还涉及其他级别的复杂性.
通过设计"不允许字段以抽象类型声明,也不允许从具体类型创建新的子类型",Julia已经避免了许多问题.但是,其中某些模式在某些情况下可能会有所帮助.

创建模式包括工厂方法模式,抽象工厂模式,单例模式,建造者模式和原型模式.

### 11.2.1 工厂方法模式
工厂方法模式的思想是提供一个单一的接口,以创建与接口兼容的不同类型的对象,同时向客户端隐藏实际的实现.这种抽象使客户端与功能提供者的基础实现脱钩.例如,程序可能需要在输出中格式化一些数字.在Julia中,我们可能要使用Printf包来格式化数字,如下所示.
```julia
using Printf
@sprintf("%d", 1234) # "1234"
@sprintf("%.2f",1234.567) # "1234.57"
```
也许我们不想与Printf包结合使用,因为我们将来希望切换并使用其他格式化包.为了使应用程序更加灵活,我们可以设计一个接口,可以根据数字的类型进行格式化.doc字符串中描述了以下接口:
```julia
# format(::Formatter, x::T) where {T <: Number}
# Format a numberxusing the specified formatter.Returns a string.
function format end
```
format函数采用formatter和数值x,然后返回格式化的字符串.Formatter类型定义如下:
```julia
abstract type Formatter end
struct IntegerFormatter <: Formatter end
struct FloatFormatter <: Formatter end
```
然后,工厂方法基本上会创建用于分派目的的单例类型:
```julia
formatter(::Type{T}) where {T <: Integer} = IntegerFormatter()
formatter(::Type{T}) where {T <: AbstractFloat} = FloatFormatter()
formatter(::Type{T}) where T =error("No formatter defined for type $T")
```
利用Printf包,默认实现如下所示:
```julia
using Printf
format(nf::IntegerFormatter, x) = @sprintf("%d",x)
format(nf::FloatFormatter, x) = @sprintf("%.2f",x)
# 将所有内容放入FactoryExample模块中,我们可以运行以下测试代码:
function test()
	intf=formatter(Int)
	println(format(intf,1234))
	ff=formatter(Float64)
	println(format(ff,1234))
end

partial(f, args...) = x -> f(args..., x)
rpartial(f, args...) = (x...) -> f(x..., args...)
#测试
['A':'Z';] .|> string .|> partial(println, "hello ");

[Int, Float64] .|> formatter .|> rpartial(format, 1234)
[Int, Float64] .|> x -> (formatter(x) |> y->format(y,1234) ) # -> 优先级高于 |>

@curried fmt(T; value) = format(formatter(T), value)
@curried fmt2(value, T) = format(formatter(T), value)
[Int, Float64] .|> fmt(value=1234)
[Int, Float64] .|> fmt2(1234)
```

### 11.2.2 抽象工厂模式
抽象工厂模式用于通过一组工厂方法创建对象,这些方法从具体实现中抽象出来.抽象工厂模式可以看作是一个工厂中的工厂.
我们可以探索一些示例,构建支持Microsoft Windows和macOS的多平台GUI库.当我们要开发跨平台的代码时,我们可以利用这种设计模式.图11-1的UML图描述了这种设计.
```
                  ------------
                  |  Client  |
                  ------------
                        |
                        |  uses
                        V
         ----------------------
         |   Abstract Factory |
         |--------------------|
         |   createButton()   |
         |   createLabel()    |
         ----------------------
                /           \
               /             \
     -------------------      -------------------
     |  MacOSFactory   |      | WindowsFactory  |
     |-----------------|      |-----------------|
     | createButton()  |      | createButton()  |
     | createLabel()   |      | createLabel()   |
     -------------------      -------------------
              |                          |
              |    return                |    return
              V                          V
  --------------   -------------   ------------  --------------
  |  MacOSBtn  |  | MacOSLabel |  | WindowsBtn| | WindowsLabel|
  --------------   -------------   ------------  --------------
       (Button)      (Label)          (Button)       (Label)
```
这里介绍两种GUI对象:Button和Label.它们在Microsoft Windows和macOS平台的概念相同.客户端不在乎如何实例化这些对象.相反,它要求抽象工厂GUIFactory返回工厂(MacOSFactory或WindowsFactory),该工厂支持多个工厂方法来创建依赖于平台的GUI对象的工厂.
Julia的实现可以简单地用适当的抽象和具体类型建模.让我们从操作系统级别开始:
```julia
abstract type OS end
struct MacOS <: OS end
struct Windows<: OS end
```
我们打算在之后将MacOS和Windows用作单例类型以进行分派.现在,让我们继续并按如下所示定义抽象类型Button和Label.此外,我们分别为每种类型定义了show方法:
```julia
abstract type Button end
Base.show(io::IO, x::Button) = print(io,"'$(x.text)' button")
abstract type Label end
Base.show(io::IO, x::Label)  = print(io,"'$(x.text)' label")

#Buttons
struct MacOSButton <:Button
	text::String
end
struct WindowsButton <:Button
	text::String
end
#Labels
struct MacOSLabel <:Label
	text::String
end
struct WindowsLabel <:Label
	text::String
end
```
由于工厂方法依赖于平台, 利用OS特性和多个分派来调用正确的make_button或make_label函数:
```julia
# Generic implementation using traits
current_os() = MacOS() # should get from system
make_button(text::String) = make_button(current_os(),text)
make_label(text::String) = make_label(current_os(),text)
```
为了进行测试,我们对current_os函数进行硬编码, 最后,我们需要为每个**平台实现以下特定函数**:
```julia
# Macos implementation
make_button(T::MacOS, text::String) = begin println(T);MacOSButton(text) end
make_label(::MacOS, text::String) = MacOSLabel(text)
# Windows implementation
make_button(T::Windows, text::String) = begin println(T);WindowsButton(text) end
make_label(::Windows, text::String)=WindowsLabel(text)
```
我们的简单测试仅涉及调用make_button函数.
```julia
button = make_button("Click")
```

### 11.2.3 单例模式
单例模式用于创建对象的单个实例.通常在应用程序启动时或在首次访问时**延迟创建**它.对于多线程应用程序,如何考虑不当, 可能会违背**单例对象的实例化必须仅发生一次**规则.
假设我们要创建一个称为AppKey的单例,该单例用于在应用程序中进行加密:
```julia
# AppKey contains an app id and encryption key
struct AppKey
	appid::String
	value::UInt128
end
```
最初,我们可能会想使用全局变量.既然我们已经了解了全局变量对性能的影响,就可以应用在第6章中学习的全局常量模式.本质上, 将Ref对象创建为占位符,如下所示:
```julia
# placeholder for AppKey object.
const appkey = Ref{AppKey}() # Base.RefValue{AppKey}(#undef)
```
首先创建appkey全局常量而不为其分配任何值,但是可以在实例化单例时对其进行更
新.单例的构造可以如下进行:
```julia
function construct()
	global appkey
	if !isassigned(appkey)
		ak = AppKey("myapp", rand(UInt128))
		println("constructing $ak")
		appkey[]=ak
	end
	return nothing
end
```
只要有一个线程,此代码就可以正常工作.如果我们使用多个线程对其进行测试,则$isassigned$检查是有问题的.例如,两个线程可能会检查是否同时分配了键,并且两个线程都可能认为单例对象需要实例化.在这种情况下,我们最终构造了两次单例. 测试代码如下所示:
```julia
# $ JULIA_NUM_THREADS=4 julia # --project=.
# julia -t 4
struct AppKey
	appid::String
	value::UInt128
end
const appkey = Ref{AppKey}() # Base.RefValue{AppKey}(#undef)
function construct()
	global appkey
	if !isassigned(appkey)
		ak = AppKey("myapp", rand(UInt128))
		println("constructing $ak")
		appkey[]=ak
	end
	return nothing
end
function test_multithreading()
	println("Number of threads: ", Threads.nthreads())
	global appkey
	Threads.@threads for i in 1:8
		construct()
	end
end
```
我们可以如下演示问题,让我们用四个线程启动Julia REPL.
```julia
Number of threads: 4 # 有几个线程, 创建几个实例
constructing AppKey("myapp", 0xf6e0d97ec75b380053b23699241df05f)
constructing AppKey("myapp", 0x747405110d80b905dbbeb97e6b59aabc)
constructing AppKey("myapp", 0x5889c70ee693ffd806e4b0d73e1bd27a)
constructing AppKey("myapp", 0xd7137ea0f181fd6a15e9ed0b9a361bfc)
```

要使用锁,我们可以如下修改construct函数.
```julia
# 注意, appkey_lock 和 appkey不同, 它是创建时候就分配了单例. 而后者是延迟创建.
const appkey_lock=Ref(ReentrantLock()) # 直接使用defined lock contructed

# change construct() to acquire lock before construction, and release it finally
function construct()
	global appkey
	global appkey_lock
	lock(appkey_lock[]) # Acquire lock
	try
		if !isassigned(appkey)
			ak = AppKey("myapp",rand(UInt128))
			println("constructing $ak")
			appkey[] = ak
		else
			println("skipped construction")
		end
	finally
		unlock(appkey_lock[]) # Release lock
		return appkey[]
	end
end
```
在检查是否已分配`appkey[]`之前,我们必须首先获取锁.当我们完成构造单例时
```julia
test_multithreading()
Number of threads: 4
constructing AppKey("myapp", 0x400e3916c8d1624001d01334a7f40e3f)
skipped construction
skipped construction
skipped construction
skipped construction
skipped construction
skipped construction
skipped construction
```

### 11.2.4 建造者模式
建造者模式用于通过**逐步构建**简单的组件来构建复杂对象.我们可以想象工厂组装线以类似的方式工作.在这种情况下,产品会越来越多地逐步组装在一起,并且在组装线的末端,产品就会完成并准备就绪.
这种模式的一个好处是,建造者代码看起来像线性数据流,并且对于某些人来说更易
于阅读.在Julia中,我们可能想编写如下代码:
```julia
car = Car() |>
	add(Engine("4-cylinder 1600cc Engine")) |>
	add(Wheels("4x20-inch wide wheels")) |>
	add(Chassis("Roadster Chassis"))
```
本质上,这正是第9章中描述的函数管道模式.对于此示例,我们可以开发用于构建每个零件(例如轮子,引擎和底盘)的高阶函数.以下代码说明了如何构建用于创建轮子的柯里化(高阶)函数:
```julia
function add(wheels::Wheels)
	return function (c::Car)
		c.wheels=wheels
		return c
	end
end

function set(symbol::Symbol, val::Any, c::Car)
    setfield!(c, symbol, val)
    return c
end

function test3()
    car = Car() |>
	    partial(set, :engine, Engine("4-缸1800cc引擎"))) |>
	    partial(set, :wheels, Wheels("4x 20-inch wide 固特异轮胎"))) |>
	    partial(set, :chassis, Chassis("Roadster Chassis底盘")))
    println(car)
end
#============= 测试运行见 
D:\julias\Hands-on-Design-Patterns-and-Best-Practices-with-Julia\Chapter11\04_builder.jl
https://github.com/tearf001/Hands-on-Design-Patterns-and-Best-Practices-with-Julia
=============#
```


### 11.2.5原型模式
原型模式用于通过克隆现有对象或原型对象中的字段来创建新对象.当因为**构造有些对象很难或很费时**,所以制作该对象的副本并通过进行**少量修改**将其称为新对象时,原型模式很有用.

由于Julia将数据和逻辑分开,因此对象的副本与复制内容实际上是一样的.这听起来很容易,但是我们不应忽视浅拷贝和深拷贝之间的区别.一个对象的浅拷贝只是一个所有字段都从另一个对象复制而来的对象.通过递归地进入对象的字段并复制其底层字段来创建对象的深拷贝.这样,由于某些数据可以与原始对象共享,因此可能不希望使用浅拷贝.
为了说明这一点,让我们考虑一个银行账户示例的以下结构定义:
```julia
mutable struct Account
	id::Int
	balance::Float64
end
struct Customer
	name::String
	savingsAccount::Account
	checkingAccount::Account
end
```
现在,假设我们有一个从以下函数返回的Customer对象数组:
```julia
function sample_customers()
	a1=Account(1,100.0)
	a2=Account(2,200.0)
	c1=Customer("John Doe", a1, a2)
	a3=Account(3,300.0)
	a4=Account(4,400.0)
	c2=Customer("Brandon King", a3, a4)
	return [c1,c2]
end
```
sample_customer函数返回两个客户的数组.为了进行测试,让我们构建一个测试工具来更新第一个客户的余额,如下所示:
```julia
function test(copy_function::Function)
	println("--- testing ",string(copy_function, " ---")
	customers = sample_customers()
	c = copy_function(customers)
	c[1].checkingAccount.balance +=500
	println("orig: ",customers[1].checkingAccount.balance)
	println("new: ",c[1].checkingAccount.balance)
end
```
如果我们使用内置的copy和deepcopy对测试工具进行测试,则会得到以下结果.
```julia
test(copy)
--- testing copy ---
orig:700.0
new:700.0
test(deepcopy)
--- testing deepcopy ---
orig:200.0
new:700.0
```
使用copy函数时,从客户数组中生成了浅拷贝.深拷贝可能更安全.

## 11.3 行为型模式
行为型模式是指对象如何设计为相互协作和通信.OOP范式中有11种GoF模式.

### 11.3.1 责任链模式
中间件
责任链(CoR)模式用于使用**处理程序链**来处理请求,而每个处理程序都有其自己独立的职责.这种模式在许多应用程序中很常见.例如,Web服务器通常使用所谓的中间件来处理HTTP请求.每个中间件都负责执行特定任务,例如验证请求(authenticating request和validating request),维护cookie和执行业务逻辑.

有关CoR模式的特定要求是,链的任何部分都可以在任何时间断开,从而导致该过程提前退出.在前面的Web服务器示例中,身份验证中间件可能已经确定用户尚未经过身份验证,因此,应将用户重定向到单独的网站进行登录.这意味着除非用户通过身份验证步骤,否则将跳过其余中间件.

我们如何在Julia中设计类似的东西?让我们看一个简单的例子:DepositRequest对象包含客户想要在其账户中存入的金额.如果存款金额大于100000美元,表示感谢:
```julia
mutable struct DepositRequest
	id::Int
	amount::Float64
end

@enum Status CONTINUE HANDLED

# update_account_handler函数负责使用新的存款更新账户
function update_account_handler(req::DepositRequest)
	println("Deposited $(req.amount) to account $(req.id)")
	return CONTINUE
end
# send_gift_handler函数负责向客户发送大量存款的感谢信
function send_gift_handler(req::DepositRequest)
	req.amount >100_000 && println("=> Thank you for your business")
	return CONTINUE
end
# notify_customer函数负责在存款后通知客户
function notify_customer(req::DepositRequest)
	println("deposit is finished")
	return HANDLED
end
```
函数还返回一个CONTINUE 继续 或HANDLED 结束运行.因此, 我们可以建立函数数组:
```julia
# 我们还可以有一个函数来按顺序执行这些处理程序:
function apply(req::DepositRequest, handlers::AbstractVector{Function})
	for f in handlers
		status = f(req)
		status == HANDLED && return nothing
	end
end

handlers=[
	update_account_handler,
	send_gift_handler,
	notify_customer
]
	
function test()
	println("Test:customer depositing a lot of money")	
	apply(DepositRequest(1,300_000),handlers)
	
	println("\nTest:regular customer")
	apply(DepositRequest(2,1000),handlers)
end

test()
#=======================================
Test:customer depositing a lot of money
Deposited 300000.0 to account 1
=> Thank you for your business
deposit is finished

Test:regular customer
Deposited 1000.0 to account 2
deposit is finished
========================================#
```

### 11.3.2 中介者模式
中介者模式用于促进应用程序中不同组件之间的通信.这样做的方式是使各个组件彼此分离.在大多数应用程序中,一个组件的更改会影响另一个组件.有时,还有级联效应.中介者可以负责在一个组件发生更改时得到通知,并且可以将事件通知给其他组件,以便进行进一步的下游更新.

作为示例,我们可以考虑图形用户界面(GUI)的用例.假设我们有一个屏幕,其中包含我们喜欢的银行业务应用程序的三个字段:
- 金额:账户中的当前余额.
- 利率:当前利率,以百分比表示.
- 利息金额:利息金额.只读
它们如何相互影响?如果金额发生变化,则需要更新利息金额.同样,如果利率发生变化,那么利息金额也需要更新.
```julia
module MediatorExample

abstract type Widget end
mutable struct TextField <: Widget
    id::Symbol
    value::Union{String, Nothing}
end

Base.@kwdef struct App
    amount_field::TextField
    interest_rate_field::TextField
    interest_amount_field::TextField
    function App(amount_field::TextField, 
	    interest_rate_field::TextField, 
	    interest_amount_field::TextField
	)
        app = new(amount_field, interest_rate_field, interest_amount_field)
        correct!(app)
        app
    end

end

get_number(t::TextField) = t.value isa String ? tryparse(Float64, t.value) : nothing

function set_number(t::TextField, x::Real)
    println("* ", t.id, " is being updated to ", x)
    t.value = string(x)
    return nothing
end

correct!(app::App) = begin
    amount = get_number(app.amount_field)
    rate = get_number(app.interest_rate_field)
    if !isnothing(amount) && !isnothing(rate)
        interest = amount * rate / 100.0
        set_number(app.interest_amount_field, interest)
    else
        app.interest_amount_field.value = nothing
    end
end

const app = App(
    interest_rate_field = TextField(:interest_rate, nothing),
    amount_field = TextField(:amount, "1001.00"),
    interest_amount_field = TextField(:interest_amount, nothing))

function on_change_event(widget::Widget)
    notify(app, widget)
end
# Notify the mediator `app` about a change in the `widget`.
function notify(app::App, widget::Widget)
    if widget in (app.amount_field, app.interest_rate_field)
        correct!(app)
    end
end
# For testing purpose
function print_current_state()
    println("current amount = ", get_number(app.amount_field))
    println("current interest rate = ", get_number(app.interest_rate_field))
    v = get_number(app.interest_amount_field)
    println("current interest amount = ", v isa Nothing ? nothing : v)
    println()
end

function test()
    # Show current state before testing
    print_current_state()
    # double interest rate
    set_number(app.interest_rate_field, 30)
    on_change_event(app.interest_rate_field)
    print_current_state()

    # double principal amount from 100 to 200
    set_number(app.amount_field, 200)
    on_change_event(app.amount_field)
    print_current_state()
end

end # module

using .MediatorExample
MediatorExample.test()
```
使用2个中介者的好处是,每个对象都可以专注于自己的职责,而不必担心下游影响. 
### 11.3.3备忘录模式

备忘录模式是一种状态管理技术,可用于在需要时将工作还原到以前的状态.一个常见的示例是文字处理器应用程序的撤销功能或记住最近打开的文件:
```julia
using Dates
struct Post
	title::String
	content::String
end
struct Blog
	author::String
	posts::Vector{Post}
	date_created::DateTime
end
```
如上所示,Blog对象包含Post对象的数组.按照惯例,数组中的最后-个元素是博客帖子的当前版本.如果数组中有五个帖子,则表示到目前为止已进行了四个更改.创建新博客很容易,如以下代码所示:
```julia
function Blog(author::String, post::Post)
	return Blog(author, [post],now())
end
```
默认情况下,新博客对象仅包含一个版本.随着用户进行更改,新版本推入数组中.
```julia
version_count(blog::Blog)=length(blog.posts)
#要获取当前帖子,我们可以简单地获取数组的最后一个元素:
current_post(blog::Blog)=blog.posts[end]
```
以下是我们用来使用新标题或内容更新博客的函数:
```julia
# update!函数接受Blog对象,并且可以选择接受更新的title和/或content.它将创建一个新的Post对象,并将其推入posts数组.
function update!(blog::Blog;
	title=nothing,
	content=nothing
)
	post = current_post(blog)
	new_post = Post(
		something(title, post.title),
		something(content, post.content)
	)
	push!(blog.posts, new_post) # 入栈
	return new_post
end
# 撤销操作如下所示:
function undo!(blog::Blog)
	if version_count(blog) > 1
		pop!(blog.posts)
		return current_post(blog)
	else
		error("Cannot undo...no more previous history.")
	end
end
# 我们可以使用以下test函数对其进行测试:
function test()
	blog = Blog("Tom",Post("Why is Julia so great?", "Blah blah...(nothing yet)"))
	println("creating a blog ", blog)
	update!(blog, content="The reasons are.")
	println("Number of versions: ",version_count(blog))

	println("Current post")
	println(current_post(blog))

	println("Undo#1")
	undo!(blog)
	println(current_post(blog))
	println("Undo #2") #expect failure
	undo!(blog)
	println(current_post(blog))
end
```

### 11.3.4 观察者模式
观察者模式对于将观察者注册到对象非常有用,这样该对象中的所有状态更改都会触发向观察者的通知发送.在支持第一类实体函数的语言(例如Julia)中,可以通过维护在对象状态改变之前或之后调用的函数列表来轻松实现此类功能.这些函数可称为钩子.

Julia中观察者模式的实现可以包括两个部分:
1.  扩展`setproperty!`函数用于监控状态变化并通知观察者.
2. 维护一个词典,该词典可用于查找要调用的函数.
对于以下演示,我们将再次显示银行账户示例:
```julia
mutable struct Account
	id::Int
	customer::String
	balance::Float64
end
```
以下是用于维护观察者的数据结构:
```julia
const OBSERVERS = IdDict{Account, Vector{Function}}();
```
IdDict是一种特殊类型,它使用Julia的内部对象ID作为字典键.为了注册观察者,我们提供以下函数:
```julia
function register(a::Account, f::Function)
	fs = get!(OBSERVERS, a, Function[])
	println("Account $(a.id): registered observer function $(Symbol(f))")
	push!(fs, f)
end
```
现在,让我们扩展setproperty!函数:
```julia
function Base.setproperty!(a::Account, field::Symbol, value)
	previous_value = getfield(a, field)
	fs = get!(OBSERVERS, a, Function[])
	setfield!(a, field, value)
	foreach(f->
		f(a, field, previous_value, value),
		fs)
end
```
这个新的setproperty!会在字段更新后**调用**观察者函数.为了进行测试,创建一个观察者函数:
```julia
function test_observer_func(a::Account,field::Symbol, prev_value, cur_value)
	println("Account $(a.id): $field was changed from $prev_value to $cur_value")
end
function test_observer_func2(a::Account,field::Symbol, prev_value, cur_value)
	println("$field was changed 从 $prev_value 到 $cur_value")
end
```
我们的测试函数编写如下:
```julia
function test()
	a1=Account(1,"John Doe", 100.00)
	register(a1, test_observer_func)
	a1.balance += 10.00
	a1.customer = "John Doe Jr."
	return nothing
end
test()
```
运行测试程序时,我们可以看到每次更新属性时都会调用`test_observer_func`

### 11.3.5 状态模式
状态模式用于对象的行为取决于其内部状态的情况.
网络服务就是一个很好的例子.基于网络的服务的典型实现是**监听**特定的端口号.当网络服务当前处于监听状态时,它应允许打开新连接;当远程进程连接到服务时,它将建立一个连接,并且这些进程使用该连接彼此通信直到会话结束.但是,在打开连接之前,不允许数据传输; 相反,连接关闭不应允许连接或数据发送.
在Julia中,我们可以使用多个分派来实现状态模式.首先,定义对网络连接有意义的以下类型:
```julia
abstract type AbstractState end
struct ListeningState <: AbstractState end
struct EstablishedState <: AbstractState end
struct ClosedState <: AbstractState end

const LISTENING = ListeningState()
const ESTABLISHED = EstablishedState()
const CLOSED = ClosedState()
```

在这里,我们利用了单例类型模式.至于网络连接本身,我们可以如下定义类型:
```julia
struct Connection{T <: AbstractState, S}
	state::T
	conn::S
end
```

现在,让我们开发一个send函数,该函数用于通过连接发送消息.在我们的实现中,send函数除了收集连接的当前状态, 并将调用转发到特定于状态的send函数外,不执行其他任何操作:
```julia
send(c::Connection, msg) = _send(c.state, c.conn, msg)
# Use multiple dispatch
# Implementsendmethod for each state
_send(::ListeningState, conn, msg) = error("No connection yet")
_send(::EstablishedState, conn, msg) = write(conn, msg * "\n")
_send(::ClosedState, conn, msg) = error("Connection already closed")
```
你可能会将此视为Holy Traits模式.对于单元测试,我们可以开发一个test函数,以使用指定的消息创建一个新的Connection并将消息发送到Connection对象:
```julia
function test(state, msg)
	c = Connection(state, stdout)
	try
		send(c, msg)
	catch ex
		println("$(ex) for message $msg")
	end
end
```
然后,测试代码简单地运行test函数三次,每种可能的状态测试一次:
```julia
function test()
	test(LISTENING, "hello world 1")
	test(CLOSED, "hello world 2")
	test(ESTABLISHED, "hello world 3")
end
```
运行测试函数时,我们得到以下输出.
```julia
StateExample.test()
ErrorException("No connection yet") for message 'hello world 1'
ErrorException("Connection closed") for message 'hello world 2'
hello world 3

```

因为连接处于ESTABLISHED状态,所以仅成功发送了第三条消息.

💕注意💕
```julia
write(stdout, "sdf") # sdf
```

### 11.3.6 策略模式
策略模式使客户端可以选择最佳算法以在运行时使用.除了将客户端与预定义的算法结合之外,可以在必要时为客户端配置特定的算法(策略).

此外,有时无法提前确定算法的选择,因为该决定可能取决于输入数据,环境或其他因素.在Julia中,我们可以使用多重分派解决问题.

让我们考虑斐波那契数列生成器的情况.正如我们从第6章中学到的那样,第n个斐波那契数的计算在递归实现时可能很棘手,因此我们的第一个算法(策略)可能是记忆.另外,我们也可以使用迭代算法来解决相同的问题,而无须使用任何递归. 为了支持**记忆**和**迭代**算法,让我们创建一些新类型,如下所示:
```julia
abstract type Algo end
struct Memoized <: Algo end
struct Iterative <: Algo end
```

Algo抽象类型是所有斐波那契算法的超类型.目前,我们只有两种算法可供选择`Memoized`或`Iterative`.现在,我们可以如下定义`fib`函数的记忆版本:
```julia
using Memoize
@memoize function _fib(n)
	n <= 2 ? 1 : _fib(n - 1) + _fib(n - 2)
end

function fib(::Memoized, n)
	println("Using memoization algorithm")
	_fib(n)
end
```
相应的迭代算法可以如下实现:
```julia
function fib(algo::Iterative, n)
	n <= 2 && return 1
	prev1, prev2 = 1,1
	local curr
	for i in 3:n
		curr = prev1 + prev2
		prev1, prev2 = curr, prev1
	end
	return curr
end
```
由于第一个参数是Iterative对象,因此我们知道将相应地分派此函数.从客户端的角度来看,它可以根据需要选择记忆版本或迭代版本.由于记忆版本以O(1)速度运行,因此当n越大时速度应该更快.但是,对于较小的n值,迭代版本会更好.我们可以通过以下方式之一调用fib函数:
```julia
fib(Memoized(), 10)
fib(Iterative(),10)

```
如果客户端选择实现算法选择过程,则可以轻松完成,如下所示:
```julia
function fib(n)
	algo = n>50 ? Memoized(): Iterative()
	return fib(algo, n)
end
```

实现策略模式非常容易.多重分派的效果再次拯救了我们!接下来,我们将介绍另一种称为模板方法
### 11.3.7 模板方法模式

模板方法模式用于创建可以使用**不同种类**的**算法**或**操作**的**明确定义的过程**.作为模板,可以使用客户端所需的任何算法或函数对其进行自定义.在这里,我们将探讨如何在机器学习(ML)管道用例中利用模板方法模式.对于不熟悉ML管道的用户,提供简单版本.
```
+--------+     +--------+    +-----+    +--------+    +-------+
|  数据  | --> |  划分   | -> | 训练 | -> |Fit data| -> | 模型  |
+--------+     +--------+ |  +-----+    +--------+    +---o---+
						  |                               ↓
						  |  +-----+                  +-------+    +----------+
						  -> | 测试 | -------------->  | 验证  | -->| 准确率结果 |
							 +-----+                  +-------+    +----------+
```
$$图11-2$$
首先将数据集**划分**为两个单独的数据集以进行**训练和测试**. **训练数据集**被输入到将数据**拟合为统计模型**的过程中.然后,validate函数使用该模型**预测**测试集中的响应(也称为目标)变量.最后它将预测值与实际值进行比较,并确定模型的准确率.
假设我们已经按照以下步骤建立了管道:
```julia
using DataFrames, LinearAlgebra
# Run machine learning pipeline
function ml_run(data::DataFrame, response::Symbol, predictors::Vector{Symbol})
	train, test = split_data(data, 0.7)
	model = fit(train, response, predictors)
	validate(test, model, response)
end
```
为简洁起见,此处提供`split_data,fit`和`validate`简单实现
```julia
using DataFrames, GLM
# Split randomly to dfs for (train, test) `keep` as per% of records kept to test.
split_data(df::DataFrame, keep::Float64) = 
	let b = rand(size(df,1)) .< keep
	    (df[b, :], df[.!b, :])
	end

# Return a model for predicting the `response` var from the `predictors` vars.
function fit(df::DataFrame, response::Symbol, predictors::Vector{Symbol})
	# https://github.com/JuliaStats/StatsModels.jl/blob/master/src/terms.jl#L21C1
    formula = Term(response) ~ +(Term.(predictors)...)
    return GLM.lm(formula, df)
end

# Predict response variable using the model and validate accuracy of model.
function validate(df, model, response)
    yhat = GLM.predict(model, df)
    y = df[:, response]
    return (result = [y yhat], rmse = rmse_fn(yhat .- y))
end

"Root mean square error."
rmse_fn(ys) = GLM.norm(ys) / sqrt(length(ys))
```
管道概念在前面的逻辑中得到了证明. 让我们快速预测一下波士顿的房价.
```julia
using RDatasets
# Using original template
boston = RDatasets.dataset("MASS", "Boston");
result, rmse = ml_run(boston, :MedV, [:Rm, :Tax, :Crim]);
println(rmse)
```
在此示例中,响应变量为:MedV,我们将基于:Rm,:Tax和:Crim建立一个统计模型波士顿住房数据集包含美国人口普查局收集的有关马萨诸塞州波士顿地区住房的数据.许多统计分析教育文献都广泛使用它.我们在此示例 使用的变量是:
- MedV: 自有住房的中位数价值为1000美元
- Rm: 每个住宅的平均房间数
- Tax: 每10000美元的全额房产税率
- Crim: 按城镇划分的人均犯罪率
模型的准确率记录在`rmse`变量中(意味着均方根误差).默认实现使用**线性回归**作为拟合函数.

为了实现模板方法模式,我们允许插入过程的**任何部分**.因此,我们可以使用**关键字参数**修改函数:
```julia
# Run machine learning pipeline (template version w/ keyword args)
function ml_run2(data::DataFrame, response::Symbol, predictors::Vector{Symbol};
            fit = fit, split_data = split_data, validate = validate)
    train, test = split_data(data, 0.7)
    model = fit(train, response, predictors)
    validate(test, model, response)
end
```
在这里,我们添加了三个关键字参数:`fit,split_data和validate`. 为了说明其工作方式,让我们创建一个使用广义线性模型(GLM)的新拟合函数:
```julia
using GLM
# Custom fitting function
function fit_glm(df::DataFrame, response::Symbol, predictors::Vector{Symbol})
    formula = Term(response) ~ +(Term.(predictors)...)
    return glm(formula, df, Normal(), IdentityLink())
end
```

现在我们已经自定义了拟合函数,我们可以通过`fit`关键字参数传递程序来重新运行该程序.

```julia
result, rmse = ml_run2(boston, :MedV, [:Rm, :Tax, :Crim], fit = fit_glm);
println(rmse)
```
客户端只需传递函数即可轻松自定义管道,这是可行的,因为Julia支持第一类实体函数.
使用2个中介者的好处是,每个对象都可以专注于自己的职责,而不必担心下游影响.
一个主要中介者负责组织活动以及处理事件和交流.
接下来,我们将看看备忘录模式.

## 11.4 结构型模式
结构型设计模式用于将对象组合,尽可能多的重用组件.通过学习本节中描述的结构型模式,当我们在项目中遇到类似情况时,就有一个模板可以遵循.
在本节中,我们将回顾传统的面向对象的模式,包括适配器模式,桥接模式,组合模式,装饰器模式,外观模式,享元模式和委托模式.

### 11.4.1适配器模式
适配器模式用于使一个对象与另一个对象一起工作.假设我们需要集成两个子系统,但是由于不能满足接口要求,我们可以使用委托模式包装一个对象,并提供符合所需接口的其他功能.
我们如何解决这个问题?首先,让我介绍LinkedList实现. 遵循AbstractArray接口
```julia
# module LinkedList
mutable struct Node{T} # <: AbstractArray{T,1}
    prev::Union{Node,Nothing}
    next::Union{Node,Nothing}
    value::T
end

list(x) = Node(nothing, nothing, x)  

# accessors
prev(n::Node) = n.prev
next(n::Node) = n.next
value(n::Node) = n.value

"Insert new elements at current position."
function Base.insert!(n::Node{T}, x:: Union{T, Node}) where T
    new_node = x isa Node ? x : Node(n, n.next, x) # 1. x 节点的从中间插入, 构建此关系
    if n.next !== nothing # 2. 右侧节点next, 那么还要维护其前向节点关系.
        n.next.prev = new_node
    end
    n.next = new_node # 3. 左侧
    return new_node
end

function Base.show(io::IO, n::Node)
    isnothing(n) && return nothing
    current_node = n
    seen_nodes = Set{Node}()
    while !isnothing(current_node)
	    if current_node in seen_nodes 
		    @warn "检测到循环,广播已停止以避免无限循环."
		    break
		end
		println(io, "Node: $(current_node.value)")
		push!(seen_nodes, current_node)
		current_node = next(current_node)
	end
	return nothing	
end
```
这是一个相当标准的双向链表设计.
```julia
L = list(1);
insert!(L,2);
insert!(next(L),3);
insert!(next(next(L)), 4);
ans.next = L; L.prev = ans;
```
在这种情况下,我们可以构建一个符合AbstractArray接口的包装器(或所谓的适配器).首先,让我们创建一个新类型并将其设为AbstractArray的子类型:
```julia
struct MyArray{T} <: AbstractArray{T,1}
	data::Node{T}
end
```
因为我们只需要支持一维数组符合AbstractArray接口,我们应该实现`Base.size`和`Base.getindex`
```julia
function Base.size(ar::MyArray)
	n = ar.data
	count = 0
	seen_nodes = Set{Node}()
	while n !== nothing
		if n in seen_nodes 
		    @warn "检测到循环."
		    break
		end
		push!(seen_nodes, n)
		n = next(n)
		count +=1
	end
	return (count, 1)
end

function Base.size(n::Node, i=nothing)
	count = 0
	seen_nodes = Set{Node}()
	while n !== nothing
		if n in seen_nodes 
		    @warn "检测到循环."
		    break
		end
		push!(seen_nodes, n)
		n = next(n)
		count +=1
	end
	return isnothing(i) ? (count, 1) : (count, 1)[i]
end
```

该函数通过使用next函数遍历链表来确定数组的长度.支持索引元素,我们可以如下定义getindex函数:
```julia
function Base.getindex(n::MyArray, idx::Int)
    n = n.data
    for i in 1:(idx-1)
        next_node = next(n)
        next_node === nothing && throw(BoundsError(n.data, idx))
        n = next_node
    end
    return value(n)
end

function Base.getindex(n::Node, idx::Int)
    for i in 1:(idx-1)
        next_node = next(n)
        next_node === nothing && throw(BoundsError(n.data, idx))
        n = next_node
    end
    return value(n)
end
```
这就是我们要做的所有包装器工作.让我们现在旋转一下.


#### 双向链表-扩展广播
```julia
# 实现 broadcast
function Broadcast.broadcasted(::typeof(|>), n::Node{T}, tubeFunc=identify) where T
    results = []
    current_node = n
    seen_nodes = Set{Node}()
    while !isnothing(current_node)
	    if current_node in seen_nodes 
		    @warn "检测到循环,广播已停止以避免无限循环."
		    break
		end
		push!(seen_nodes, current_node)
		push!(results, tubeFunc(current_node))
		current_node = next(current_node)
	end
	return results
end
```

### 11.4.2 组合模式
组合模式用于对可以分组在一起但仍被视为与单个对象相同的对象进行建模.这种情况并不罕见,例如在绘图应用程序中的形状组合在一起时,仍有对象的位置和大小.投资组合管理也会发生类似情况.我有一个由多个共同基金组成的退休投资账户.每个共同基金都可以投资股票,债券或两者都投资.然后,一些基金也可能投资其他共同基金.
从会计角度来看,我们总是可以确定股票,债券,股票基金,债券基金和基金的市场价值
```julia
struct Holding
	symbol::String
	qty::Int
	price::Float64
end
```
Holding类型包含交易代码,数量和当前价格.我们可以如下定义一个投资组合:
```julia
struct Portfolio
	symbol::String
	name::String
	stocks::Vector{Holding}
	subportfolios::Vector{Portfolio}
end
Portfolio(symbol::String, name::String, Holdings::Vector{Holding}) =
    Portfolio(symbol, name, Holdings, Portfolio[])  

Portfolio(symbol::String, name::String, subportfolios::Vector{Portfolio}) =
    Portfolio(symbol, name, Holding[], subportfolios)
```
投资组合由符号(交易代码),名称,持股组和子投资组合数组标识.创建一个样本投资组合:
```julia
function sample_portfolio()
	large_cap = Portfolio("TOMKA", "Large Cap Portfolio",[
		Holding("AAPL",100,275.15),
		Holding("IBM",200,134.21),
		Holding("GOOG",300,1348.83)])
	
	small_cap =Portfolio("ToMKB", "Small Cap Portfolio",[
		Holding("ATo",100,107.05),
		Holding("BURL",200,225.09),
		Holding("ZBRA",300,257.80)])

	p1 = Portfolio("ToMKF","Fund of Funds Sleeve", [large_cap,small_cap])
	p2 = Portfolio("TOMKG","Special Fund Sleeve", [Holding("C",200,	76.391)])
	return Portfolio("TOMz","Master Fund",[p1, p2])
end
sample_portfolio()  # = 
Portfolio("TOMz", "Master Fund", Holding[], 
	Portfolio[ # p1
		Portfolio("ToMKF", "Fund of Funds Sleeve", Holding[], 
			Portfolio[ # large_cap
				Portfolio("TOMKA", "Large Cap Portfolio", Holding[
					Holding("AAPL", 100, 275.15), 
					Holding("IBM", 200, 134.21), 
					Holding("GOOG", 300, 1348.83)],
					Portfolio[]
				), # small_cap
				Portfolio("ToMKB", "Small Cap Portfolio", Holding[
					Holding("ATo", 100, 107.05), 
					Holding("BURL", 200, 225.09), 
					Holding("ZBRA", 300, 257.8)], 
					Portfolio[]
				)
			]
		), # p2
		Portfolio("TOMKG", "Special Fund Sleeve", Holding[
			Holding("C", 200, 76.391)], Portfolio[]
		)
	]
)


Base.show(io::IO,h::Holding)=print(io,h.symbol," ", h.qty," shares @ \$",h.price)
Base.show(io::IO, p::Portfolio) = myshow(io, p)
function myshow(io::IO, p::Portfolio, level = 0)
    println("  " ^ level, p.name, " (", p.symbol, ")")
    if length(p.stocks) > 0
        println(io, "  ", "  " ^ level, "Holdings:")
        foreach(h -> println(io, "  " ^ level, "    ", h), p.stocks)
    end

    if length(p.subportfolios) > 0
        foreach(subpf -> myshow(io, subpf, level + 1), p.subportfolios)
    end
end
```

从缩进的输出中可以更清楚地看到结构.
```julia
Master Fund (TOMz)
  Fund of Funds Sleeve (ToMKF)
    Large Cap Portfolio (TOMKA)
      Holdings:
        AAPL 100 shares @ $275.15
        IBM 200 shares @ $134.21
        GOOG 300 shares @ $1348.83
    Small Cap Portfolio (ToMKB)
      Holdings:
        ATo 100 shares @ $107.05
        BURL 200 shares @ $225.09
        ZBRA 300 shares @ $257.8
  Special Fund Sleeve (TOMKG)
    Holdings:
      C 200 shares @ $76.391
```
因为我们要支持在任何级别上计算市场价值的能力,所以我们只需要为每种类型定义market_value
```julia
market_value(s::Holding)=s.qty * s.price
```
市场价值不过是数量乘以价格.投资组合的市场价值的计算只复杂一点点:
```julia
market_value(p::Portfolio) =
    mapreduce(market_value, +, p.stocks, init = 0.0) +
    mapreduce(market_value, +, p.subportfolios, init = 0.0)

market_value(p::Portfolio) = sum(market_value.(p.stocks)) + sum(market_value.(p.subportfolios)) 
# Base.reduce_empty_iter(op, itr, ::Base.HasEltype) = 0.0 破坏性方法
# 原始方法
market_value(p::Portfolio) = sum(market_value.(p.stocks)) +
    (length(p.subportfolios) > 0 ? sum(market_value.(p.subportfolios)) : 0.0)

function sample_portfolio2()
	large_cap = Portfolio("TOMKA", "Large Cap Portfolio",[
		Holding("AAPL",100,275.15),
		Holding("IBM",200,134.21),
		Holding("GOOG",300,1348.83)])
	
	small_cap =Portfolio("ToMKB", "Small Cap Portfolio",[
		Holding("ATo",100,107.05),
		Holding("BURL",200,225.09),
		Holding("ZBRA",300,257.80)])

	p1 = Portfolio("ToMKF","Fund of Funds Sleeve", [large_cap,small_cap])
	p2 = Portfolio("TOMKG","Special Fund Sleeve", [Holding("C",200,	76.391)])
	# return Portfolio("TOMz","Master Fund",[p1, p2])
	return p2
end
```

在这里,我们使用mapreduce函数来计算单个股票(或subportfolios)的市场价值,并将其汇总.由于投资组合可能包含多个持股和多个subportfolios,因此我们需要对两者进行计算并将它们加在一起.由于每
个子投资组合也是一个portfolio对象,因此该代码自然会更深地递归到子subportfolios中.组合没有什么花哨的.因为Julia支持泛型函数,所以我们可以为单个对象以及分组对象提供实现.

接下来,我们将讨论享元模式.
### 11.4.3 享元模式

享元模式通过共享相似/相同对象的内存来有效地处理大量**细粒度**对象.一个很好的例子涉及处理字符串.在数据科学领域,我们经常需要阅读和分析以表格格式表示的大量数据.在许多情况下,某些列可能包含大量只是重复值的字符串.例如,人口调查可能会有一列说明性别的列,因此它将包含Male或Female.与其他一些编程语言不同,字符串在Julia中不被保留.这意味着将重复存储单词
Male的10个副本,它占用单个Male字符串使用的存储空间的10倍.我们可以从REPL轻松看
到这种效果,如下所示.
```julia
s = ["Male" for _ in 1:1_000];
Base.summarysize(s)
8052
s = ["Male" for _ in 1:100_000];
Base.summarysize(s)
800052 = 800000 + 40 + 8 + length("Male")

Base.summarysize([]) # 40
Base.summarysize([""]) # 56
Base.summarysize(["A"]) # 57
Base.summarysize(["",""]) # 64
Base.summarysize(["A","A"]) # 74

Base.summarysize([nothing for _ in 1:1000]) # 40 不分配内容内存. 
Base.summarysize(['B' for _ in 1:1000]) # 4040 内容占据 4000
Base.summarysize(["" for _ in 1:1000]) # 8048 双倍, 则增加一个类型8
Base.summarysize(["A" for _ in 1:1000]) # 8049 内容占据

```
因此,存储100000个Male字符串副本将占用大约800KB的内存.那真是浪费内存.解决此问题的常用方法是维护池化数组.除了存储100000个字符串,我们还可以对数据进行编码并存储100000个字节,0x01对应于男性,0x00对应于女性.我们可以使用s将内存占用减少8倍,如下所示.
```julia
s = [0x01 for _in 1:100_000];
Base.summarysize(s)
100040
```
你可能想知道为什么要报告40个额外的字节.这40个字节实际上由数组容器使用.
```julia
s = BitArray(rand(Bool) for _ in 1:100_000);
Base.summarysize(s) # 12568
```
同样,通过使用BitArray存储性别值,我们将内存使用量减少为1/8(从1字节变为1位).这是对内存使用的积极优化.但是我们仍然需要将Male和Female字符串存储在某个地方,对吗?这是一项容易的任务,因为我们知道可以在任何数据结构(例如字典)中对它们进行跟踪.
```julia
const gender_map = Dict(true => "Male",false =>"Female")
	Dict{Bool,String} with 2 entries:
	false =>"Female"
	true =>"Male"
Base.summarysize(gender_map) # 370
```
综上所述,我们现在能够在12568+370=12938字节的内存中存储100000个性别值.与
原始的直接存储字符串的简单方式相比,我们节省了98%以上的内存消耗!我们如何实现
如此巨大的节省?因为所有记录共享相同的两个字符串.我们唯一需要维护的数据是对这
些字符串的引用数组.

因此,这就是**享元模式**的概念.在许多地方,一遍又一遍地使用相同的技巧.
CSV.jl包使用了一个名为**CategoricalArrays**的包,该包提供了基本上相同的内存优化.

### 11.4.4 桥接模式,装饰器模式和外观模式

它们相对容易实现,而且你已经掌握了先前设计模式部分中的许多思想.
它们与(委托,单例类型,多重分派,第一类实体函数,抽象类型和接口)的方法相同.

#### 桥接模式
bridge
用于将抽象与其实现**分离**,从而使其可以独立发展.
建立抽象类型的层次结构,实现者可以针对这些抽象类型开发符合这些接口的软件.
- Julia的数字类型是很好的例子.有许多抽象类型可用 例如 Integer,AbstractFloat和Real.
- 由Base包提供了具体的实现,例如Int和Float64
- 设计足够抽象时,可以轻易另一种实现方式.SaferInteger包为数字避免了数值溢出.

#### 装饰器模式
它可以用来增强具有新功能的现有对象,因此称为装饰器
假设已经购买了第三方库,但对功能并不满意.可通过**新函数包装**现有库,即**装饰器模式**  

#### 委托模式
将**现有类型**包装为**新类型**,可通过委托给基础对象来重用现有功能.向新类型添加新函数以获得新功能.

#### 外观模式
用于封装复杂的子系统,并为客户端提供简化的接口.我们需要做的就是创建一个新类型,并提供一个在该新类型上运行的简单API.我们可以使用**委托模式**将请求转发到其他封闭类型.

现在,我们已经研究了所有传统的面向对象模式.可能你已经注意到,许多用例都可以通过本书中描述的Julia基本功能和模式来解决.这不是巧合,而是在Julia中可以轻松解决复杂问题.
