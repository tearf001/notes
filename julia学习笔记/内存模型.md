[# 栈、栈帧与函数调用](https://ctfbook.ph0en1x.com/reverse/zhan-3001-zhan-zheng-yu-han-shu-diao-yong)
## 基本概念

在操作系统中，一般用**栈**来保存函数的**状态**和**局部变量**。
在x86架构中，使用esp寄存器指向栈顶的内存地址；在x64架构中，使用rsp寄存器指向栈顶。一般可以简称为sp。

- ESP寄存器又被称为**栈指针**（Stack Pointer）
- EBP寄存器又被称为**帧指针**（Frame Pointer）

**1. ESP 寄存器**
- **ESP：** Extended Stack Pointer（扩展栈指针）    
- **作用：** ESP 寄存器指向**当前栈顶的内存地址**。    
    - **栈顶：** 栈的顶部是最后被压入栈的元素的所在位置。        
    - **栈增长方向：** 多数架构中，栈内存从高地址向低增长。入栈ESP  ↓  ,出栈时，ESP  ↑
    - **动态变化：** ESP 的值在程序运行过程中随着**函数调用和返回**会动态变化。        
- **用途：**    
    - **入栈/出栈操作：** CPU 使用 ESP 寄存器来进行入栈（push）和出栈（pop）操作。        
    - **访问栈数据：** 程序可以通过 ESP 寄存器来访问当前栈顶的数据。        
    - **跟踪栈帧：** ESP 寄存器在函数调用过程中，用于跟踪当前栈帧的边界。        

**2. EBP 寄存器**
- **EBP：** Extended Base Pointer（扩展基址指针）或 Extended Frame Pointer（扩展帧指针）    
- **作用：** EBP 寄存器指向**当前栈帧的起始地址**（也称为基址）。    
    - **栈帧：** 栈帧是为函数调用分配的栈内存区域，存储函数的局部变量、参数和返回地址。  
    - **固定基准：** 在函数执行过程中，EBP 的值通常不变，作为访问当前栈帧中数据的基准。
    - **链接栈帧：** EBP 寄存器用于链接栈中的不同栈帧，可以方便地遍历函数调用链。
- **用途：**    
    - **访问局部变量：** 程序可以通过 EBP 寄存器加上偏移量来访问当前栈帧中的局部变量。
    - **访问函数参数：** 函数参数通常被压入调用者的栈帧，通过 EBP 和 偏移量可以访问。       
    - **回溯函数调用：** EBP 寄存器用于构建栈回溯信息，在调试时可以查看函数调用链。        

**3. 为什么需要 ESP 和 EBP？**
- **动态管理：** ESP 寄存器用于动态地管理栈内存的增长和收缩，确保每次入栈和出栈操作正确
- **函数调用支持：** EBP 寄存器用于构建栈帧，使得函数调用能够正确地传递参数、返回结果，以及访问局部变量。    
- **方便访问：** EBP 寄存器为访问栈中的数据提供了一个稳定的基准地址，方便程序访问局部变量和函数参数。    
- **调试：** EBP 寄存器用于构建栈回溯信息，使得调试器可以追踪函数调用链，定位程序错误。
    
**4. 它们是如何协同工作的？**
- **函数调用：**
    1. **调用者：** 在调用函数之前，会将参数压入栈中，并保存返回地址。        
    2. **被调用者：**        
        - 会将当前的 EBP 的值保存到栈中，并把 ESP 的值赋给 EBP，这样 EBP 就指向了新栈帧的起始地址。            
        - 会调整 ESP 的值，为局部变量分配栈空间。
    3. **函数执行：** 函数执行过程中，会通过 EBP 加上偏移量来访问局部变量和参数。
    4. **函数返回：**
        - 会将保存在栈中的 EBP 值恢复到 EBP 寄存器，这样 EBP 就恢复到了调用者的栈帧。
        - 会调整 ESP 的值，回收当前栈帧的内存空间。
        - 会从栈中弹出返回地址，并跳转到调用者的代码处。            
- **整体流程：** ESP 始终指向栈顶，动态变化；EBP 则指向当前栈帧的基址，作为访问局部变量和参数的基准。

**总结:**

- **ESP (Extended Stack Pointer)：** 扩展栈指针，指向当前栈顶，用于动态管理栈。    
- **EBP (Extended Base Pointer/Extended Frame Pointer)：** 扩展基址/帧指针，指向当前栈帧的基址，用于访问局部变量和参数。    
- ESP 和 EBP 寄存器共同协作，使得函数调用能够正确执行，并且方便程序访问栈中的数据。

### #栈帧
栈帧是指函数在被调用时，所拥有的一块独立的用于存放函数所使用的状态和变量的栈空间。
每个函数都对应有一个栈帧。同一个函数多次进入，每次可能会分配到不同的栈帧。
整个栈的内容在同一个时刻可以看作是由许多栈帧依序“堆叠”组成的。

对于一个运行中的函数，其使用的栈帧区域被sp和bp寄存器限定
> <strike>对于x86，sp等价esp，bp等价rsp</strike>；
> 对于x64，sp等价rsp，bp等价rbp）。

bp指向栈帧的底部，sp指向栈帧的顶部。
```
内存高端   
     ┌───────────────────────────┐          一次函数调用的栈结构：
     │  命令行参数及环境变量        │          ┌──────────────────-─┐
     │  Command Line Parameters  │          │  函数参数 Arg    N  │
     ├───────────────────────────┤          │  函数参数 ...       │
  ↑  │           栈 Stack        │ →        │   函数参数 Arg   1  │
	 │		       ↓             │          ├───────────────────┤
  地 │             ↑             │          │   返回地址  Addr    │
  址 │           堆 Heap         │           ├───────────────────┤
  变 │                           │          │   当前栈帧的起始地址 │← EBP 
  大 │  BSS 段                   │          ├───────────────────-┤
     ├───────────────────────────┤          │  本地变量 LocalVar 1│
     │  数据段 .DATA              │          │   ...              │
     ├───────────────────────────┤          │  本地变量 LocalVar k│
     │  代码段 .CODE              │          └───────────────────┘ ← ESP 栈指针
     └───────────────────────────┘
低端内存
```
> 内存中的堆栈结构
> 在函数中使用的所有变量（本地变量、实参），一般使用bp定位。设N为整型字节数，bp+2N是第一个实参的地址，bp-N是第一个本地变量的地址。



 **BSS段**：（Block Started by Symbol Segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS段属于静态内存分配。 

**数据段**（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。 

**代码段**（code segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域**通常**属于只读, 也有可能包含一些只读的常数变量.

 **堆** 是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减） 

 **_栈(stack)_**：栈又称堆栈， 是用户存放程序临时创建的局部变量，也就是说我们函数()中定义的变量（但不包括static声明的变量，static意味着在**数据段**中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区.

## 函数调用 stdcall

一个函数调用，一般需要以下步骤 $f(a, b, c)$

1. 保存函数的实参    $c, b, a$
2. 保存子函数结束后，需要返回的地址（返回到哪里$f _{next}$）    
3. 保存父函数的 #栈帧 信息    
4. 在栈上**开辟**空间供局部变量使用    
5. **执行函数**实现的功能    
6. 释放**局部变量**使用的空间    
7. 根据保存的父函数 #栈帧 信息，恢复父函数 #栈帧    
8. 根据保存的返回地址，恢复父函数执行流，即$f _{next}$