## 6.1 前言
### 全局变量
```julia
variable=10
function add_using_global_variable(x)
	return x+variable
end
@code_llvm add_using_global_variable(10)
# 编译器无法真正假设全局变量始终是整数。
; Function Signature: add_using_global_variable(Int64)
; @ REPL[69]:1 within `add_using_global_variable`
; Function Attrs: uwtable
define nonnull ptr @julia_add_using_global_variable_2998(i64 signext %"x::Int64") #0 {
top:
  %jlcallframe1 = alloca [2 x ptr], align 8 # 分配栈空间 # 存储函数参数
  %gcframe2 = alloca [4 x ptr], align 16 # GC
  # gcframe2 进行初始化,并设置了 GC 相关的指针
  call void @llvm.memset.p0.i64(ptr align 16 %gcframe2, i8 0, i64 32, i1 true)
  %pgcstack = call ptr inttoptr (i64 140706155432000 to ptr)() #9
  store i64 8, ptr %gcframe2, align 16
  %frame.prev = getelementptr inbounds ptr, ptr %gcframe2, i64 1
  %task.gcstack = load ptr, ptr %pgcstack, align 8
  store ptr %task.gcstack, ptr %frame.prev, align 8
  store ptr %gcframe2, ptr %pgcstack, align 8
  # ; @ REPL[69]:2 within `add_using_global_variable` 
  # 全局变量访问的核心, 原子加载一个指针ptr(全局变量)
  %variable.checked=load atomic ptr, ptr @"*Main.variable#3000.jit" unordered, align 16
  # 检查加载的指针是否为空。如果为空,则跳转到 err 标签,表示全局变量未定义
  %.not = icmp eq ptr %variable.checked, null
  br i1 %.not, label %err, label %ok # 根据比较结果进行分支跳转。

err:                                              ; preds = %top
  call void @ijl_undefined_var_error(ptr nonnull @"jl_sym#variable#3001.jit", ptr nonnull @"jl_global#3002.jit")
  unreachable

ok:                                               ; preds = %top
  %gc_slot_addr_1 = getelementptr inbounds ptr, ptr %gcframe2, i64 3 # 申请指针地址
  store ptr %variable.checked, ptr %gc_slot_addr_1, align 8 # 将指针存储到GC tracker
  # 将局部变量 x 装箱成一个 Int64 对象。这是因为 Julia 中所有值都是对象
  %box_i64=call !null align 8 dereferenceable(8) ptr @ijl_box_i64(i64 signext %"x::I64")
  %gc_slot_addr_0 = getelementptr inbounds ptr, ptr %gcframe2, i64 2 # 申请装箱指针地址
  
  store ptr %box_i64, ptr %gc_slot_addr_0, align 16 # 将装箱后的 x 的指针存储到 GC 框架中
  store ptr %box_i64, ptr %jlcallframe1, align 8 # 参数指针存储到 jlcallframe1
  %0 = getelementptr inbounds ptr, ptr %jlcallframe1, i64 1
  store ptr %variable.checked, ptr %0, align 8
  %1 = call nonnull ptr @ijl_apply_generic(ptr nonnull @"jl_global#3004.jit", ptr nonnull %jlcallframe1, i32 2) # 调用 ijl_apply_generic 函数执行加法。注意使用泛型函数调用
  %frame.prev6 = load ptr, ptr %frame.prev, align 8
  store ptr %frame.prev6, ptr %pgcstack, align 8
  ret ptr %1
}
```
#常量占位符 全局常量被分配了一个Ref对象。在Julia中，Ref对象不过是一个占位符，其中包含已
知封闭对象的类型。你可以在Julia REPL中尝试以下操作
```julia
# Initialize aconstant Ref object with the value of 10
const semi_constant = Ref(10)
function add_using_global_semi_constant(x)
  return x + semi_constant[]
end
# 可修改
semi = Ref(1)
semi[] =  20
semi # Base.RefValue{Int64}(20)
```

## 6.2 全局常量

示例2——PyCall.jl程序包
PyCall.jl包的文档建议用户使用**全局变量占位符**技术存储Python对象。
在其文档中可以找到以下摘录：

>对于类型稳定的全局常量,请在顶层将常量初始化为`PyNULL()`,然后使用模块的_init__函数中的copy!函数将其更改为实际值

对于高性能代码,通常需要类型稳定的全局常量。基本上,初始化模块时,可以使用`PyNULL()`值初始化此全局常量。该常量实际上只是一个占位符对象,以后可以用实际值对其进行更改。
> 此技术类似于在6.26节中提到的Ref的用法。

## 6.3 数组结构模式

英特尔处理器支持一种称为单指令多数据(SIMD)的技术。通过利用**流SIMD扩展**(SSE)和高级矢量扩展(**A**dvanced**V**ectore**X**tension)寄存器,可以在单个CPU周期内执行多个数学运算。
![TUP](https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/SIMD.svg/225px-SIMD.svg.png)
> **SSE**(英语：Streaming SIMD Extensions)是[英特尔](https://zh.wikipedia.org/wiki/%E8%8B%B1%E7%89%B9%E5%B0%94 "英特尔")在[AMD](https://zh.wikipedia.org/wiki/AMD "AMD")的[3D Now!](https://zh.wikipedia.org/wiki/3DNow! "3DNow!")发布一年之后,在其计算机芯片[Pentium III](https://zh.wikipedia.org/wiki/Pentium_III "Pentium III")中引入的指令集,是继[MMX](https://zh.wikipedia.org/wiki/MMX "MMX")的扩展指令集。SSE指令集提供了70条新指令。[AMD](https://zh.wikipedia.org/wiki/AMD "AMD")后来在[Athlon XP](https://zh.wikipedia.org/wiki/Athlon "Athlon")中加入了对这个新指令集的支持。
> 现代的并行计算框架 OpenCL, CUDA

利用这些奇特的CPU指令的先决条件之一就是首先要确保数据位于连续的内存块中。我们如何将数据定向在连续的内存块中?你可以在本节中找到解决方案。
### BDM (Business Domain Model)
让我们看自纽约市的出租车数据(2018年12月的数据并将其截断为100000条记录)。
https://raw.githubusercontent.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/master/Chapter06/StructOfArraysPattern/yellow_tripdata_2018-12_100k.csv

TripPayment 模型
```julia
struct TripPayment
	vendor_id::String
	tpep_pickup_datetime::String
	tpep_dropoff_datetime::String
	passenger_count::Int
	trip_distance::Float64
	fare_amount::Float64
	extra::Float64
	mta_tax::Float64
	tip_amount::Float64
	tolls_amount::Float64
	improvement_surcharge::Float64
	total_amount::Float64
end
```
预览

| VendorID  | tpep_pickup_datetime   | tpep_dropoff_datetime   | passenger_count | trip_distance  | RatecodeID  | store_and_fwd_flag  | PULocationID  | DOLocationID  | payment_type  | fare_amount  | extra | mta_tax | tip_amount  | tolls_amount  | improvement_surcharge | total_amount  |
| --------- | ---------------------- | ----------------------- | --------------- | -------------- | ----------- | ------------------- | ------------- | ------------- | ------------- | ------------ | ----- | ------- | ----------- | ------------- | --------------------- | ------------- |
| 2         | 08/16/2018 08:19:06    | 08/16/2018 08:26:01     | 3               | 1.19           | 1           | N                   | 233           | 164           | 1             | 6.5          | 0.5   | 0.5     | 1.56        | 0             | 0.3                   | 9.36          |
| 2         | 08/16/2018 08:27:47    | 08/16/2018 08:41:43     | 4               | 2.32           | 1           | N                   | 164           | 148           | 1             | 11           | 0.5   | 0.5     | 2.46        | 0             | 0.3                   | 14.76         |
| 2         | 08/16/2018 08:52:33    | 08/16/2018 08:57:27     | 2               | 1.38           | 1           | N                   | 137           | 229           | 2             | 6.5          | 0.5   | 0.5     | 0           | 0             | 0.3                   | 7.8           |
| 2         | 08/16/2018 08:00:00    | 08/16/2018 08:22:00     | 5               | 4.47           | 1           | N                   | 186           | 41            | 1             | 18.5         | 0.5   | 0.5     | 2.97        | 0             | 0.3                   | 22.77         |
| 2         | 08/16/2018 08:50:09    | 08/16/2018 09:03:56     | 5               | 3.11           | 1           | N                   | 141           | 151           | 1             | 13           | 0.5   | 0.5     | 1.7         | 0             | 0.3                   | 16            |
| 2         | 08/16/2018 08:11:55    | 08/16/2018 08:25:24     | 1               | 2.44           | 1           | N                   | 68            | 170           | 1             | 11           | 0.5   | 0.5     | 2.46        | 0             | 0.3                   | 14.76         |
| 2         | 08/16/2018 08:55:53    | 08/16/2018 09:02:02     | 1               | 1.15           | 1           | N                   | 246           | 90            | 1             | 6.5          | 0.5   | 0.5     | 1.56        | 0             | 0.3                   | 9.36          |

```julia
function read_trip_payment_file(file)
	# 源代码 https://github.com/JuliaData/CSV.jl/blob/main/src/file.jl#L162
	f = CSV.File(file, skipto=2) # skipto 不指定, 它会推断列头. 为0的时候,生成Column1~n
	records = Vector{TripPayment}(undef,length(f))
	for (i,row) in enumerate(f)
		records[i] = TripPayment(row.VendorID,
			row.tpep_pickup_datetime,
			row.tpep_dropoff_datetime,
			row.passenger_count,
			row.trip_distance,
			row.fare_amount,
			row.extra,
			row.mta_tax,
			row.tip_amount,
			row.tolls_amount,
			row.improvement_surcharge,
			row.total_amount)
	end
	return records
end
filename = "yellow_tripdata_2018-12_100k.csv"
records = read_trip_payment_file(filename)
 # materialize a csv file as a DataFrame, copying columns from CSV.File
df = CSV.File(filename) |> DataFrame

# to avoid making a copy of parsed columns, use CSV.read
df = CSV.read(filename, DataFrame)

# load a csv file directly into an sqlite database table
db = SQLite.DB()
tbl = CSV.File(filename) |> SQLite.load!(db, "sqlite_table")  
```
使用生成器语法并避免分配
```julia
@btime mean(r.fare_amount for r in $records) # 180.600 μs (0 allocations: 0 bytes)
fare_amounts = [r.fare_amount for r in records]
@btime mean($fare_amounts) # 12.200 μs (0 allocations: 0 bytes)
@btime mean(fare_amounts) # 27.090 μs (1 allocation: 16 bytes)
```

### 结构数组 vs 数组结构
`Vector{TripPayment}` vs [..]

在结构数组中,要访问对象的字段,程序必须首先索引该对象,然后通过内存中的预定偏移量找到该字段。例如,TripPayment对象中的passenger_count字段是结构的第四个字段,其中前三个字段是Int64、String和String types。因此,到第四个字段的偏移量为24。

结构的数组具有面向行的布局,因为每一行都存储在连续的内存块中。

在数组的结构中,我们采用面向列的方法。在这种情况下,我们只为整个数据集维护一个对象。在对象内,每个字段代表原始记录的特定字段的数组。例如,fare_amount字段将作为票价金额数组存储在此对象中。

面向列的格式针对高性能计算进行了优化,因为数组中的数据值均具有相同的类型,内存也更紧凑。

> 在64位系统中,结构通常对齐到8字节存储块中。例如,一个仅包含Int32和Int16类型的两个字段
的结构仍然消耗8个字节,即使6个字节足以存储数据,2个额外的字节用于将数据结构填充到边界。

```julia
# 构造数组结构
struct TripPaymentColumnarData
	vendor_id::Vector{Int}
	tpep_pickup_datetime::Vector{String}
	tpep_dropoff_datetime::Vector{String}
	passenger_count::Vector{Int}
	trip_distance::Vector{Float64}
	fare_amount::Vector{Float64}
	extra::Vector{Float64}
	mta_tax::Vector{Float64}
	tip_amount::Vector{Float64}
	tolls_amount::Vector{Float64}
	improvement_surcharge::Vector{Float64}
	total_amount::Vector{Float64}
end
columar_records=TripPaymentColumnarData(
	[r.vendor_id forrin records],
	[r.tpep_pickup_datetime forr in records],
	[r.tpep_dropoff_datetime forr in records],
	[r.passenger_count forrin records],
	[r.trip_distance for rinrecords],
	[r.fare_amountforrin records],
	[r.extra forrin records],
	[r.mta_tax forrin records],
	[r.tip_amountforrin records],
	[r.tolls_amountforrin records],
	[r.improvement_surcharge for rin records],
	[r.total_amount forrin records]
)
# 完成后,我们可以证明新的对象结构确实已优化。
@btime mean(columar_records.fare_amount);
# 27.202 μs (1 allocation:16 bytes) # 具有出色的性能。
```

### 使用StructArrays包
我们非常不满意先前丑陋的柱状(列)结构。我们不仅需要创建带有大量Vector字段的新数据类型,还需要创建构造函数以将结构数组转换为新类型。
当我们在Julia生态系统中使用功能强大的包时,我们可以意识到Julia的强大。为了完全实现此模式,我们将引入StructArrays.jl包,该包可将把数机械重复的转换任务(将结构体数组转换为数组结构)自动化。
实际上,使用StructArrays非常简单:
```julia
using StructArrays
sa = StructArray(records)
```
让我们快速浏览一下内容。首先,我们可以像对待原始数组一样对待sa,例如我们可以像以前一样处理数组的前三个元素。
```julia
sa[1:3]
3-element StructArray(::Array{Int64,1},::Array{String,1},::Array{String,1},::Arra
y{Int64,1},::Array{Float64,1},::Array{Float64,1},::Array{Float64,1},::Array{Floa
t64,1},::Array{Float64,1},::Array{Float64,1},::Array{Float64,1},::Array{Float64,
1}) # with eltype TripPayment:
TripPayment(1,"2018-12-01 00:28:22","2018-12-01 00:44:07",3.95,0.0,0.3,17.25)
TripPayment(1,"2018-12-01 00:52:29","2018-12-0101:11:37",3,2.3,13.0,0.5,0.5)
TripPayment(2,"2018-12-0100:12:52","2018-12-01 00:36:23",1,0.0,2.5,0.5,0.5)
# 如果我们只选择一条记录,它将返回原始的TripPayment对象。
sa[1]
TripPayment(1,"2018-12-01 00:28:22","2018-12-0100:44:07",2,2.5,12.0,0.5,0.5)
# 确保没有错误,我们还可以检查第一条记录的类型。
typeof(sa[1]) # TripPayment
```
使用 [range]横行切片
使用 .member 纵向切片

DenseArray是数组的超类型。什么是DenseArray?实际上,它是一种抽象类型,其数组中的所有元素都分配给一个连续的内存, Julia默认情况下支持动态数组,这意味着当我们向其中推送更多数据时,数组的大小会增加。当分配更多内存时,它将现有数据复制到新的内存位置。
为了避免过多的内存重新分配,当前的实现使用一种复杂的算法来增加内存分配的大小一一以足够快的速度避免过多的重新分配,但又要足够保守以至于不会过度分配内存。

```julia
Base.summarysize(records)/1024/1024
15.068092346191406
Base.summarysize(sa)/1024/1024
14.305671691894531
records = nothing # 不再需要
sa = nothing # 计算后丢弃
GC.gc()

```
### StructArray 的其他用法
```julia
# 一维向量
a=[1,2,3,4]
asa = StructArray((x=a))
4-element StructArray(::Vector{Int64}) with eltype @NamedTuple{x::Int64}:
 (x = 1,)
 (x = 2,)
 (x = 3,)
 (x = 4,)

asa.x == a # true 指向同一个内存
asa = StructArray((x=a, y=[i*i for i in a]))
@NamedTuple{x::Int64, y::Int64}:
 (x = 1, y = 1)
 (x = 2, y = 4)
 (x = 3, y = 9)
 (x = 4, y = 16)

asa.y   #[1, 4, 9, 16]

asa[1]
(x = 1, y = 1)
asa[4]
(x = 4, y = 16)
# 二维向量
a, b = [1 2; 3 4], [1 4; 9 16]
t = StructArray((a = a, b = b))
t[2,2]) == (a = 4, b = 16) # true
t[2,1:2] == StructArray((a = [3, 4], b = [9, 16])) # true
2-element StructArray(::Vector{Int64}, ::Vector{Int64}) with eltype @NamedTuple{a::Int64, b::Int64}:
 (a = 3, b = 9)
 (a = 4, b = 16)

```
### 处理嵌套对象结构
前面的案例适用于任何平面数据结构。如今,设计包含其他复合类型的类型已经很普遍了。让我们深入一点,看看如何处理这样的嵌套结构。
首先,假设我们要在单独的复合数据类型中将与票价相关的字段分开:
```julia
struct TripPayment
	vendor_id::String
	tpep_pickup_datetime::String
	tpep_dropoff_datetime::String
	passenger_count::Int
	trip_distance::Float64
	fare::Fare
end

struct Fare
	fare_amount::Float64
	extra::Float64
	mta_tax::Float64
	tip_amount::Float64
	tolls_amount::Float64
	improvement_surcharge::Float64
	total_amount::Float64
end
```
调整函数
```julia
function read_trip_payment_file(file)
	f = CSV.File(file,skipto=2)
	records = Vector(TripPayment}(undef,length(f))
	for (i,row) in enumerate(f)
		records[i] = TripPayment(row.VendorID,
			row.tpep_pickup_datetime,
			row.tpep_dropoff_datetime,
			row.passenger_count,
			row.trip_distance,
			Fare(row.fare_amount,
				row.extra,
				row.mta_tax,
				row.tip_amount,
				row.tolls_amount,
				row.improvement_surcharge,
				row.total_amount
			))
	end
	return records
end
# 为了达到相同的结果,我们可以使用unwrap。
sa = StructArray(records,unwrap = t-> t <: Fare); # 根据类型unwrap
#= 关键字参数unwrap的值基本上是一个函数,该函数接受特定字段的数据类型。
如果函数返回true,则将使用嵌套的StructArray构造该特定字段。=#
sa.fare.fare_amount # 使用unwrap之后的访问
# now 100000-element Array{Float64,1} ...
```
**注意:**
尽管数组结构可以提高性能, 但为新数组分配内存会产生开销. 如果数据量很大,分配和数据复制操作也将花费一些时间。

## 6.4 共享数组模式
现代操作系统可以处理许多并发进程,并充分利用所有处理器核心。对于分布式计算,通常将较大的任务分解为较小的任务,以便多个进程可以同时执行任务。

当需要合并或汇总这些单独执行的结果以最终交付, 此过程称为还原。

这个概念以各种形式转世。例如,在函数式编程中,通常使用映射－化简来实现数据处理。映射过程获取一个列表并将一个函数应用于每个元素,而化简过程将结果合并。在大数据处理中,Hadoop使用一种类似的映射－化简形式,只不过它在集群中的多台机器上运行。DataFrames包包含执行Split-Apply-Combine模式的函数。这些都呈现几乎相同的概念。

有时,并行工作进程需要相互通信。通常,进程可以通过某种形式的进程间通信(IPC)传递数据来
相互通信。有很多方法可以执行此操作,如套接字、Unix域套接字、管道、命名管道、消息队列、共享内存和内存映射。

Julia附带了一个名为SharedArrays的标准库,该库与操作系统的共享内存和内存映射接口连接。此
功能允许Julia进程通过共享中央数据源相互通信。

### 6.4.2 准备示例数据
为了遵循此模式的后续代码,我们可以准备一些测试数据。在运行代码之前,请确保你有足够的磁盘空间用于测试数据。你将需要大约22GB的可用空间。与其将100000个文件放在一个目录中,不如将它们分成100个子目录。因此,我们首先创建目录。为此创建了一个简单的函数:
```julia
function make_data_directories()
	for i in 0:99
		mkdir(lpad("$i", 2, "0"))
	end
end
```

我们可以假设每个证券都由介于1到100000之间的数字索引值标识。让我们定义一个函数,该函数生成查找文件的路径：
```julia
function locate_file(index)
	id = index - 1
	dir = lpad(string(id % 100), 2, '0')
	joinpath(dir,"sec$(lpad(id, 5, '0')).dat")
end
# 该函数旨在将文件散列到100个子目录之一中。让我们看看它是如何工作的：
locate_file.(vcat(1:2, 99:102))
# 6-element Vector{String}:
 "00\\sec0.dat"
 "01\\sec1.dat"
 "98\\sec98.dat"
 "99\\sec99.dat"
 "00\\sec100.dat"
 "01\\sec101.dat"
function generate_test_data(nfiles)
	for i in 1:nfiles
		A=rand(10000,3) # 10000 * 3
		file=locate_file(i)
		open(file,"w") do io
			write(io,A)
		end
	end
end

folder =joinpath(ENV["HOME"],"julia_book_ch06_data")
"/home/ubuntu/julia_book_ch06_data"
cd(folder)
make_data_directories()
generate_test_data(100_000)
```

```bash
ls -l 0 | tail -6
-rw-r--r-- 1 Administrator 197121 240000 Nov 27 17:07 sec99499.dat
-rw-r--r-- 1 Administrator 197121 240000 Nov 27 17:07 sec99599.dat
-rw-r--r-- 1 Administrator 197121 240000 Nov 27 17:07 sec99699.dat
-rw-r--r-- 1 Administrator 197121 240000 Nov 27 17:07 sec99799.dat
-rw-r--r-- 1 Administrator 197121 240000 Nov 27 17:07 sec99899.dat
-rw-r--r-- 1 Administrator 197121 240000 Nov 27 17:07 sec99999.dat
```

### 6.4.4 开启16进程
```julia
using Distributed
using SharedArrays
# 检查所有进程工作目录
@everywhere println(pwd())
# @everywhere cd($dir)

#= load_data!函数读取所有100000个文件并将数据铲入评估矩阵。=#
function load_data!(nfiles,dest)
	# @distributed宏将for循环的主体发送给辅助进程(通常,此处的主程序不等待工作进程返回)
	# 但是! @sync宏会阻塞,直到所有作业都完全完成.
	@sync @distributed for i in 1:nfiles
		read_val_file!(i,dest)
	end
end

# @everywhere宏来确保该locate_file函数已定义并且可用于所有辅助进程 
@everywhere function locate_file(index)
	id = index - 1
	dir = lpad(string(id % 100), 2, '0')
	joinpath(dir,"sec$(lpad(id, 5, '0')).dat")
end
@everywhere function read_val_file!(index,dest)
	# 如何读取二进制文件 Read data file into a segment of the shared array `dest`
	filename = locate_file(index)
	(nstates,nattrs) = size(dest)[1:2]
	open(filename) do io
		nbytes = nstates * nattrs * 8
		buffer = read(io, nbytes) # nbytes-element Vector{UInt8} ie.字节缓冲数组 
		A = reinterpret(Float64, buffer) # reinterpret函数将数据解析为Float64值的数组
		dest[:, :, index] = A # 有30000个Float64值, 代表10000种未来状态和3个收益源
	end
end
# 主程序如下所示:
nfiles = 100_000
nstates = 10_000
nattr=3
valuation = SharedArray{Float64}(nstates,nattr,nfiles); # 三维数组 3维共享数组
# 10000×3×100000 SharedArray{Float64, 3}
@time load_data!(nfiles,valuation); # 13secs
```

6.4.5直接在共享数组上分析数据使用共享数组可以使我们对单个存储空间中的数据执行并行操作。只要我们不对数据进行变异,那么这些操作就可以独立运行而不会发生冲突。这种类型的问题称为“过易并行问题”([Embarrassingly Parallel])。
> - [并行计算](https://zh.wikipedia.org/wiki/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97 "并行计算")中,**过易并行**(embarrassingly parallel,也称作embarrassingly parallelizable、完美并行perfectly parallel、delightfully parallel、pleasingly parallel)是指(几乎)不需要努力就能拆分成若干并行任务的问题。并行任务之间的通信或结果的相互依赖(几乎)为零。
> - 这些问题与[分布式计算](https://zh.wikipedia.org/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97 "分布式计算")问题不同,后者需要任务间的通信,尤其是中间结果的通信。
> - 过易并行问题更容易在缺乏[超级计算机](https://zh.wikipedia.org/wiki/%E8%B6%85%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA "超级计算机")集群所需的特殊设施的[服务器集群](https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9B%86%E7%BE%A4 "服务器集群")执行,非常适合基于互联网的[志愿计算](https://zh.wikipedia.org/wiki/%E5%BF%97%E6%84%BF%E8%AE%A1%E7%AE%97 "志愿计算")平台,如[BOINC](https://zh.wikipedia.org/wiki/BOINC "BOINC")等,且受[并行减速](https://zh.wikipedia.org/wiki/%E5%B9%B6%E8%A1%8C%E5%87%8F%E9%80%9F "并行减速")影响较小。
> - 同**过易并行**相反的是本质上无法并行化的**连贯串行**问题。
> - 过易并行问题的常见例子如[GPU](https://zh.wikipedia.org/wiki/GPU "GPU")处理的3D视频渲染,每帧(前向法)或像素([光线追踪](https://zh.wikipedia.org/wiki/%E5%85%89%E7%B7%9A%E8%BF%BD%E8%B9%A4 "光线追踪")法)都可单独处理,没有任何相互依赖关系。某些形式的[密码破解](https://zh.wikipedia.org/w/index.php?title=%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3&action=edit&redlink=1 "密码破解(页面不存在)")也过易并行的,很容易分布在[CPU](https://zh.wikipedia.org/wiki/CPU "CPU")、[多核处理器](https://zh.wikipedia.org/wiki/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8 "多核处理器")或集群中。
> - Many may wonder the etymology of the term “embarrassingly”. In this case, embarrassingly has nothing to do with embarrassment; in fact, it means an overabundance—here referring to parallelization problems which are “**embarrassingly easy**”.

为了说明多重处理的强大,我们首先对一个简单的函数进行基准测试,该函数计算所有证券的收益的标准差:
```julia
using Statistics: std
# Find standard deviation of each attribute for each security
function std_by_security(valuation)
	# n的值表示证券数量。nattr的值表示收益来源的数量。nstates 表示某券某源的历史数据
	(nstates,nattr,n) = size(valuation) # n 证券数量 100,000
	result = zeros(n,nattr) # nattr 来源 3个 
	for i in 1:n
		for j in 1:nattr
			result[i, j] = std(valuation[:, j, i]) # i 证券 j 来源的方差
		end
	end
	return result
end
```

让我们看看一个过程
需要花费多少时间。最佳时间是5.286秒。和可用内存正相关
```julia
@time std_by_security(valuation);
52.748028 seconds (903.86 k allocations: 22.372 GiB, 3.45% gc time, 0.07% compilation)
6.853532 seconds (900.00 k allocations: 22.372 GiB, 12.85% gc time)

```
### 使用 BenchmarkTools

```julia
using BenchmarkTools
@benchmark std_by_security($valuation) seconds=30

BenchmarkTools.Trial: 7 samples with 1 evaluation.
 Range (min … max):  4.804 s …   5.020 s  ┊ GC (min … max): 13.59% … 14.85%
 Time  (median):     4.907 s              ┊ GC (median):    13.68%
 Time  (mean ± σ):   4.895 s ± 74.841 ms  ┊ GC (mean ± σ):  13.85% ±  0.46%

  █  █          █          ██      █                  █
  █▁▁█▁▁▁▁▁▁▁▁▁▁█▁▁▁▁▁▁▁▁▁▁██▁▁▁▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█▁
  4.8 s          Histogram: frequency by time        5.02 s<

 Memory estimate: 22.37 GiB, allocs estimate: 900003.
```
分布式版本
```julia
# Distribution version
using BenchmarkTools;
@everywhere using Statistics:std


function std_by_security2(valuation)
    (nstates, nattr, n) = size(valuation)
    result = SharedArray{Float64}(n, nattr)
    @sync @distributed for i in 1:n
        for j in 1:nattr
            result[i, j] = std(valuation[:, j, i])
        end
    end
    return result
end

@benchmark std_by_security2($valuation) seconds=30
BenchmarkTools.Trial: 11 samples with 1 evaluation.
 Range (min … max):  2.809 s …  2.842 s  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     2.819 s             ┊ GC (median):    0.00%
 Time  (mean ± σ):   2.821 s ± 9.350 ms  ┊ GC (mean ± σ):  0.00% ± 0.00%

  █  █        ██  ██ █   █         █  █                  █
  █▁▁█▁▁▁▁▁▁▁▁██▁▁██▁█▁▁▁█▁▁▁▁▁▁▁▁▁█▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁
  2.81 s        Histogram: frequency by time        2.84 s <

 Memory estimate: 128.90 KiB, allocs estimate: 2119.
```


### 更高难度的任务
```julia
using Statistics: std, mean, median
import Pkg; Pkg.add("StatsBase");
using StatsBase: skewness, kurtosis

function stats_by_security(valuation,funcs)
	(nstates,nattr,n) = size(valuation)
	result= zeros(n, nattr,length(funcs)) # 证券, 来源, 分析 三维分析
	for i in 1:n # i of 证券 100,000
		for j in 1:nattr # j of 来源 3
			for (k,f) in enumerate(funcs) # f
				result[i,j,k]=f(valuation[:, j, i])
			end
		end
	end
	return result
end

funcs =(std,skewness,kurtosis); # 方差, 偏度(>0偏右), 峰度
@time result = stats_by_security(valuation,funcs);
# 21.099982 seconds (3.60 M allocations:67.156 GiB,3.27% gc time)
#! 15.216919 seconds (2.16 M allocations: 53.692 GiB, 13.49% gc time)
```
$$ 偏度 (Skewness) = {\displaystyle \gamma _{1} (三阶标准矩)=\operatorname {E} {\Big [}{\big (}{\tfrac {X-\mu }{\sigma }}{\big )}^{\!3}\,{\Big ]}={\frac {\mu _{3}}{\sigma ^{3}}}={\frac {\operatorname {E} {\big [}(X-\mu )^{3}{\big ]}}{\ \ \ (\operatorname {E} {\big [}(X-\mu )^{2}{\big ]})^{3/2}}}={\frac {\kappa _{3}}{\kappa _{2}^{3/2}}}\ ,}$$
$$峰度(Kurtosis) = {\displaystyle \gamma _{2}={\frac {\kappa _{4}}{\kappa _{2}^{2}}}={\frac {\mu _{4} 四阶中心矩}{\sigma ^{4} 四阶标准差}} [四阶标准矩]-3}$$
[偏度(歪度)](https://zh.wikipedia.org/wiki/%E5%81%8F%E5%BA%A6)
[峰度(尖度)](https://zh.wikipedia.org/wiki/%E5%B3%B0%E5%BA%A6)
并行版本
```julia
@everywhere using Statistics: std,mean,median
@everywhere using StatsBase: skewness,kurtosis
function stats_by_security2(valuation,funcs)
	(nstates,nattr,n) = size(valuation)
	result = SharedArray{Float64}((n,nattr,length(funcs)))
	@sync @distributed for i in 1:n
		for j in 1:nattr
			for (k,f) in enumerate(funcs)
				result[i,j,k]=f(valuation[:,j,i])
			end
		end
	end
	return result
end
funcs =(std,skewness,kurtosis);
@time result = stats_by_security2(valuation,funcs);
# 2.329082 seconds (5.06 k allocations:242.359 KiB)
#!  5.798433 seconds (4.51 k allocations: 278.938 KiB)
```
### 6.4.7 配置共享内存使用情况
SharedArrays的魅力来自操作系统中对内存映射和共享内存工具的使用。当处理大量数据时,我们可能需要配置系统以处理该卷。
#### 调整系统内核参数
Linux操作系统对共享内存的大小有限制。为了找出是什么限
制,我们可以使用ipcs命令。
其他略...
### 6.4.8确保工作进程可以访问代码和数据
开发并行计算时,初学者经常会遇到以下问题
- 工作进程中未定义的**函数**：这可能是没有加载库包的症状,或者是仅在当前进程中定义但在工作进程中未定义。这两个问题都可以通过使用@everywhere宏来解决,如前面的示例所示。
- 工作进程中不可用的**数据**：这可能是数据在当前进程中存储为变量但没有传递给工作进程的征兆。SharedArray使用方便,因为它可以自动供工作进程使用。
  对于其他情况,开发人员通常有两个选择：
	- 通过函数**参数显式传递**数据。
	- 如果数据在**全局变量**中,则可以使用@everywhere宏进行传递,如下所示：
	```julia
	@everywhere my_global_var = whatever_value
	```
- 对于更高级的用例`ParallelDataTransfer.jl`包提供了一些有用的函数来促进主进程和工作进程之间的数据传输。

### 6.4.9  避免并行进程之间的竞态
SharedArray提供了跨多个进程共享数据的方便渠道。同时,SharedArray在设计上是所有工作进程中的全局变量。作为每个并行程序的一般经验法则,对数组进行更改时应格外小心。如果相同的内存地址需要由多个进程写入,则这些操作必须同步,否则程序很容易崩溃。最好的选择是尽可能避免更改。
另一种可选的方法是为每个工作线程分配一组互斥的槽`slot`, 以免它们相互冲突。

### 6.4.10 使用共享数组的约束
#位类型 #原始类型
SharedArray中的元素必须是位类型。这是什么意思?位类型的形式定义可以概括如下：
- 类型是不可变的。
- 该类型仅包含原始类型或其他位类型。
下面的OrderItem类型是位类型,因为所有字段都是原始类型：
```julia
struct OrderItem
	order_id::Int
	item_id::Int
	price::Float64
	quantity::Int
end
```

以下Customer类型不是位类型,因为它包含对String的引用-既不是原始类型也不是位类型：
```julia
struct Customer
	name::String
	...
end
```

**可变结构类型** 也不是位类型

否则`ERROR: ArgumentError: type of SharedArray elements must be bits types,got MutablePoint{Float64}`
## 6.5 记忆模式
### 斐波那契数列
首先,让我们通过修改函数以跟踪执行次数来分析性能有多差。代码如下：
```julia
function fib(n)
	if n<3
	return (result=1, counter=1)
	else
		result1, counter1=fib(n-1)
		result2, counter2=fib(n-2)
		return (result=result1+result2, counter=1+counter1+counter2)
	end
end
```
cache
```julia
const fib_cache = Dict()
_fib(n)= n<3 ? 1 : fib(n-1) + fib(n-2)

function fib(n)
	if haskey(fib_cache,n)
		return fib_cache[n]
	else
		value=_fib(n)
		fib_cache[n]=value
		return value
	end
end
@btime fib(40); # 15ns

const fib_cache1 = zeros(Int, 100) # Pre-allocate for a reasonable range 
function fiba(n) 
	if n < 3 
		return 1
	elseif fib_cache1[n] != 0
		return fib_cache1[n] 
	else 
		fib_cache1[n] = fib(n - 1) + fib(n - 2) 
		return fib_cache1[n]
	end
end
@btime fiba(40); # 4ns # 使用临时变量会增加负担10ns 但比字典版好.动态尺寸会变慢100ns

# 闭包版本
function memoize(f)
	memo=Dict()
	(args...; kwargs...)->begin
		x = (args, kwargs)  # x = hash_all_args(args,kwargs)
		if haskey(memo,x)
			return memo[x] # 使用tuple 作为 key
		else
			value = f(args...; kwargs...)
			memo[x] = value
			return value
		end
	end
end
fibm = memoize(_fib)
fibm=n->begin println("called with $n"); n<3 ? 1 : fibm(n-1)+fibm(n-2) end
fibm = memoize(fibm) # 注意这里应使用覆盖, 否则递归调用性能提升非常有限
end
@btime fibm(40); # 29ns 闭包版本比外置缓存略慢
using Memoize;
@memoize fibm(n) = n<3 ? 1 : fibm(n-1) + fibm(n-2)
```


### 6.5.4理解泛型函数的约束
上述方法的一个缺点是我们必须将原始函数定义为匿名函数而不是泛型函数。这似乎是一个主要限制。问题是为什么它不能与泛型函数一起使用?
让我们通过启动一个新的Julia REPL,再次定义原始的fib函数,并使用相同的memoize函数包装它来进行快速测试。
```julia
fib(n)= n<3 ? 1 : fib(n-1) + fib(n-2);
fib = memoize(fib) ERROR: invalid redefinition of constant fib
```

问题在于,fib已被定义为泛型函数,无法将其绑定到新的匿名函数,这个匿名函数是从memoize函数返回的内容。要变通解决此问题,我们可能会想为该memoize函数分配一个新名称`fib_fast=memoize(fib)`
但是,它并不会起作用,因为原始的fib函数对自身进行了递归调用,而不是对新的记忆版本进行了递归调用。


### 6.5.6 处理参数中的可变数据类型
到目前为止,我们对传递给函数的参数或关键字参数的关注并不多。当这些参数中的任何一个是可变的时,必须小心。为什么?因为我们当前的实现使用参数作为字典缓存的键。如果我们更改字典的键,则可能导致意外的结果。
假设我们有一个需要2秒钟才能运行的函数：
```julia
x = [1,-2,3,-4,5]
slow_sum_abs =(x::AbstractVector{T} where {T <:Real}) -> begin
	sleep(2)
	sum(abs(v) for v in x)
end
sum_abs= memoize(slow_sum_abs);
@time sum_abs(x)
```

知道它很慢,我们像往常一样记住它：`sum_abs=memoize(slow_sum_abs)`
最初,它似乎一直很完美. 但是,我们对以下观察感到震惊。
#似乎是一个版本BUG 实测并没有什么问题
```julia
push!(x,-6) # 15 after 0.000000
```
它没有返回值21,而是返回前一个结果15,就好像没有将-6插入到数组中一样。出于好奇,让我们将另一个值推入数组,然后重试。
```julia
push!(x,7)
@time sum_abs(x) # 28 after 2
```
它再次正常工作。为什么会这样呢?为了理解这一点,让我们回顾一下memoize函数的编写方式:

自定义hash函数
```julia
function hash_all_args(args,kwargs)
	h = 0xed98007bd4471dc2 # rand(UInt64) hash seed
	h+= hash(args,h)
	h+= hash(kwargs,h)
	return h
end
```
mutation memoize 测试
```julia
for i in 6:10
	push!(x,i*(iseven(i) ? -1 : 1))
	ts = @elapsed val = sum_abs(x)
	println(i,":", x, "->", val, " (", round(ts, digits=1),"s)")
	ts = @elapsed val = sum_abs(x)
	println(i,":", x, "->" ,val, " (", round(ts, digits=1),"s)")
end

6:[1, -2, 3, -4, 5, -6, -7, -8, -9, 10, -6]->61 (2.0s)
6:[1, -2, 3, -4, 5, -6, -7, -8, -9, 10, -6]->61 (0.0s)
7:[1, -2, 3, -4, 5, -6, -7, -8, -9, 10, -6, 7]->68 (2.0s)
7:[1, -2, 3, -4, 5, -6, -7, -8, -9, 10, -6, 7]->68 (0.0s)
8:[1, -2, 3, -4, 5, -6, -7, -8, -9, 10, -6, 7, -8]->76 (2.0s)
8:[1, -2, 3, -4, 5, -6, -7, -8, -9, 10, -6, 7, -8]->76 (0.0s)
9:[1, -2, 3, -4, 5, -6, -7, -8, -9, 10, -6, 7, -8, 9]->85 (2.0s)
9:[1, -2, 3, -4, 5, -6, -7, -8, -9, 10, -6, 7, -8, 9]->85 (0.0s)
10:[1, -2, 3, -4, 5, -6, -7, -8, -9, 10, -6, 7, -8, 9, -10]->95 (2.0s)
10:[1, -2, 3, -4, 5, -6, -7, -8, -9, 10, -6, 7, -8, 9, -10]->95 (0.0s)
```
使用宏
```julia
using Memoize
@memoize fibm(n) =n<3 ? 1 : fibm(n-1) + fibm(n-2);
@btime fibm.(1:40) # 16ns per
```

### 6.5.8现实生活中的例子
某些开源包中使用了记忆功能。在私有应用程序和数据分析中，实际用法可能更常见。在以下各节中，让我们看一些用于记忆的用例。
**Symata. jl**
Symata.jl包支持斐波那契多项式。正如我们已经意识到的那样，斐波那契多项式的实现也是递归的，就像我们在本节前面讨论的斐波那契数列问题一样。Symata.jl使用Memoize.jl包创建_fibpoly函数，如下所示：
```julia
fibpoly(n::Int)=_fib_poly(n)
using Symata
let myzero=0,myone=1,xvar=Polynomials.Poly([myzero,myone]),zerovar=Polynomials.Poly([myzero]),onevar=Polynomials.Poly([myone])
	global _fib_poly
	@memoize function _fib_poly(n::Int)
		if n==0
			return zerovar
		elseif n==1
			return onevar
		else
		return xvar * _fib_poly(n-1) + _fib_poly(n-2)
		end
	end
end
```

Omega. jl
Omega.jl包实现了自己的记忆缓存。有趣的是，它使用Core.Compiler.return_type函数从缓存查找中确保正确的返回类型。这样做是为了避免类型不稳定性问题。在本章后面的闸函数模式部分，我们将更多地讨论类型不稳定的问题以及如何处理该问题。查看以下代码示例：
```julia
@inline function memapl(rv::RandVar,mω::TaggedΩ)
	if dontcache(rv)
		ppapl(rv,proj(mω,rv))
	elseif haskey(mω.tags.cache, rv.id)
		mω.tags.cache[rv.id]::(Core.Compiler).return_type(rv,		typeof((mω.taggedω,)))
	else
		mω.tags.cache[rv.id]=ppapl(rv,proj(mω,rv))
	end
end
```

Caching.jl
```julia
file = "Chapter06/StructOfArraysPattern/yellow_tripdata_2018-12_100k.csv"
# "D:\\julias\\Hands-on-Design-Patterns-and-Best-Practices-with-Julia\\Chapter06\\StructOfArraysPattern\\yellow_tripdata_2018-12_100k.csv"
using Caching,CSV,DataFrames, BenchmarkTools
@cache function read_csv(filename::AbstractString)
	println("Reading file:",filename)
	df = @btime CSV.File($filename) |> DataFrame
	# 或者 @time df = CSV.File(filename) |> DataFrame
	# @btime df = CSV.File(filename) |> DataFrame # 有2个错误, df和filename	
	return df
end
read_csv(cache with θentries,θ in memory θ on disk)
```

## 6.6 闸函数模式
Julia被设计为一种动态语言，同时它还追求高性能。秘诀来自其先进的编译器。当函数中的变量类型已知时，编译器可以生成高度优化的代码。但是，当变量的类型不稳定时，编译器必须编译可与任何数据类型一起使用的更通用的代码。从某种意义上说，Julia是可以被谅解的一一即使为运行时性能付出了代价，它也永远不会失败。
是什么使变量的类型不稳定？这意味着在某些情况下变量可以是一种类型，而在其他情况下则可以是另一种类型。本节将讨论这样的类型不稳定性问题，它可能如何发生以及我们可以如何应对它。
闸函数是一种可用于解决由类型不稳定而导致的性能问题的模式。因此，让我们看看如何实现这一目标。


@code_warntype宏显示代码的中间表示(IR）。编译器了解该代码中每一行的流和数据类型后，便会生成一个IR。出于此处的目的，我们不需要了解屏幕上打印的所有内容，但可以注意与代码生成的数据类型相关的突出显示的文本。通常，当你看到红色文本时，它也将是一个危险信号。

```julia
ra(n) = isodd(n) ? rand(Int, n) : rand(Float64, n)
@code_warntype ra(2)

MethodInstance for ra(::Int64)
  from ra(n) @ Main REPL[106]:1
Arguments
  #self#::Core.Const(Main.ra)
  n::Int64
Body::Union{Vector{Float64}, Vector{Int64}}
1 ─ %1 = Main.isodd(n)::Bool
└──      goto #3 if not %1
2 ─ %3 = Main.rand(Main.Int, n)::Vector{Int64}
└──      return %3
3 ─ %5 = Main.rand(Main.Float64, n)::Vector{Float64}
└──      return %5

function double_sum_of_random_data(n) # 没有使用闸函数
	data=ra(n)
	total = 0
	for v in data
		total += v
	end
	return total
end
```
在这种情况下，编译器认为此函数的结果可以是Float64数组或Int64数组。因此，返回类型仅为`Union {Array {Float64,1}，Array {Int64,1}}`。

> 通常，来自@code_warntype输出的红色/黄色标记越多表示代码中类型不稳定性问题越多。该函数正是我们想要做的。但是，当将其用于其他函数的主体时，类型不稳定性问题会进一步影响运行时性能。我们可以使用闸函数来解决此问题。

### 6.6.3开发闸函数

闸函数(barrier function)是**用来界定区域边界性状的一种函数**。 又称障碍函数。 处理优化问题时，在极值点的搜索过程中，为保证搜索始终在可行域内，对企图从可行域内部穿越边界的点，在目标函数中加入障碍项，表示障碍项的函数即为闸函数。

闸函数是将一部分逻辑从现有函数重构为新的独立的函数。完成后，新函数所需的所有数据将**作为函数参数**传递。继续前面的示例，我们可以**分解**出计算数据加倍和的逻辑,如下所示:
```julia
function double_sum(data)
	total=0
	for v in data
		total += 2v
	end
	return total
end
```

然后，我们只需修改原始函数即可使用它：
```julia
function double_sum_of_random_data(n)
	data=ra(n)
	return double_sum(data)
end
```

更稳定的类型
```julia
function double_sum(data)
	total=zero(eltype(data))
	for vin data
		total+=2
	end
	return total
end
```
泛型
```julia
function double_sum(data::AbstractVector{T})) where {T<:Number}
	total=zero(T)
	for vin data
		total+=v
	end
	return total
end
```

### 6.6.5 使用@inferred宏
Julia在Test包中附带一个方便的宏，可用于检查函数的返回类型是否与推断的函数的返回类型匹配。推断的返回类型只是我们之前从@code_warntype输出中看到的类型。例如，我们可以在本节的开始检查臭名昭著的random_data函数。
```julia
@inferred random_data(1)

ERROR:return type Array{Int64,1} does not match inferred return type Union{Array{Float64,1},Array{Int64,1}}
Stacktrace:
[1] error(::String) at./error.jl:33
[2] top-level scope at REPL[31]:1

julia> @inferred random_data(2)

ERROR:return type Array(Float64,1} does not match inferred return type U
nion{Array{Float64,1},Array{Int64,1}]
Stacktrace:
[1]error(::String] at./error.jl:33
[2] top-level scope at REPL[32]:1
```

只要实际返回的类型与推断的返回类型不同，宏就会报告错误。作为持续集成管道中自动测试套件的一部分，它可能是验证类型不稳定性问题的有用工具。
使用闸函数的主要原因是在存在类型不稳定性问题的情况下提高性能。如果我们更深入地考虑它，它还具有迫使我们创建较小函数的附带好处。较小的函数更易于阅读和调试，并且性能更好。
