
## 子模块
通常有两种用于组织子模块文件的模式:
- 第一种模式涉及一种较简单的情况，其中每个子模块完全包含在一个源文件中，如下所示:
```julia
module MyPackage
	include("sub_module1.jl")
	include("sub_module2.j1")
	include("sub_module3.j1")
end
```

·第二种模式涉及较大的子模块，其中每个子模块可能有多个源文件。在这种情况下,子模块的源代码位于子目录中：
```julia
# MyPackage.j1
module MyPackage
	include("sub_module1/sub_module1.j1")
	include("sub_module2/sub_module2.j1")
	include("sub_module3.j1")
end
```

当然，子模块的目录可能包含多个文件。在前面的示例中，`sub_module1`可能包含多个
其他源文件，如以下代码段所示：
```julia
#sub_module1.j1
module SubModule1
	include("file1.jl")
	include("file2.jl")
	include("file3.j1")
end
```
接下来，我们将研究如何在模块和这些子模块之间引用符号和函数。
- 1. `Mortage.jl` 是一个简单独立的模块, 包含了payment`函数
- 2. `Caculator.jl` 包含了 `"Mortage.jl"` 并得到了**payment**(`using .Mortage payment`)
- 3. `Caculator.jl` 将原有的`interest, rate` 转入`funcs.jl` 并包括了后者
- 4. `funcs.jl` 没有包的概念, 但是可用使用 `payment`

规则(自写)
- 非模块的代码文件名小写. 该文件可能使用**未定义**的函数,但是在特定的上下文中可以使用.
- 子模块可用引用父模块中的对象(其位置应早于子模块引入点), 使用 `using ..Parent: earlier`
 
### 双向引用避免
- wrap: 在父模块中, 引入子模块之后, 再包一个函数, 既用了父模块对象, 又使用子模块的实现	
- split 将依赖的成员分离. 使得2个模块都依赖于分离模块


## 7.3关键字定义模式

你可以使用**默认构造函数**创建一个对象，该构造函数接受为该结构定义的每个字段的**位置参数**列表。对于较小的对象，这应该简单明了。对于较大的对象，这变得令人困惑，因为如果不引用结构的定义，那么每次我们编写代码来创建此类对象时，都很难记住哪个参数对应于哪个字段。
我们将讨论在开发Julia代码时如何减轻这种压力，以及如何使用@wdef宏来完成此工作，以便使代码易于阅读和维护。

### 7.3.1重温结构定义和构造函数
首先让我们看一下如何定义结构以及提供什么构造函数。考虑文本编辑应用程序中文本样式配置的用例。我们可以定义一个结构：
```julia
struct TextStyle
	font_family
	font_size
	font_weight
	foreground_color
	background_color
	alignment
	rotation
end
```
默认情况下，Julia为构造函数提供所有字段的位置参数，其顺序与结构中的定义顺序相同。因此，创建TextStyle对象的唯一方法是执行以下操作:
`style=TextStyle("Arial",11,"Bold","black",“white”,"left"，0)`
- 需要确保以正确的顺序指定所有参数
- 另一个问题是，我们可能希望某些字段具有默认值。
### 7.3.2 在构造函数中使用关键字参数
 默认构造函数没有提供任何简便的方法。创建具有这么多参数的对象的更合理的语法是在构造函数中使用关键字参数。
```julia
function TextStyle(;font_family,
	font_size,
	font_weight="Normal",
	foreground_color="black",
	background_color-"white",
	alignment="left",
	rotation=0)
return TextStyle(font_family,
	font_size,
	font_weight,
	foreground_color,
	background_color,
	alignment,
	rotation)
end
```

在这里，我们选择为除font_family和font_size之外的大多数字段提供默认值。它被简单地定义为向结构中所有字段提供关键字参数的函数。创建TextStyle对象要容易得多，并且代码现在更具可读性。实际上，我们获得了另一个好处，即可以按任何顺序指定参数，如下所示：
```julia
style=TextStyle(font_family="Arial",font_weight="Bold",font_size=11)
```

确实，这是一个非常简单的方法。我们可以为每个结构创建这种构造函数，从而解决问题，是吗？是，但也不是。尽管创建这些构造函数相当容易，但要为每个地方的每个结构都这样做很麻烦。
此外，构造函数定义必须在函数参数中指定所有字段名称，并且这些字段在函数主体中重复。因此，开发和维护变得相当困难。接下来，我们将介绍一个宏来简化代码。

### 7.3.3使用 #kwdef 宏简化代码
关键字定义模式解决了相当普遍的用例，Julia已经提供了一个宏来帮助定义结构以及接受关键字参数的构造函数。该宏当前未导出，但是你可以按如下方式直接使用它：
```julia
Base.@kwdef struct TextStyle
	font_family
	font_size
	font_weight="Normal"
	foreground_color-"black"
	background_color="white"
	alignment="center"
	rotation=0
end
```

基本上，我们可以将Base.@kwdef宏放在类型定义的前面。作为类型定义的一部分，我们还可以提供默认值。宏会自动使用关键字参数定义结构和相应的构造函数。通过使用下面的methods函数，我们可以看到如下的输出。
```julia
julia> methods(TextStyle)
# 2 methods for generic function "(::Type)":
[1] TextStyle(;font_family,font_size,font_weight, foreground_color...)
[2] TextStyle(font_family,font_size, font_weight,foreground_color...)
```

从输出中我们可以看到第一个方法是接受关键字参数的方法。第二种方法是需要位置参数的默认构造。现在，创建新对象非常方便。
我们应该注意，前面的定义没有为font_family和font_size指定任何默认值。因此,在创建TextStyle对象时，这些字段是必需的。使用@kwdef宏可以简化对象的构造，并使代码更具可读性。没有理由不在任何地方使用它。
**从Julia版本1.3开始，不会导出@kwdef宏。** 有一个特性要求将其导出。如果对使用不导出的特性感到不舒服，请考虑改用Parameters.jl包。

## 7.4 代码生成模式

### 7.4.1文件日志记录器用例介绍
让我们考虑一个构建文件日志记录工具的用例。假设我们要提供一个API，用于根据一组日志记录级别将消息记录到文件中。默认情况下，我们将支持三个级别：info、warning和error。提供一个日志记录器工具，以便将消息定向到文件，只要该消息具有足够高的日志记录级别即可。功能需求可以总结如下：
- info级别日志记录器接受具有info、warning或error级别的消息。
- warning级别日志记录器仅接受warning或error级别的消息。
- error级别日志记录器仅接受具有error级别的消息。

为了实现文件日志记录器，我们首先为三个日志记录级别定义一些常量：
```julia
const INFO=1
const WARNING=2
const ERROR=3
```

这些常量按数字顺序设计，因此我们可以轻松确定消息何时具有与日志记录器可以接受的日志记录级别一样高的日志记录级别。接下来，我们定义Logger工具如下:
```julia
struct Logger
	filename #log file name
	level #minimum level acceptable to be logged
	handle #file handle
end
Logger(filename,level) = Logger(filename,level,open(filename,"w"))
```

Logger对象包含日志文件的文件名、日志记录器可以接受的最低消息级别以及用于保存数据的文件句柄。我们可以为Logger提供如下构造函数:
`Logger(filename,level) = Logger(filename,level,open(filename,"w"))`
构造函数自动打开指定的文件进行写入。现在，我们可以为info级别消息开发第一个日志记录函数：
```julia
using Dates

function info!(logger::Logger, args...)
	if logger.level <= INFO
		let io=logger.handle
		print(io,trunc(now(), Dates.Second), " [INFO] ")
		for (idx, arg) in enumerate(args)
			idx > 0 && print(io, " ")
			print(io,arg)
		end
		println(io)
		flush(io)
		end
	end
end
```

此函数旨在仅在INFO级别足够高以被日志记录器接受时，才将消息写入文件。它还使用now函数和日志文件中的［INFO]标签打印当前时间。然后，它写入所有由空格分隔的参数，最后刷新I/0缓冲区。现在我们可以快速测试代码。首先，我们将使用info_logger。
```julia
logger = Logger("tmp_info.log", INFO)
info!(logger, "hello", 123)
readlines(logger.filename)
```

以同样的方式编写error!, warn!, debug!, critical!函数来完成项目。

### 7.4.2 函数定义的代码生成
如上一节所述，代码生成是解决编写重复代码问题的一种方法。我们要做的是建立定义函数的语法，然后将其放入循环中以定义所有三个日志记录函数。代码如下所示：
```julia
for level in (:info,:warning,:error)
	lower_level_str = String(level) # 函数名
	upper_level_str = uppercase(lower_level_str) # 大写名
	upper_level_sym = Symbol(upper_level_str) # 常量符号
	fn = Symbol(lower_level_str * "!") # 函数名称
	label = " [" * upper_level_str * "] "
	@eval function $fn(logger::Logger, args...)
		if logger.level <= $upper_level_sym
			let io = logger.handle
				print(io,trunc(now(), Dates.Second), $label)
				for (idx, arg) in enumerate(args)
					idx>0 && print(io," ")
					print(io,arg)
				end
				println(io)
				flush(io)
			end
		end
	end
end
```

上述代码的解释如下：
- 由于我们需要为三个日志记录级别定义函数，遍历了一系列符号：:info、:warning和:error。
- 在循环内部，我们可以看到函数名称为fn，标签为label，以及用于日志级别比较(例如INFO、WARNING或ERROR)的常量为upper_level_sym。
- 我们使用@eval宏来定义日志记录函数，其中将fn变量、label和upper_level_sym插入函数主体。

在Julia REPL中运行代码后，所有三个函数(info!、warning!和error!)应该已经完成定义。为了进行测试，我们可以使用三种不同的日志记录器来调用它们。让我们先尝试info_logger。
```julia
julia> info_logger =Logger("/tmp/info.log",INFO);
julia> info!(info_logger,"hello", 123);
julia> warning!(info_logger,"hello", 456);
julia> error!(info_logger,"hello", 789);
julia> readlines("/tmp/info.log")
# 3-element ArrayfString,1}:
"2019-11-18T15:37:37 [INF0] hello 123"
"2019-11-18T15:37:40 [WARNING] heLlo 456"
"2019-11-18T15:37:43 [ERROR] heLlo 789
```

正如预期的那样，所有消息都记录到文件中，因为info_logger可以接收任何级别

### 7.4.3调试代码生成
由于代码是在后台生成的，当看不到生成的代码是什么样时，你可能会感到有些惶恐。我们如何保证在所有这些变量插值之后生成的代码正是我们期望的结果？
幸运的是，有一个名为CodeTracking的包可以使调试代码的生成更加容易。我们将在这里看到它的工作方式。
在上一节中，我们应该已经生成了三个函数：info!、warning!和error!。由于这些被定义为泛型函数，因此我们可以检查为每个函数定义了哪些方法。让我们以error!函数为例。
```JULIA
methods(error!)
#1 method for generic function "error!":
[1] error!(logger::Logger, args...) in Main at REPL[14]:10
```

在这种情况下，我们只有一个方法。我们可以使用first函数来获取方法对象本身。
```julia
julia> methods(error!) |> first
error!(logger::Logger, args...) in Main at REPL[14]:10
```

一旦有了对方法对象的引用，我们就可以依靠CodeTracking来揭示所生成函数的源代码。特别是，我们可以使用definition函数，该函数接受一个方法对象并返回一个表达式对象。为了使用此函数，我们还需要加载Revise包。让我们尝试以下方法。
```julia
julia> using Revise, CodeTracking
julia> methods(error!) |> first |> definition # 省略掉meta
:(function warning!(logger::Logger, args...)      
      if logger.level <= WARNING
          let io = logger.handle
              print(io, trunc(now(), Dates.Second), " [WARNING] ")
              for (idx, arg) = enumerate(args)
                  idx > 0 && print(io, " ")
                  print(io, arg)
              end
              println(io)
              flush(io)
          end
      end
  end)
```

在这里，我们可以清楚地看到变量已正确插值，logger.level变量与ERROR常量进比较，并且日志记录标签正确包含[ERROR]字符串。
我们还可以看到输出中包含了行号。由于我们从REPL定义了函数，因此行号的用处不大。如果我们从存储在文件中的模块生成函数，则文件名和行号信息将更加有用。不过，这里的行号节点似乎过于分散注意力。我们可以使用MacroTools包中的rmlines函数轻松删除它们。
```julia
julia> using MacroTools
julia> MacroTools.postwalk(rmlines,definition(first(methods(error!))))

julia> defi(method) = MacroTools.postwalk(rmlines, definition(method))
julia> defi(first(methods(warning!)))
:(function warning!(logger::Logger, args...)
	if logger.level <= WARNING
		let io = logger.handle
			print(io, trunc(nowC), Dates.Second), " [WARNING] ")
			for (idx, arg) = enumerate(args)
				idx > θ && print(io， " ")
				print(io, arg)
			end
			println(io)
			flush(io)
		end
	end
end)
# 输出open的第一个源代码实现
methods(open) |> first |> defi
```


### 7.4.4考虑代码生成以外的选项
在7.4节中，我们一直专注于代码生成技术。前提是我们可以轻松添加一个新函数，该函数与现有函数一样工作，但有所不同。实际上，代码生成并不是我们手头唯一的选项。让我们以相同的示例继续讨论。之前我们是想在给info!函数定义逻辑之后添加warning!和error!函数。如果我们退后一步，我们可以泛化info!函数并使其处理不同的日志记录级别。可以按以下步骤完成：
```julia
function logme!(level, label,logger::Logger,args...)
	if logger.level <=level
		let io = logger.handle
			print(io,trunc(now(),Dates.Second),label)
			for (idx,arg) in enumerate(args)
				idx>0 && print(io," ")
				print(io,arg)
			end
			println(io)
			flush(io)
		end
	end
end
```

logme!函数看起来与之前的info!函数很像，除了需要额外的两个参数：level和label。这些变量在函数主体中获取和使用。现在，我们可以定义所有三个日志记录函数，如下所示：
```julia
info!(logger::Logger,msg...)=logme!(INFO,"[INFO]", logger,msg...)
warning!(logger::Logger,msg...)=logme!(WARNING,"[WARNING]", logger, msg...)
error!(logger::Logger,msg...)=logme!(ERROR,"[ERROR]",logger, msg...)
```

我们已经使用常规的结构化编程技术解决了原始问题，并且将重复代码减至最少。在这种情况下，这些函数之间的唯一变化是简单的类型：常量和字符串。在另一种情况下，我们可能需要在主体内调用不同的函数。这也是可以的，因为函数在Julia中是第一类实体，因此我们可以传递函数的引用。我们可以做得更好吗？当然可以。使用闭包技术可以使代码更加简化。为了说明这个
概念，让我们定义一个新的make_log_func函数，如下所示:
```julia
function make_log_func(level,label)
	(logger::Logger,args...) -> begin # 返回闭包函数,匿名
		if logger.level <= level
			let io=logger.handle
				print(io,trunc(now(),Dates.Second)," [", label, "] ")
				for (idx,arg)in enumerate(args)
					idx>0 && print(io, " ")
					print(io,arg)
				end
				println(io)
				flush(io)
			end
		end
	end
end
```

这个函数采用level和label参数，并返回包含主要日志记录逻辑的匿名函数。level和label参数在闭包中捕获，并在匿名函数中使用。因此，我们现在可以更轻松地定义日志记录函数，如下所示：
```julia
info!=make_log_func(INFO, "INFO")
warning!=make_log_func(WARNING, "WARNING")
error!=make_log_func(ERROR, "ERROR")
```

因此，这里定义了三个匿名函数：info!、warning!和error!。它们都一样出色。
> 用计算机科学的术语来说，闭包是从封闭环境中捕获变量的第一类实体函数。从技术上讲，结构化编程解决方案和闭包之间存在不小的差异: 
> - 泛型函数被称为**模块内可以扩展**的函数。
> - 相反，匿名函数是唯一的,**不能扩展**。

## 7.5 DSL 领域特定语言模式
Julia是一种通用的编程语言，可以有效地解决任何领域的问题。然而，Julia还是少数几种允许开发人员构建新语法以适合特定领域用法的编程语言之一。因此，DSL是结构化查询语言(SQL)的一个例子。SQL旨在处理二维表结构中的数据。它非常强大，但是仅在需要处理表中的数据时才适用。
在Julia生态系统中，有一些突出的区域广泛使用DSL。最杰出的一个是Differential-Equations包，它使你能够以非常接近其原始数学符号的形式编写微分方程。例如，考虑如下的洛伦茨系统方程：
$${\displaystyle {\begin{aligned}{\frac {\mathrm {d} x}{\mathrm {d} t}}&=\sigma (y-x),\\[6pt]{\frac {\mathrm {d} y}{\mathrm {d} t}}&=x(\rho -z)-y,\\[6pt]{\frac {\mathrm {d} z}{\mathrm {d} t}}&=xy-\beta z.\end{aligned}}}$$

定义这些方程的代码可以编写如下：
```julia
@ode_def begin
dx = σ * (y - x)
dy = x * (ρ - z) - y
dz = x * y - β * z
end σ ρ β
```

如上所示，语法几乎与数学方程式匹配。
下一节我们将探讨如何为称为L系统的计算机图形中的实际用例构建自已的DSL。

### 7.5.1 L系统介绍
L系统(也称为Lindenmayer系统)是一种正式语法，用于描述生物如何通过简单模式进行进化。它是由匈牙利生物学家和植物学家Aristid Lindenmayer于1968年首次提出的。L系统可以生成模仿现实生活形状和形式的有趣模式。一个著名的例子是特定藻类的生长,可以按以下方式建模：

Lindenmayer研究海藻生长模式时提出的最早的L-系统：
>**变量** : A B
>**常量** : 无
>**公理**  : A (**公理；格言；自明之理**)
>**规则**  : (A → AB), (B → A)

迭代过程：
_n_ = 0 : A
_n_ = 1 : AB
_n_ = 2 : ABA
_n_ = 3 : ABAAB
_n_ = 4 : ABAABABA
_n_ = 5 : ABAABABAABAAB
_n_ = 6 : ABAABABAABAABABAABABA
_n_ = 7 : ABAABABAABAABABAABABAABAABABAABAAB

例1的解释

```
n=0:         A           开始 (公理/起始点)
            / \
n=1:       A   B         据规则(A→AB)起始点A拓展成AB;因起始点没有B,规则(B→A)没有被用到
          /|    \
n=2:     A B     A       AB中的A拓展成AB，B变成A，于是得到了ABA
        /| |     |\
n=3:   A B A     A B     可看每个A都是一个新子树的根，由此引发出和整体结构同构的子结构。
      /| | |\    |\ \
n=4: A B A A B   A B A   
```

如果我们观察这个序列的长度就会发现这是一个[斐波那契数列](https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97 "斐波那契数列") 1 2 3 5 8 13 21 34 55 89 ... 如果我们把A看成一只成年兔子，B看成未成年兔子，那么这个构造和那个著名的**兔生兔**的构造是一致的。 即每个月B会成长成A，而A每个月又会生出一个B。

### 7.5.2 为L系统设计DSL
DSL的特征是源代码应看起来像领域概念的原始表示。在这种情况下，领域概念由公理和一组规则描述。使用藻类生长示例，它看起来应如下所示:
```
Axiom: A
	Rule: A->AB
	Rule: B->A
```

如果尝试用普通的Julia语言编写它们，则可能会得到如下代码:
```julia
model = LModel("A")
add_rule!(model, "A", "AB")
add_rule!(model, "B", "A")
```

这不是理想的。虽然代码既不长又不难读，但看起来不像L系统语法那么清晰。我们真正想要的是构建一个DSL，让我们指定模型，如下所示：
```julia
model=@lsys begin
	axiom: A
	rule: A → AB
	rule: B → A
end
```

这将是我们的DSL的目标语法。

### 7.5.3 重温L系统核心逻辑
作为此示例的一部分，我们将一起开发L系统包。在进入DSL实现之前，让我们快速绕道并了解核心逻辑是如何工作的。对API的了解使我们能够正确地设计和测试DSL。开发LModel对象要开发Model对象，请执行以下步骤：
1) 首先创建一个名为LModel的类型，以记录公理和规则集。该结构可以定义如下:
```julia
struct LModel
	axiom
	rules
end
```
2) 然后，我们可以添加一个构造函数，该构造函数填充公理字段并初始化规则字段:
```julia
"Create a L-system model."
LModel(axiom) = LModel([axiom], Dict())
```
3) 根据设计，公理是单个元素的数组。规则被捕获在字典中以便快速查找。一个add_rule!函数还被编写为向模型添加新规则:
```julia
"Add rule to a model."
function add_rule!(model::LModel,left::T,right::T) where (T<:AbstractString)
	model.rules[left]=split(right,"") # split函数将字符串转换为单字符字符串数组。
	return nothing
end
```

4) 最后，我们添加Base.show函数只是为了可以在终端上很好地显示模型：
```julia
"Display model nicely."
function Base.show(io::IO,model::LModel)
	println(io,"LModel:")
	println(io,"Axiom:", join(model.axiom))
	for k in sort(collect(keys(model.rules)))
		println(io,"Rule:", k, "→", join(model.rules[k]))
	end
end
```

定义了这些函数后，我们可以快速验证我们的代码，如下所示。
```julia
algae_model = LModel("A");
add_rule!(algae_model, "A", "AB");
```

接下来，我们将研究采用模型并跟踪迭代的当前状态的核心逻辑。开发状态对象为了模拟L系统模型的增长，我们可以开发一个LState类型来跟踪增长的当前状态。这是一种简单的类型，仅保留对模型、当前增长迭代和当前结果的引用。为此，请阅读以下代码：
```julia
struct LState
	model
	current_iteration
	result # 模型的当前结果. 第一次是公理
end
```

构造函数只需要将模型作为唯一参数。它将current_iteration默认为1，并将默认result为模型的公理，如下所示:
```julia
"Create a L-system state from a model'."
LState(model::LModel)=LState(model, 1, model.axiom) # 默认构造函数
# 我们需要一个函数来进入增长的下一阶段。因此，我们只提供next函数:
function next(state::LState)
	new_result=[]
	for el in state.result
	#Look up el from the rules dictionary and append to new_result
	# Just default to the element itself when it is not found
		next_elements = get(state.model.rules, el, el)
		append!(new_result, next_elements)
	end
	return LState(state.model, state.current_iteration + 1, new_result)
end
```

基本上，给定当前状态，它将迭代当前结果的所有元素，并使用模型中的规则扩展每个元素。get函数在字典中查找元素。如果找不到，则默认为自身。扩展的元素只是附加到new_results数组中。最后，使用下一个迭代编号和新结果创建一个新的LState对象。为了在终端中更好地显示，我们可以为LState添加Base.show方法，如下所示:
```julia
"Compact the result suitable for display"
result(state::LState) = join(state.result)
Base.show(io::IO,s::LState)=print(io,"LState(",s.current_iteration,"):",result(s))
```

result函数只是将数组的所有元素组合成一个字符串。show函数同时显示当前迭代编号和结果字符。
测试
```julia
state = LState(algae_model)
next(state)
```

### 7.5.4 实现L系统的DSL
回顾上一节，我们希望拥有用于定义L系统模型的简洁语法。从元编程的角度来看，我们只需要将代码从一棵抽象语法树转换到另一棵抽象语法树即可。图7-6显示了需要哪种转换。
```julia
algae_model = @lsys begin                struct LModel end
axiom: A                                 algae_model =LModel("A")
rule: A → AB                             add_rule!(algae_model,"A", "AB")
rule: B → A                              add_rule!(algae_model,"B", "A")
end
```

事实证明，转换非常简单。当遇到公理时，我们转换代码以构造一个新的LModel对象。
遇到规则时，我们会将代码转换为add_rule!函数调用。虽然看起来很容易，但是可以使用预先存在的工具极大地简化这种源到源的转换。特别是，MacroTools包包含一些非常有用的宏和函数来处理这些情况。首先让我们了解该工具，然后在开发DSL时可以利用它们。

使用@capture宏

MacroTools包提供了一个名为@capture的宏，可用于将表达式与模式进行匹配。作为匹配过程的一部分，它还会分配开发人员希望为其捕获匹配值的变量。@capture宏接受两个参数。第一个是需要匹配的表达式，第二个是用于匹配的模式。
考虑以下示例。
```julia
using MacroTools
@capture( :(x=1), x = val_)
true
val # 因为成功匹配了模式，所以还为val变量分配了值1。
1
```

可以匹配模式时，宏返回true，否则返回false。当模式匹配时，将在 **当前环境** 中**分配**以**下划线结尾的变量**，*并且下划线与变量名分开*。

匹配公理和规则语句

我们可以使用相同的技巧从axiom和rule语句中提取有用的信息。让我们对axiom语句进行快速实验，该语句由公理、冒号和符号组成。将其与`@capture`宏进行匹配，如下所示。

```julia
ex = :(axiom :A)
:(axiom:A) # range oper with :(:)
#= Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol :
    2: Symbol axiom
    3: Symbol A
=#
match_axiom = @capture(ex, axiom :sym_)
true
sym
:A
```

匹配rule语句同样容易。唯一的区别是我们要匹配原始符号和相应的替换符号，如下所示。
```julia
ex=:(rule : A→AB) # :(rule:A→AB)
@capture(ex,rule:original_ → replacement_) # true
original # :A
replacement # :AB
```

匹配后，将为original变量和replacement变量分配规则中的相应符号。我们还可以观察到匹配的变量是符号而不是字符串。由于LModel编程接口需要字符串，因此我们将不得不通过walk函数中的符号执行附加的数据转换，这将在"为DSL开发宏"中介绍。

使用postwalk函数

为了遍历整个抽象语法树，我们可以使用MacroTool的postwalk函数。为了理解它是如何工作的，我们可以使用一个简单的示例，如以下步骤所述:
1) 让我们创建一个表达式对象，如下所示。
```julia
ex = quote 
x=1
y=x^2+3
end |> rmlines # 在这里，我们使用rmlines函数删除行号节点，因为在本练习中我们不需要它们。

quote
x=1
y=x^2+3
end
```

2) 然后，我们可以使用postwalk函数遍历树并显示它遇到的所有内容。

postwalk函数接受一个函数作为其第一个参数，表达式作为第二个参数。当它遍历树时，它会调用带有被访问子表达式的函数。我们可以看到它考虑了每个单叶子节点, 以及表达式中的每个子树，例如：(x=1)。正如我们在输出的底部看到的那样，它还包括顶层表达式。

> 如果我们稍微注意遍历的顺序，就会发现postwalk函数从下至上，从叶节点开始工作。MacroTools还提供了遍历树的prewalk函数, prewalk 是从上到下

现在我们知道了如何匹配表达式并遍历树，我们在工具箱中拥有了开发DSL的所有功能。
为DSL开发宏为了支持LModel语法，我们必须将公理和规则语句与它们在模型中的编写方式进行匹
配。让我们开始创建lsys宏，如下所示:
```julia
macro lsys(ex)
	return MacroTools.postwalk(thewalk, ex) # 要保证返回是表达式, 且为model # TODO
end
```
该宏仅使用postwalk遍历抽象语法树。结果表达式按原样返回。实际上，主要的转换逻辑驻留在walk函数中，如下所示:

```julia
function thewalk(ex)
	match_axiom = @capture(ex, axiom :sym_)
	if match_axiom
		sym_str = String(sym)
		return :(model=LModel($sym_str))
	end
	match_rule = @capture(ex, rule: original_ → replacement_)
	if match_rule
		original_str = String(original)
		replacement_str = String(replacement)
		return :(add_rule!(model,$original_str,$replacement_str)) # 返回值需要eval
	end
	return ex
end
```


让我们一次剖析前面的代码。
`thewalk`函数使用`@capture`宏来匹配`axiom`和`rule`模式。匹配时，将相应的符号转换为字符串，然后内插到相应的表达式中，并返回最终表达式。考虑以下代码：
`match_axiom = @capture(ex,axiom :sym_)`
@capture宏调用尝试将表达式与axiom:sym_匹配，这是一个axiom符号，后跟一个冒号，然后是另一个符号。由于sym_目标符号以下划线结尾，因此如果匹配成功，将为sym变量分配匹配的值。在7.5.3节的藻类模型示例中，我们希望将sym分配给:A符号。匹配后，将执行以下代码：
```julia
if match_axiom
	sym_str = String(sym)
	return :(model=LModel($sym_str))
end
```

目标表达式只是构造一个LModel对象，并将其分配给model变量。使用藻类模型，我们可以期望转换后的表达式如下所示: 
`model = LModel("A")`
同样，可以使用以下模式来匹配rule语句:
`match_rule = @capture(ex,rule: original_ → replacement_)`
original变量和replacement变量已分配、转换为字符串，并插值到目标表达式中add_rule!语句中。

在lsys宏中，thewalk函数由postwalk函数多次调用(对抽象语法树的每个节点和子树调用一次)。要查看postwalk如何生成代码，我们可以在REPL中对其进行测试。

```julia
ex = quote
	axiom :A
	rule: A→AB
	rule: B→A
end;

MacroTools.postwalk(walk, ex) |> rmlines
quote
	model =LModeL("A")
	add_rule!(model, "A","AB")
	add_rule!(model,"B","A")
end

# 事实证明，我们还没有完全完成，因为转换后的语句位于quote块中，并且该块的返回值将来自该块的最后一个表达式，其结果为0。因为add_rule!函数不会返回任何有意义的值。最后的更改实际上是最简单的部分。让我们再次修改@lsys宏，如下所示:
macro lsys(ex)
	ex = MacroTools.postwalk(walk, ex)
	push!(ex.args, :(model))
	return ex
end
# push!函数用于在块的末尾添加:(model)表达式。
```

让我们测试宏扩展，看看它是什么样子。
```julia
@macroexpandc @lsys begin
axiom :A
rule: A → AB
rule: B → A
end |> rmlines

quote
#44#model = LSystem.LModel("A")
LSystem.add_rule!(#44#model,"A","AB")
LSystem.add_rule!(#44#model,"B","A")
#44#model
end
```
最后，我们可以如下使用宏。
```julia
algae_model = @lsys begin
axiom: A
rule: A→AB
rule: B→A
end

LModel:
	Axiom: A
	Rule:A → AB
	Rule:B → A
```

现在可以使用我们的小型DSL构建algae_model示例。事实证明，开发DSL一点也不困难。有了MacroTools等出色的工具，我们可以快速提出一套转换模式，并将抽象语法树处理成我们想要的任何东西。
DSL是简化代码并使其易于维护的好方法。它在特定领域中可能非常有用。