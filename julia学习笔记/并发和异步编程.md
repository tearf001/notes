
## [在 Channel 中进行通信](https://docs.julialang.org/en/v1/manual/asynchronous-programming/#Communicating-with-Channels)

在某些问题中，所需的各种工作并不是通过**函数调用**自然关联的； 在需要完成的工作中没有明显的“调用者”或“被调用者”。 一个典型的例子是**生产者-消费者**问题，其中一个复杂的过程正在生成值，而另一个复杂的过程正在消耗它们。消费者不能简单地调用生产者函数来获取一个值，因为生产者可能有更多的值要生成，因此可能还没有准备好返回。
对于任务，生产者和消费者都可以根据需要运行，根据需要来回传递值。

Julia 提供了 [`Channel`](https://docs.julialang.org/en/v1/base/parallel/#Base.Channel) 机制来解决这个问题。一个 **Channel** 是一个先进先出的队列，允许多个 `Task` 对它可以进行读和写。