# 宏

## meta
```julia
macro inline()   Expr(:meta, :inline)   end
macro noinline() Expr(:meta, :noinline) end
macro isdefined(s::Symbol)  Expr(:escape, Expr(:isdefined, s)) end

# 同步原语 base/task.jl @sync宏会阻塞，直到所有作业都完全完成.
macro sync(block)
    var = esc(sync_varname) # const sync_varname = gensym(:sync) # Symbol("##sync#246")
    quote
        let $var = Channel(Inf) # 给sync_varname(同步变量)赋予创建的频道
            v = $(esc(block))
            sync_end($var) # 发送到频道,等待同步结束
            v
        end
    end
end

# 同步结束, 接受隧道
function sync_end(c::Channel{Any}) # Channel 见 [[并发和异步编程]]
    local c_ex
    while isready(c)
        r = take!(c)
        if isa(r, Task)
            _wait(r) # just wait for a task to be done, no error propagation
            if istaskfailed(r)
                if !@isdefined(c_ex)
                    c_ex = CompositeException()
                end
                push!(c_ex, TaskFailedException(r))
            end
        else
            try
                wait(r)
            catch e
                if !@isdefined(c_ex)
                    c_ex = CompositeException()
                end
                push!(c_ex, e)
            end
        end
    end
    close(c)
    # Capture all waitable objects scheduled after the end of `@sync` and
    # include them in the exception. This way, the user can check what was
    # scheduled by examining at the exception object.
    if isready(c)
        local racy
        for r in c
            if !@isdefined(racy)
                racy = []
            end
            push!(racy, r)
        end
        if @isdefined(racy)
            if !@isdefined(c_ex)
                c_ex = CompositeException()
            end
            # Since this is a clear programming error, show this exception first:
            pushfirst!(c_ex, ScheduledAfterSyncException(racy))
        end
    end  

    if @isdefined(c_ex)
        throw(c_ex)
    end
    nothing
end

# base/timing.jl
macro time(ex) quote @time nothing $(esc(ex)) end end
macro time(msg, ex)
    quote
        local ret = @timed $(esc(ex))
        local _msg = $(esc(msg))
        time_print(stdout, ret.time*1e9, ret.gcstats.allocd, ret.gcstats.total_time, gc_alloc_count(ret.gcstats), ret.lock_conflicts, ret.compile_time*1e9, ret.recompile_time*1e9, true; msg=_msg)
        ret.value
    end
end
```
# 函数
## 内置
```julia
objectid(@nospecialize(x)) = ccall(:jl_object_id, UInt, (Any,), x)

fill(n::<:Number, x) # 产生数组
eachindex(listorlike) # Base.OneTo(length(listorlike))
axes(A) # (Base.OneTo(size(A)[0]), Base.OneTo(size(A)[1]), ...) # 轴range. 
ones(axes(A)); zeros(axes(A))
repeat(::String|Char, n) # for string
union(...literals) # 合并(去重)
	union(1: n, 2, 3: 5, 'a': 'C')	# 如果 l:r 不连续, 则这部分成为空集
all(itr) = all(identity, itr)

# 当我们需要创建一个与另一个数组的大小相同的零数组时，axes函数可能会派上用场。
zeros(axes(A))
3x4 Array{Float64,2}:
0.00.00.00.0
0.00.00.00.0
0.00.00.00.0

ntuple(i -> n, el_value) #[ev, ev, ...] # n 个
rand(::T, row, col, lay1, lay2) # rand(::T=Float64); [L]; [Mx,My]; [;;Lay]; ...

rand() = ccall(:jl_rand, UInt64, ()) % UInt32
rand(::Type{UInt32}) = rand()
rand(::Type{Float64}) = rand() * 2.0^-32
# 更多见 D:\julias\julia\stdlib\Random\src\Random.jl
# RNG random number generator
@inline default_rng() = TaskLocalRNG()
rand(X)                   = rand(default_rng(), X)
rand(::Type{X}) where {X} = rand(default_rng(), X)

eltype(::Type) = Any
eltype(::Type{Bottom}, slurp...) = throw(ArgumentError("Union{} have no elements"))

eltype(x) = eltype(typeof(x))
eltype(::Type{<:AbstractArray{E}}) where {E} = @isdefined(E) ? E : Any
eltype(::Type{<:AbstractSet{E}}) where {E} = @isdefined(E) ? E : Any 
# 字典
eltype(::PersistentDict{K,V}) where {K,V} = Pair{K,V}
eltype(::Type{<:AbstractDict{K,V}}) where {K,V} =
    @isdefined(K)  ? 
	    @isdefined(V) ? Pair{K,V} : Pair{K} : 
	    @isdefined(V) ? Pair{k,V} where k : Pair
# 自定义实现
el_type(::Type{Dict{K,V}}) where {K,V} =
    @isdefined(K)  ? 
	    @isdefined(V) ? Pair{K,V} : Pair{K} : 
	    @isdefined(V) ? Pair{k,V} where k : Pair
el_type(x::Dict{K,V}) where {K,V} = el_type(typeof(x))

nameof(m::Module) = ccall(:jl_module_name, Ref{Symbol}, (Any,), m)

unique(r::AbstractRange) = allunique(r) ? r : oftype(r, r[begin:begin])
function unique(f, C; seen::Union{Nothing,Set}=nothing) ...
# 测试
a = [3.1, 4.2, 5.3, 3.1, 3.1, 3.1, 4.2, 1.7];
# 求唯一元素的坐标(首次出现) eachindex(a) == 1:length(a) == keys(a) # true
unique(i -> a[i], keys(a)#=eachindex(a)=#) # 4-element Vector: 1 2 3 8 
# pick indexes from list
a[i] # 4-element Vector{Float64}: 3.1 4.2 5.3 1.7 
a[i] == unique(a) # true
```


## 内置函数的实现

```julia

# base/error.jl
error(s::AbstractString) = throw(ErrorException(s))
error(s::Vararg{Any,N}) = @noinline throw(ErrorException(Main.Base.string(s...)))

#similar
similar(a::Array{T,1}) where {T} = Vector{T}(undef, size(a,1))
similar(a::Array{T,2}) where {T} = Matrix{T}(undef, size(a,1), size(a,2))
similar(a::Array{T,1}, S::Type) where {T} = Vector{S}(undef, size(a,1))
similar(a::Array{T,2}, S::Type) where {T} = Matrix{S}(undef, size(a,1),size(a,2))
similar(a::Array{T}, m::Int) where {T} = Vector{T}(undef, m)
similar(a::Array, T::Type, dims::Dims{N}) where {N} = Array{T,N}(undef, dims)
similar(a::Array{T}, dims::Dims{N}) where {T,N} = Array{T,N}(undef, dims)

# base/io.jl
function open(f::Function, args...; kwargs...)
    io = open(args...; kwargs...)
    try
        f(io)
    finally
        close(io)
    end
end
```

# 第三方宏
```julia
# @btime packages\BenchmarkTools\QNsku\src\execution.jl
macro btime(args...)
    _, params = prunekwargs(args...)
    bench, trial, result = gensym(), gensym(), gensym()
    trialmin, trialallocs = gensym(), gensym()
    tune_phase = hasevals(params) ? :() : :($BenchmarkTools.tune!($bench))
    return esc(
        quote
            local $bench = $BenchmarkTools.@benchmarkable $(args...)
            $tune_phase
            local $trial, $result = $BenchmarkTools.run_result(
                $bench; warmup=$(hasevals(params))
            )
            local $trialmin = $BenchmarkTools.minimum($trial)
            local $trialallocs = $BenchmarkTools.allocs($trialmin)
            println(
                $BmTools.prettytime($BmTools.time($trialmin)),
                " (", $trialallocs," allocation",
                ": ", $BmTools.prettymemory($BmTools.memory($trialmin)),
                ")")
            $result
        end
    )
end
  
# memoize 大量引用 #MacroTools 
cache_name(f) = Symbol("##", f, "_memoized_cache")
macro memoize(args...)
    if length(args) == 1
        dicttype = :(IdDict)
        ex = args[1]
    elseif length(args) == 2
        (dicttype, ex) = args
    else
	    # 三种形式 f()=..; x->..; function f()
        error("Memoize accepts at most two arguments")
    end
    cache_dict = isexpr(dicttype, :call) ? dicttype : :(($dicttype)())
    def_dict = try        
        #= MacroTools\src\utils.jl 匹配任何函数定义
        return `Dict(:name=>..., :args=>..., etc.)`. 
        The definition can be rebuilt by call `MacroTools.combinedef(dict)`.=#
        splitdef(ex) 
    catch
        error("@memoize must be applied to a method definition")
    end  

    # a return type declaration of Any is a No-op because everything is <: Any
    rettype = get(def_dict, :rtype, Any) # splitdef(:(function b() ::Int 1 end))
    f = def_dict[:name]
    def_dict_unmemoized = copy(def_dict)
    def_dict_unmemoized[:name] = u = Symbol("##", f, "_unmemoized")  

    args = def_dict[:args]
    kws = def_dict[:kwargs]
    # Set up arguments for tuple
    tup = [splitarg(arg)[1] for arg in vcat(args, kws)] # for body
    # Set up identity arguments to pass to unmemoized function
    identargs = map(args) do arg	    	    
        arg_name, typ, slurp, default = splitarg(arg) #MarcoTools
        if slurp || namify(typ) === :Vararg
            Expr(:..., arg_name)
        else
            arg_name
        end
    end

    identkws = map(kws) do kw
        arg_name, typ, slurp, default = splitarg(kw)
        if slurp
            Expr(:..., arg_name)
        else
            Expr(:kw, arg_name, arg_name)
        end
    end
    fcachename = cache_name(f)
    mod = __module__
    fcache = isdefined(mod, fcachename) ?
             getfield(mod, fcachename) :
             Core.eval(mod, :(const $fcachename = $cache_dict))  

    body = quote
        get!($fcache, ($(tup...),)) do
            $u($(identargs...); $(identkws...))
        end
    end
    if length(kws) == 0
        def_dict[:body] = quote
            $(body)::Core.Compiler.return_type($u, typeof(($(identargs...),)))
        end
    else
        def_dict[:body] = body
    end
    esc(quote
        $(combinedef(def_dict_unmemoized))
        empty!($fcache)
        Base.@__doc__ $(combinedef(def_dict))
    end)
end
function memoize_cache(f::Function)
    # This will fail in certain circumstances (eg. @memoize Base.sin(::MyNumberType) = ...) but I don't think there's a clean answer here, because we can already have multiple caches for certain functions, if the methods are defined in different modules.
    getproperty(parentmodule(f), cache_name(f))
end
```