# 第9章 其他模式
本章将介绍不同于前述的其他一些设计模式,这些模式对于构建大型应用程序非常有用.它们提供的一些工具能帮助我们强化前几章中看到的主要模式.简而言之,我们将探索以下三种模式:
 - 单例类型分派模式
	 单例类型分派模式利用了Julia的多重分派特征,该特征使你可以添加新功能,而不必修改
 - 打桩/模拟模式
	 用外部依赖项的情况下对其进行测试.它使自动化测试变得更加容易.
 - 函数管道模式
	函数管道模式利用管道运算符来表示执行的线性流程.它是许多数据处理管道中采用的一种编程方式.有人发现线性执行的概念更直观.我们将探索一些示例来表示这种模式是良好的.

## 9.2单例类型分派模式
Julia支持动态分派,这是其多重分派系统的特有功能.动态分派允许程序在运行时根据函数参数的类型分派到适当的函数.如果你熟悉面向对象编程语言方面的多态性,那么这个概念是相似的.在本节中,我们将解释什么是单例类型以及如何将其用于实现动态分派.
首先,让我们考虑一个桌面应用程序用例,其中系统响应用户单击事件.图形用户界面(GUI) 如图

	File               | Help
	Open File...
	Close File
	Exit

$$图9-1$$
首先我们尝试使用简单的逻辑来实现文件处理函数,看如何使用单例类型分派模式对其进行改进.
### 9.2.1 开发命令处理器
我们第一次尝试实现类似于以下内容的命令过程:

```julia
function process_command(command::String, args)  # CODE SMELL
	if command == "open"
		#open a file
	elseif command == "close"
		#close current file
	elseif command == "exit"
		#exit program
	elseif command == "help"
		#popsupa help dialog
	else
		error("bug, this should have never happened.") 
	end
end
```
函数将命令作为字符串,根据字符串的值,它将调用相应的函数.可以通过GUI代码传递args参数以获取更多信息.例如,正在打开或关闭的文件的路径.
#CODE-SMELL
### 9.2.2 理解单例类型
单例类型只是设计为具有单个实例的数据类型.可以通过定义没有任何字段的类型来轻松实现它:
`struct OpenCommand end`
要创建此类数据类型的单个实例,我们可以使用以下默认构造函数:
`OpenCommand() `
与某些面向对象的编程语言不同,此构造函数返回完全相同的实例,即使你多次调用它也是如此.换句话说,它已经是一个单例.我们可以如下证明.
```julia
julia> oc1 = OpenCommand() ;
julia> oc2 = OpenCommand() ;
julia> oc1 === oc2 # true
```
创建两个OpenCommand实例之后,我们使用`===`运算符对它们进行比较,它告诉我们这两个实例确实是在引用同一对象.因此,我们实现了单例的创建.

为每个命令创建一个单例类型,即`CloseCommand,ExitCommand,HelpCommand`等.此外,我们还可以创建一个称为`AbstractCommand`的新抽象类型,该抽象类型可以用作所有这些命令类型的超类型.更好的方法是用**参数化类型**来为不同的命令创建不同的单例类型.由于这是一个相当普遍的用例,因此Julia预定义了一个称为Val的类型.让我们来看看它.

### 9.2.3 使用Val参数化数据类型 (PDT) 
#单例对象
Val是在Base包中定义的**参数化数据类型**.其目的是为我们提供一种**使用单例类型进行分派**的简便方法.Val类型定义如
```julia
struct Val{x} end
```
那我们如何创建单例对象呢 ? 我们可以使用Val构造函数并将其传递任何值.例如,我们可以创建一个嵌入值为1的单例类型,如下所示.
```julia
julia> Val(1) 
Val{1}
# 让我们确认这个对象的数据类型.
julia> Val(1)  |> typeof
Val{1}
julia> Val(2)  |> typeof
Val{2}
```
可以看到Val{x}分别具有自己的类型Val{x}.有趣的是,传递给构造函数的值最终以**类型签名**结尾.
我们可以通过调用两次Val构造函数并比较它们的身份来证明这些确实是单例.
```julia
julia> Val(1)  === Val(1)  # true
julia> Val(:foo)  === Val(:foo)  # true
```
Val构造函数也可以接受符号作为参数.请注意,Val只接受**位类型**的数据,因为它属于**类型签名**.大多数用例都涉及在类型参数中带有整数和符号的Val类型.如果尝试创建非位类型的Val对象,则会收到如下错误:
```julia
julia>Val("julia") 
ERROR:TypeError:in Type,in parameter,expected Type,got String
```
### 9.2.4 使用单例类型动态分派 {::STD}
调用函数时会根据参数的类型分派函数调用.请参见 [[3.设计函数与接口#多重分派]], Val 也是类型(参数化数据类型) 

对于每个命令,定义一个采用单例类型的函数.例如,Open和Close事件的函数签名如下:
```julia
function process_command(::Val{:open}, filename) 
	println("opening file $filename") 
end
function process_command(::Val{:close}, filename) 
	println("closing file $filename") 
end
```
我们不必为第一个参数指定任何名称,因为我们不需要使用它.但必须指定类型.给定这样的函数签名,我们可以按以下方式处理Open事件.
```julia
process_command(Val(:open) ,"julia.pdf") 
# opening file julia.pdf
```
我们创建一个单例并将其传递给函数.因为类型签名匹配,所以Julia将分派到我们在前面的截图中定义的函数.现在,假设我们已经定义了所有其他函数,我们可以如下编写主分派程序的代码:
```julia
function process_command(command::String, args...) 
	process_command(Val(Symbol(command) ) , args...) 
end
```

这里我们只需将命令转换为符号,然后将其传递给Val构造函数即可创建单例类型的对象.在运行时,将相应地分派适当的process_command函数.让我们快速测试一下.
```julia
process_command("open","julia.pdf") 
# opening file julia.pdf
process_command("close","julia.pdf") 
# closing file julia.pdf
```

太棒了!它只是利用**动态分派来找出要调用的底层函数**.- 每当我们需要添加新命令时,我们都可以定义一个新的带有**Val单例**的`process_command`函数.主分派函数不再更改.可以创建自已的参数化类型,而不是使用标准Val类型.这可以非常简单地实现,如下所示:
```julia
#A parametric type that represents a specific command
struct Command{T} end
# Constructor function to create a new Command instance from a string
Command(s::AbstractString)  = Command{Symbol(s) }() 
```
构造函数使用字符串,并创建一个Command单例对象,该对象具有从字符串转换而来的Symbol类型参数.有了这种单例类型,我们可以定义分派函数和相应的操作,如下所示:
```julia
# 分派函数
function process_command(command::String,args...) 
	process_command(Command(command) ,args...) 
end
# Actions
function process_command(::Command{:open}, filename) 
	println("opening file $filename") 
end
function process_command(::Command{:close}, filename) 
	println("closing file $filename") 
end
```
这种样式的代码在Julia编程中相当常见,由于已被函数分派替换,因此不再存在条件分支.此外,你还可以通过定义新函数来扩展系统的功能,且无须修改任何现有代码.当我们需要从第三方库扩展功能时,这是一个相当有用的特性.
### 9.2.5 分派的性能优势
使用单例类型很好,因为我们可以避免编写条件分支.另一个好处是可以提高性能.我们可以在Julia的Base包的**ntuple**函数中找到一个有趣的示例.ntuple函数用于通过在1到N的序列上应用函数来创建N个元素的元组.例如,我们可以创建偶数元组,如下所示.
`julia> ntuple(i -> 2i, 10)  # (2,4,6,8,10,12,14,16,18,20) `
窥视源代码,将会发现这个有趣的定义:
```julia
function ntuple(f::F,n::Integer) where F
	t = n==0 ? () :
		n==1 ? (f(1) ,) :
		n==2 ? (f(1) ,f(2) ) :
		n==3 ? (f(1) ,f(2) ,f(3) ) :
		n==4 ? (f(1) ,f(2) ,f(3) ,f(4) ) :
		n==5 ? (f(1) ,f(2) ,f(3) ,f(4) ,f(5) ) :
		n==6 ? (f(1) ,f(2) ,f(3) ,f(4) ,f(5) ,f(6) ) :
		n==7 ? (f(1) ,f(2) ,f(3) ,f(4) ,f(5) ,f(6) ,f(7) ) :
		n==8 ? (f(1) ,f(2) ,f(3) ,f(4) ,f(5) ,f(6) ,f(7) ,f(8) ) :
		n==9 ? (f(1) ,f(2) ,f(3) ,f(4) ,f(5) ,f(6) ,f(7) ,f(8) ,f(9) ) :
		n==10 ? (f(1) ,f(2) ,f(3) ,f(4) ,f(5) ,f(6) ,f(7) ,f(8) ,f(9) ,f(10) ) : _ntuple(f,n) 
	return t
end
```

如果大于10,则调用另一个函数来创建元组:
```julia
function _ntuple(f,n) 
@_noinline_meta
(n>=0) 11throw(ArgumentError(string("tuple length should be≥0,got
n) >) 
([f(i) fori=1:n]...) 
end
```
该_ntuple函数的性能较差,因为它使用类型推导来创建数组, 然后将结果分配到新的元组中.当我们来比较创建10个元素的元组和创建11个元素的元组的情况时,性能基准测试的结果可能会让你感到非常惊讶.
```julia
julia> using BenchmarkTools
julia> @btime ntuple(i->2i, 10) ;
0.031 ns (0 allocations: 0 bytes)  # 1.1ns
julia> @btime ntuple(i->2i, 11) ;
820.195 ns (4 allocations: 336 bytes)  # 386.2 ns
```
ntuple函数被设计为在元素数量少(即10个或更少的元素) 时表现最佳.可以将更改ntuple函数来进行更多的硬编码,但是编写代码太烦琐了,且结果代码非常丑陋.也许更令人惊讶的是,Julia在使用Val单例类型时实际上具有相同函数的另一个变体,如以下截图所示.
```julia
julia> @btime ntuple(i->2i,Val(10) ) ;
0.032 ns (o allocations: 0 bytes) 
julia> @btime ntuple(i->2i,Val(11) ) ;
0.031 ns (0 allocations:0 bytes) 
julia> @btime ntuple(i->2i, Val(100) ) ;
17.301 ns (0 allocations:0 bytes) 
```

理论上10个元素和11个元素之间没有区别.实际上,即使100个元素,与非Val版本(820纳秒) 相比,性能还是相当合理的(17纳秒) .让我们看一下它是如何实现的.以下摘自Julia源代码:
```julia
Using singleton type dynamic dispatch
#inferrable ntuple (enough for bootstrapping) 
ntuple(f,::Val{0}) =() 
ntuple(f,::Val{1}) =(@_inline_meta;(f(1) ,) ) 
ntuple(f,::Val{2}) =(@_inline_meta;(f(1) ,f(2) ) ) 
ntuple(f,::Val{3}) =(@_inline_meta;(f(1) ,f(2) ,f(3) ) ) 
@inline function ntuple(f::F,::Val{N})  where {F,N}
	N::Int
	(N>=0)  || throw(ArgumentError("tuple length should be≥0,got", N) ) ) 
	if @generated
		quote
			@nexprs $N i -> t_i = f(i) 
			@ncall $N tuple t
		end
		# 新版直接用 :(@ntuple $N i -> f(i) ) 
	else
		Tuple(f(i)  for i=1:N)  # Tuple(i for i in 1:n) 
	end
end
```
从前面的代码中,我们可以看到为少于4个元素的元组定义了一些函数.之后,该函数使用元编程技术动态生成代码.在这种情况下,它使用一种特殊的结构,允许编译器在代码生成及其泛型实现之间进行选择,这在代码的if块和else块中表示.@generated,@nexprs和@ncalls宏如何工作略. 编译器已经选择了代码生成的方式.
## 9.3 打桩/模拟模式
### 9.3.1 测试替身
在我们开始讨论打桩/模拟的细节之前,复习一些行业标准的术语将很有帮助.首先是测试替身的概念, 利用伪造的组件代替真实的组件.有**多种类型**的测试替身,但最有用的是打桩和模拟,本节我们将重点介绍.在面向对象的编程中,这些概念用在类和对象上.在Julia中,我们将对函数使用相同的术语.使用函数的一个好处是,我们可以将所有精力集中在测试一件事情上.打桩是伪造的函数,它模仿真实函数,也称为协作函数.根据测试目标的要求,它们可能总是像返回始终相同的结果一样愚蠢,或者它们可能更聪明,并根据输入参数返回不同的值.无论它们有多聪明,出于一致性原因,几乎总是对返回值进行硬编码.
在测试过程中,当待测函数(FunsUnTest) 被执行时,打桩将替换协作函数.当FUT完成执行时,我们可以确定返回值的正确性.这称为状态验证.这些函数之间的交互如图9-2所示.

  $f_{FUT}$   普通调用 -> g 协作函数
		   └─------> $g _{s}$ 打桩
		   *重定向调用*
		
$$图9-2$$
模拟也是模仿协作函数的伪造函数.模拟和打桩之间的区别在于,模拟专注于行为验证.模拟不仅仅检查FUT的状态,还跟踪所有正在进行的调用.它可用于验证行为,例如预期模拟将被调用多少次,预期将传递模拟的参数的类型和值等.这称为行为验证.在执行结束时,我们可以执行状态验证和行为验证.如图9-3所示.

  $f_{FUT}$   普通调用 -> g 协作函数
		   └─------> $g _{m}$ 模拟(跟踪行为) 
		   重定向调用
$$图9-3$$
接下来我们将重点介绍如何在测试中应用打桩和模拟.
### 9.3.2 信贷审批用例
在本节中,我们将介绍与信贷有关的样本用例.假设你正在开发一个能够在**背景检查**后为客户开设新信用卡账户的系统.你可以创建具有以下结构的Julia模块:
```julia
module CreditApproval
# primary function to open an account
function open_account(first_name,last_name,email)  end
#supportive functions
function check_background(first_name,last_name)  end
function create_account(first_name,last_name,email)  end
function notify_downstream(account_number)  end
end
```
我们将从`check_background`函数开始实现,该函数仅记录事件并返回成功true.请看以下代码:
```julia
# Background check. In practice,we would call a remote service for this.
function check_background(first_name, last_name) 
	println("Doing background check for $first_name $last_name") 
	return rand()  >.5
end
```
create_account函数与此类似.在这种情况下,预期的行为是返回一个账号,即一个整数值,它代表刚创建的账号.对于此示例,我们只返回硬编码值1,如下所示:
```julia
function create_account(first_name, last_name, email) 
	println("Creating an account for $first_name $last_name") 
	return rand(Int8)  |> abs |> string |> x -> lpad(x, 3, '0') 
end
```

notify_customer函数应该向客户发送电子邮件.为了测试目的,我们只记录事件:
```julia
function notify_downstream(account_number) 
	println("Notifying downstream system about new account $account_number") 
	return nothing
end
```
最后,open_account函数如下:
```julia
# Open a new account.returns :success if successful else :failure
function open_account(first_name,last_name,email) 
	check_background(first_name, last_name)  || return :failure
	account_number = create_account(first_name, last_name, email) 
	notify_downstream(account_number) 
	return :success
end
```

### 9.3.3 使用打桩执行状态验证
我们的目标是在两种情况下测试`open_account`函数, 根据`check_background`函数返回true或false.使用我们的术语,open_account是FUT,而check_background是协作函数.我们无法真正控制协作函数的行为也不需每次测试软件时都调用远程服务.现在我们已经从原始的`CreditApproval`模块复制到了一个名为`Credit-Appro-val-Stub`的新模块,创建一个**打桩**来替换协作函数即可.由于函数在Julia中是第一类实体,因此我们可以重构`open_account`函数,以便它可以从关键字参数中获取任何背景检查函数,如下所示:
```julia
function open_account(first_name,last_name,email; checker = check_background) 
	checker(first_name,last_name)  || return :failure
	account_number = create_account(first_name,last_name, email) 
	notify_downstream(account_number) 
	return :success
end
```
新的checker(关键字参数) 来传递`背景检查`的函数.默认值设置为原始的check_background函数,因此它的行为应与以前相同.但现在该函数更具可测试性.现在可以覆盖两个执行路径,如下所示:
```julia
using Test
@testset "CreditApprovalStub.jl" begin
# 🎩🎩🎩🎩🎩🎩 stubs 🎩🎩🎩🎩🎩🎩
check_bg_success(first_name,last_name)  = true
check_bg_failure(first_name,last_name)  = false
# testing
let firstname ="John",last="Doe",email="jdoe@juliaawesome.com"
	@test open_account(firstname,last,email,checker=check_bg_success)  ==:success
	@test open_account(firstname,last,email,checker=check_bg_failure)  ==:failure
end
end # end of test
```
打桩函数`check_bg_success/check_bg_failure`模拟成功和失败的背景检查.然后,当我们需要测试open_account函数时,我们可以通过checker关键字参数传递这些打桩函数.现在运行测试.

如果我们再创建更多的关键字参数接受打桩, 来测试其他函数,将同样容易.但需要不断更改代码以适应测试, 好的工具用于应用打桩和模拟,而不会过多地破坏源代码.

### 9. 3. 4 使用Mocking包实现打桩
Mocking包是实现打桩的一个选择.现在,项目名称是CreditApprovalMockingStub:
 1)  首先,确保已安装Mocking包.然后,修改FUT,如下所示:
```julia
using Mocking
function open_account(first_name,last_name,email) 
	@mock(check_background(first_name,last_name) )  || return	:failure
	account_number = create_account(first_name,last_name,email) 
	notify_downstream(account_number) 
	return :success
end
```
@mock宏创建一个可以在其中应用打桩的**注入点**,从而替换了对协作函数(即check_background) 的现有调用.在正常的执行条件下,@mock宏仅调用协作函数.
2)  在测试时可以应用打桩.为了实现这种行为,我们需要在测试脚本顶部激活模拟,如下所示:
```julia
using Mocking
Mocking.activate() 
```
3)  接下来,我们可以使用@patch宏定义打桩函数:
```julia
check_background_success_patch =
	@patch function check_background(first_name,last_name) 
		println("check_background stub ==> simulating success") 
		return true
	end
check_background_failure_patch = 
	@patch function check_background(first_name,last_name) 
		println("check_background stub ==> simulating failure") 
		return false
	end
```

> @patch宏放在函数定义前面, 函数名称必须同原始协作函数, 同样函数的参数个数和类型匹配.
> ⚠️ 未注明类型的实际是`::Any`, 参数名不做要求.

4)  @patch宏返回一个匿名函数,该函数可以应用于FUT中的调用点.为调用补丁,我们使用apply函数,如下所示:
```julia
using Test
# test background check failure case
apply(check_background_failure_patch)  do
	@test open_account("john","doe","jdoe@julia-is-awesome.com")  == :failure
end
# test background check successful case
apply(check_background_success_patch)  do
	@test open_account("peter","doe","pdoe@julia-is-awesome.com")  == :success	
end
```
5) apply函数接受打桩并将其应用到协作函数被调用的地方,例如FUT中的@mock宏所标识的那样.让我们从REPL中运行测试.
```julia
# 确定在项目环境
julia --project=.
# 或在 pkg 上下文 
(@v1.11)  pkg> actviate .
(CreditApprovalMockingStub)  pkg> test
     Testing Running tests...
check_background stub ==> simulating failure
check_background stub ==> simulating success
Creating an account for peter doe
Notifying downstream system about new account 1
Test Summary: | Pass  Total  Time
Stubs         |    2      2  0.7s
check_background mock is called, simulating success
create account_number mock is called
notify downstream mock is called
Test Summary: | Pass  Total  Time
Mocking       |    5      5  0.2s
     Testing CreditApprovalMockingStub tests passed
```

6) 现在,让我们确保在正常执行条件下不使用打桩.从REPL中我们可以直接调用该函数.
```julia
open_account("A", "B", "c") 
	真实检查 for A B
	Creating an account for A B
	Notifying downstream system about new account [acct-16145]
	:success

```

### 9.3.5 将多个打桩应用于同一函数

在我们的示例中,open_account函数调用多个相关函数.它为客户执行背景检查,创建账户,并通知下游系统.实际上,我们可能要为所有这些对象创建打桩.我们如何应用多个打桩?Mocking包支持这个功能.和之前一样,对于每个要应用于打桩的函数,我们都需要使用@mock宏来装饰`open_account`函数.以下代码显示了这一点:
```julia
function open_account(first_name,last_name; email) 
	@mock(check_background(first_name,last_name) )  || return :failure
	account_number=@mock(create_account(first_name,last_name,email) ) 
	@mock(notify_downstream(account_number) ) 
	return :success
end
```
现在,我们准备创建更多的打桩.为了演示,我们将为create_account函数定义另一个打桩:
```julia
create_account_patch =
	@patch function create_account(first_name,last_name,email) 
		println("create_account stub is called") 
		return 314
	end
```

为了测试同时应用check background success_patch和create_account_patch的场景,我们可以将它们作为数组传递给apply函数:
```julia
apply([check_background_success_patch,,create_account_patch])  do
	@test open_account("peter", "doe", "pdoe@julia-is-awesome.com")  ==
	:success
end
```
请注意,我们没有为notify_downstream函数提供任何打桩, 则使用原始协作函数 for 灵活性, 也就是mock注入覆盖了$2^{注入点}$个不同的场景.FUT的测试复杂性呈指数增加.这也是我们要编写小函数的原因之一.
模拟是另一种验证方法,该方法将重点转移到验证FUT及其协作函数的行为上.接下来,我们将对其进行研究.
### 9.3.6 使用模拟执行行为验证
模拟与打桩不同,模拟不仅仅测试函数的返回值,还着重于从协作函数的行为角度测试期望.
- 从check_background函数的角度来看,每个open_account调用仅调用一次吗?
- 从create_account函数的角度来看,是否在背景检查成功时调用了它?
- 从create_account函数的角度来看,背景检查失败时是否不调用它?
- 从notify_downstream函数的角度来看,是否使用大于`0`的账号来调用它?
设置支持模拟的测试的过程主要有四个步骤:
1) 设置测试期间将使用的模拟函数.
2) 建立对协作函数的期望.
3) 运行测试.
4) 验证我们之前设定的期望.
现在,让我们尝试开发自已的模拟测试.我们用成功开设新账户的例子来练习.在这种情况下,我们可以预期check_background,create_account和notify_downstream函数仅被调用一次.另外,我们可以预期传递给notify_downstream函数的账号应该大于1.我们将创建一个带有绑定变量的let块来跟踪我们要根据期望进行测试的所有内容:
```julia
let check_background_call_count =0,
create_account_call_count=0,
notify_downstream_call_count=0,
notify_downstream_received_proper_account_number=false
#insert more code here...
```
前三个变量将用于跟踪我们将要创建的三个模拟的调用次数.同样,最后一个变量将用于记录测试期间notify_downstream函数是否接收到正确的账号, 模拟函数如下:
```julia
check_background_success_patch=
	@patch function check_background(first_name,last_name) 
		check_background_call_count+=1
		println("check_background mock is called,simulating success") return true
	end
```
在这里,我们只是增加了模拟函数中的`check background_call_count`计数器,以便我们可以跟踪模拟函数被调用了多少次.同样,我们可以用相同的方式定义模拟函数
```julia
create_account_patch=
	@patch function create_account(first_name,last_name,email) 
		create_account_call_count +=1
		println("create account_number mock is called") 
		return 314
	end
```
最后一个模拟函数notify_downstream_patch覆盖两个期望.它不仅调用被调用次数,

综上所述,模拟与打桩完全不同,因为它既用于行为验证,也用于状态验证.

## 9.4 函数管道模式


有时,在构建应用程序时,我们面临着一个大问题,需要复杂的计算和数据转换.我们通常可以使用结构化编程技术来将大问题分解为中型问题,然后将其进一步分解为小问题.

当问题足够小时,我们可以编写函数来分别解决每个问题.当然,这些函数不是孤立工作的一一一个函数的结果更有可能传递到另一个函数中.

函数管道模式利用管道无缝传递. 第一个函数是从HackerNews检索热门资讯,其代码如下:
```julia
using HTTP
using JSON3

url="https://hacker-news.firebaseio.com/v0/topstories.json"
response=HTTP.request("GET",url) # HTTP.Messages.Response

JSON3.read(String(response.body)) 
#= 495 ByteChar = CodeUnits{UInt8, String} 字节 char
500-element JSON3.Array{Int, ByteChar, Vector{UInt64}}
=#
	
function fetch_top_stories()
	url="https://hacker-news.firebaseio.com/v0/topstories.json"
	response=HTTP.request("GET",url)
	return JSON3.read(String(response.body))
end

struct Story
	by::String
	descendants::Union{Nothing,Int}
	score::Int
	time::Int
	id::Int
	title::String
	kids::Union{Nothing,Vector{Int}}
	url::Union{Nothing,String}
end

#Construct a Story from a Dict (or Dict-compatible) object
function Story(obj)
	value=(x)->get(obj, x, nothing) # 取值函数
	return Story(
		obj[:by], # by string
		value(:descendants), # descendants::Nothing | Int
		obj[:score], # Int
		obj[:time], # Int
		obj[:id], # Int
		obj[:title], # String 
		value(:kids), # kids Vector{Int} | nothing
		value(:url)) # string | nothing
end
```

检索单个资讯的详细信息的函数:
```julia
function fetch_story(id)
	url = "https://hacker-news.firebaseio.com/v0/item/$(id).json"
	response = HTTP.request("GET",url)
	return Story(JSON3.read(response.body))
end
fetch_story(21676252)
Story("kkm",372,517,1575218518, 21676252,"The world needs more sear
ch engines",[],"https://www.0x65.dev/blog/2019-12-01/the-world-needs-cliqz-the-world-needs-more-search-engines.html")
```
计算前N个资讯的平均得分.average_score函数如下:
```julia
using Statistics: mean
using Dates
function average_score(n = 10)
	story_ids = fetch_top_stories()
	println(now(), "Found ",length(story_ids),"stories")
	top_stories = [fetch_story(id) for id in story_ids[1:min(n,end)]]
	println(now(), "Fetched ", n, " story details")
	avg_top_scores = mean(s.score for s in top_stories)
	println(now(), "Averagescore = ", avg_top_scores)
	return avg_top_scores
end
average_score()
#= 2024-12-13T19:02:13.809Found 500stories
2024-12-13T19:02:16.053Fetched 10 story details
2024-12-13T19:02:16.120Averagescore = 192.2=#

# 管道
fetch_top_stories() |> first |> fetch_story
Story("sohkamyung", 38, 190, 1734057001, 42405462, "A new video captures a 1968 demo of IBM's Executive Terminal", [], "https://spectrum.ieee.org/ibm-demo")
```

### 9.4.3设计可组合函数

合它们,那么我们也可以灵活地构建许多不同的事物.在Julia中,我们可以很容易地编写函数.
让我们使用与上一节相同的示例.我们将创建一个名为top_story_id的新函数,该函数从Hacker News中检索第一个资讯ID.
```julia
top_story_id = first ∘ fetch_top_stories #58 (generic function with 1 method)
```
top_story_id函数被定义为组合(匿名)函数.Unicode圆形符号`∘ 输入为\circ {tab}`是Julia中的组合运算符.与管道运算符不同,我们**从右到左**读取组合函数的顺序.在这种情况下,我们首先应用fetch_top_stories函数,然后再应用first函数.
```julia
top_story_id() # 21676252
top_story=fetch_story ∘ first ∘ fetch_top_stories
top_story(); # Story
title(s::Story) = s.title

get_first_story_title = title ∘ fetch_story ∘ first ∘ fetch_top_stories
get_first_story_title()
# "macOS 15.2 breaks the ability to copy the OS to another drive"

get_first_story_title |> typeof
# CF{CF{CF{T_title, T_fetch_story}, T_first}, T_fetch_top_stories}
```

### 9.4.4 为平均得分函数开发函数管道
首先,让我们回顾一下average_score函数的编写方式:
```julia
function average_score(n = 10)
	story_ids = fetch_top_stories()
	println(now(),"Found ",length(story_ids)," stories")
	top_stories = [fetch_story(id) for id in story_ids[1:min(n,end)]]
	println(now()," Fetched ",n,"story details")
	avg_top_scores = mean(s.score for s in top_stories)
	println(now(),"Average score = ",avg_top_scores)
	return avg_top_scores
end
```
尽管代码看起来相当不错并且易于理解,但让我指出一些潜在问题: 
- 热门资讯是通过**数组展开语法**检索的.该逻辑有点复杂,我们将无法独立于average_score函数来测试这部分代码.
- println函数用于记录日志,但是我们似乎正在复制代码以显示当前时间戳. 

现在,我们将重构代码.该逻辑在很大程度上是线性的,这使其成为函数管道的理想选择.从概念上讲,图9-6是我们对计算的看法.
```
提取热门资讯 --> 允许提取前n个资讯 --> 提取资讯详细信息 -->  计算资讯平均得分 --> end
			^                  ^                  ^                   ^
	Vector{Int}           Vector(Int)    Vector{Story}              Float64
``` 
图9-6
设计一个如下所示的函数会很好:
```julia
take(n::Int) = xs -> xs[1:min(n,end)]
fetch_story_details(ids::Vector{Int}) = fetch_story.(ids)
calc_average_score(stories::Vector{Story}) = mean(s.score for s in stories)
# 忽略日志记录方面以使其保持简单,稍后会再谈.
average_score2(n=10) =
	fetch_top_stories() |>
	take(n) |>
	fetch_story_details |>
	calc_average_score
```

快速提醒一下,所有这些函数都接受单个参数作为输入,以便它们可以参与函数管道操作.
现在,让我们回到日志记录.日志记录在函数管道中扮演着有趣的角色.它被设计为产生额外作用,并且不影响计算结果, 像linux的`tea`命令
另外,我们希望能够使用通过系统的数据来格式化输出.因此,我们可以利用Formatting包:
```julia
using Formatting: printfmtln
logx(fmt::AbstractString,f::Function=identity) = x -> begin
	let y = f(x)
		print(now(), " ")
		printfmtln(fmt,y)
	end
	return x
end
```
logx函数采用格式字符串和可能的转换器函数f.它返回一个匿名函数,该匿名函数将转换后的值传递给printfmln函数.它还会自动为日志添加当前时间戳.最重要的是,此匿名函数返回参数的原始值.要查看此日志记录函数的工作方式,我们可以使用一些示例.
```julia
"John" |> logx("Hello,{}")
# 2019-12-01T12:49:36.947 HeLlo,John
"John"

[1,2,3] |>logx("Array size is {}", length)
# 2019-12-01T12:49:40.099 Array size is 3
[1,2,3]
```
综上所述,我们可以在新的average_score3函数中将日志记录引入函数管道,如下所示:
```julia
average_score3(n=10) =
	fetch_top_stories()                     |>
	logx("Number of top stories={}",length) |>
	take(n)                                 |>
	logx("Limited number of stories=$n")    |>
	fetch_story_details                     |>
	logx("Fetched story details")           |>
	calc_average_score                      |>
	logx("Averagescore={}")
```

### 9.4.5 在函数管道中实现条件逻辑
由于逻辑流是线性的,我们如何处理条件逻辑?
通过阈值检查平均得分来确定热门资讯.我们可以使用动态分派来解决此问题.我们将自下而上地构建这个函数,如下所示.
1) 创建`hotness`函数, 它返回`Val{:high}` 或`Val{:low}`参数化数据类型的实例.
  ```julia
  hotness(score) = score > 100 ? Val(:high) : Val(:low) # 这里不要用 {}
  ```
2) 针对Val参数化类型创建两个celebrate函数.它们只是使用logx函数来打印一些文本.我们用v的值来调用它,如果我们想在庆祝之后做更多工作,就可以将热度参数传递到下游:
```julia
celebrate(v::Val{:high}) = logx("Woohoo! Lots of hot topics!")(v)
celebrate(v::Val{:low})  = logx("It's just a normal day...")(v)
celebrate(v::Val{:high}) = logx("Woohoo! Lots of hot! {}", reverse ∘ string)(v)
celebrate(v::Val{:low}) = logx("Jjust a normal day!{}", uppercase ∘ string)(v)
```
3)使用函数管道模式构建check_hotness函数.该管道设计模式使用`average_score3`函数来计算平均得分.然后,hotness来确定如何更改执行路径.最后,它通过多重分派机制调用了celebrate函数:
```julia
check_hotness(n=10) =
	average_score3(n) |> hotness |> celebrate

check_hotness(10)
#=
2019-12-01T13:33:58.384 Number of top stories= 496
2019-12-01T13:33:58.385 Limited number of stories = 10
2019-12-01T13:34:00.343 Fetched story details
2019-12-01T13:34:00.343 Average Score = 64.9
2019-12-01T13:34:00.343 It's just a normal day...
Val{:low}
=#
```
这个简单的示例演示了如何在函数管道设计中实现**条件逻辑**.
重要的一点是函数管道仅处理**线性**执行.
因此,只要执行**有条件地拆分**,我们就会为每个可能的路径形成一个**新管道**.
```
      [⚪⚪]
       /   \
      /单分派\
     /       \
   [⚪⚪]  [⚪⚪]
              /\
            单分派
            /    \
        [⚪⚪] [⚪⚪]
```
但是,有时会因它们必须在管道中的每个组件之间传递中间数据,从而导致不必要的内存分配和速度变慢而受到批评.我们将介绍使用广播来克服此问题.

### 9.4.6 沿函数管道进行广播
在数据处理管道中,我们可能会遇到这样的情况,即函数融合在一起成为一个loop.这称为广播,可以通过使用点符号方便地启用它.对于数据密集型应用程序,使用广播可能会带来巨大的性能差异.考虑以下情形,其中已经定义了两个向量化函数:
```julia
add1v(xs)=[x+1 for x in xs]
mul2v(xs)=[2x for x in xs]
add1mul2v(xs)= xs |> add1v |> mul2v
```

add1v函数采用一个向量并将所有元素加1.同样,mul2v函数采用一个向量并将每个元素乘以2.现在,我们可以组合这些函数以创建一个采用一个向量的新函数,它通过管道发送到add1v以及随后的mul2v:

`add1v`函数和`mul2v`操作必须完成后传递. **中间结果虽然只是临时需要,但必须在内存中分配**,如图.
```julia
⚪-> Vector{Int} -> [加1(向量化)] -> Vec{Int} -> [乘2(向量化)] -> Vec{Int} -> ⚫
```

我们可以利用广播避免中间结果.让我们创建对单个元素而非数组进行操作的函数,如下所示:
```julia
add1(x)=x+1
mul2(x)=2x
```
仍然需要取一个向量,将每个元素加1,然后乘以2. 使用点符号定义这样的函数:
```julia
add1mul2(xs) = xs .|>add1 .|> mul2
```
管道运算符前面的点符号表示xs中的元素将广播到add1和mul2函数,将整个操作融合为一个loop.
```
                         Int
⚪ Vector{Int} --> [+1] ----> [*2] --> Vector{Int} ⚫
                ^--------------------┘
                         循环数组
```
$$图9-9$$
中间结果变为单个整数，从而无须临时数组。为了演示从广播中获得的性能改进，我们可以针对这两个函数运行性能基准测试，如以下截图所示。
```julia
using BenchmarkTools
xs = collect(1:10000);
@btime add1mul2v($xs);
# 15.354 μs (4 allocations: 156.41 KiB)
@btime add1mul2($xs);
# 7.530 μs (2 allocations: 78.20 KiB)
```
如上所示，在这种情况下，广播版本的运行速度是向量化版
本的两倍。
在下一节中，我们将回顾有关使用函数管道的一些注意事项。
