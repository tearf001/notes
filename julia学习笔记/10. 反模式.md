反模式是开发人员可能无意间执行的不良做法.有时,这些问题还不够严重,无法引起麻烦.但是,由于设计不当,应用程序可能会变得不稳定或性能下降.
- 海盗反模式
- 窄参数类型反模式
- 非具体类型反模式
## 10.2 海盗反模式
在第2章中,我们学习了如何使用**模块**创建新的命名空间, **模块**用于定义函数,以便它们在逻辑上是分开的.这样我们就可以定义两个名称完全相同,但所表示的事物并不需要完全相同的函数.

这两个不同的函数,并且彼此不干扰.另外,也可以将函数设计为从另一个包扩展.
例如,在Base包中,`AbstractArray`接口被设计为可扩展的.以下是一个例子:
```julia
# My own array-like type for tracking scores
struct Scores <: AbstractVector{Float64}
	values::Vector{Float64}
end

# implement AbstractArray interface
Base.size(s::Scores)=(length(s,values),)
Base.getindex(s::Scores, i::Int) = s.values[i]
```
在这里,我们从Base包扩展了size和getindex函数,以便它们可以使用我们自己的数据类型. 如果我们没有正确地扩展其他包的函数,可能会出现问题.
"海盗"(piracy)是指第三方函数以不好的方式被替换或扩展的情况.这是一种反模式,因为它可能导致系统行为变得不确定.为了方便起见,我们可以定义三种不同类型的海盗:
- $I类海盗$:重新定义函数
- $II类海盗$:扩展函数时无须在任何参数中使用自已的类型
- $III类海盗$:扩展函数用于其他目的
现在,我们将更详细地深入研究每种类型的海盗.

### 10.2.1 $I$类海盗 - 重新定义函数
I类海盗是指开发人员从其自已的模块中重新定义第三方函数的情况.最坏形式是在不符合原始函数接口的情况下更换函数.
```julia
Base.:(+)(x:Int,y:Int) = "hello world"
Error: Error in the keymap ...
```
一旦函数被定义,Julia REPL立即崩溃.这是因为该+函数的被很多依赖依赖.
为什么Julia允许我们这样做?在某些情况下,执行此操作可能会很有用.假设你在第三方包中发现了特定函数的错误,则可以立即注入修订,而不必等待上游的错误修复.同样替换为性能更高的版本.理想情况下,这些更改应发送到上游,但是你可以灵活地立即实施更改.
**唯一的要求**是要替换的函数应遵循相同的约定.因此,这要求对第三方包的设计有深入的了解.

### 10.2.2 $Ⅱ$类海盗一不用自定类型扩展
Julia开发人员社区通常将II类海盗称为"类型海盗".它是指在任何函数参数中不使用开发人员自已的类型的前提下扩展第三方函数的情况.
假设你要模仿JavaScript中将字符串和数字加在一起的行为, 其中值串联在一起就好像它们都是字符串一样.
```js
1 + "2" = 12
```

为了使它在Julia中实现,我们很想在MyModule中执行以下操作:
```JULIA
module MyModule
	import Base.+
	(+)(s::AbstractString,n::Number)="$s$n"
end
"1" + 2 # "12"
```
现在引入另一个包, 也是基于基础类型来扩展
```julia
module AnotherModule
	import Base:+, -, *, /
	(+)(s::AbstractString,n::T) where T<:Number = parse(T,s) + n
	(-)(s::AbstractString,n::T) where T<:Number = parse(T,s) - n
	(*)(s::AbstractString,n::T) where T<:Number = parse(T,s) * n
	(/)(s::AbstractString,n::T) where T<:Number = parse(T,s) / n
end
using .AnotherModule
"1" + 2 # 3

```

两个具有完全相同签名的相同函数的实现,可能导致灾难性的情况和难以发现的错误.
避免II类海盗的另一个原因是面向未来的问题.因升级而中断,这不是我们期望看到的.

创建自定类型在函数参数中, 可减轻II类海盗.创建一个包装器类型使用此新类型进行分派:
```julia
module MyModule
export @s_str

import Base:+, show
struct MyString
	value::AbstractString
end

macro s_str(s::AbstractString)
	MyString(s)
end

show(io::IO,s::MyString) = print(io,s.value)
(+)(s::MyString,n::Number) = MyString(s.value * string(n))
(+)(n::Number,s::MyString) = MyString(string(n) * s.value)
(+)(s::MyString,t::MyString) = MyString(s.value * t.value)
end
# Test
using .MyModule: @s_str
s"I am " + 25 + s" years old!" # I am 25 years old!
```

除了自定义类型, 我们完整定义了+函数的三种变体, 支持不同的顺序和类型, 还定义了str_str宏.

通过在函数参数中使用自已的类型,我们可以避免与其他依赖包的任何冲突,并且可以为Julia升级确保我们的代码面向未来.

### 10.2.3 $Ⅲ$ 类海盗一用自定类型扩展但目的不同
III类海盗是指函数得到扩展但用于不同目的的情况.这是扩展代码的正确过程,但是做起来并不简单.Julia开发人员也将这种海盗称为双关语.为了解它是什么,让我们在这里看一个有趣的示例.
假设我们正在开发一个简单的派对注册的应用程序.类型定义和构造函数如下所示:
```julia
# A Party just contains a title and guest names
struct Party
	title::String
	guests::Vector{String}
end
# constructor
Party(title)=Party(title,String[])

# 注入
Base.join(name::String, party::Party) = push!(party.guests,name)
```

这是Base的join方法的扩展.我们为什么要这样做?如果我们在自已的命名空间中创建join函数,那么我们可能会与标准join函数发生命名冲突.为了避免处理该冲突,仅从Base扩展函数可能会更容易.乍一看,它会按预期工作.
```julia
party = Party("Halloween 2019") # Party("Halloween 2019",String[])
join("Tom",party) # 1-element Array{String,1}: "Tom"
join("Kevin",party) # 2-element Array{String,1}: "Tom" "Kevin"
```
但是,这里有一个隐藏的陷阱.如果我们要让多人同时参加派对,那么我们就很容易陷入麻烦.
```julia
join(["Bob|","|Jeff"], party) # join(::Iterable, delim, [last])
"Bob|Party(\"HalLoween 2019\",[\"Tom\",\"Kevin\"])|Jeff"
help?> join # 原始定义
join([io::I0,] strings,delim,[last])
```

Julia的源代码定义了一些join函数而**未在参数中指定任何类型**.因此,当我们将Party对象传递给join函数时,它使用原始的join逻辑.

## 10.3 窄参数类型反模式
在Julia中设计函数时,关于是否以及如何提供参数类型,我们有很多选择.**窄参数类型**反模式是指参数的类型指定得过于狭窄,从而导致该函数适用范围较小而不能被广泛使用的情况.

让我们考虑一个简单的示例函数,该函数用于计算两个向量的乘积之和:
```julia
function sumprod(A::Vector{Float64},B::Vector{Float64})
	return sum(A .* B)
end
```
此设计没有任何问题,除了仅当参数是Float64值的向量时才可以使用该函数.

### 10.3.1 考虑参数类型的多种选项
只要传递的参数类型与函数签名匹配,Julia的分派机制就可以选择正确的函数来调用.基于类型层次结构,我们可以指定抽象类型,并且仍然可以正确选择函数.这种灵活性为我们提供了许多选项.我们可以考虑以下任何一项:
```julia
sumprod(A::Vector{Float64}, B::Vector{Float64})
sumprod(A::Vector{Number},  B::Vector{Number})
sumprod(A::Vector{T}, B::Vector{T}) where T <: Number
sumprod(A::Vector{S}, B::Vector{T}) where {S <: Number, T <: Number}
sumprod(A::Array{S,N}, B::Array{T,N}) where {N, S <: Number, T <: Number}
sumprod(A::AbstractArray{S,N}, B::AbstractArray{T,N}) where {N,S<:Number,T<:Number}
sumprod(A, B)
```
让我们首先定义我们计划支持的场景.我们希望支持任何**支持广播**的数值容器, 使用点符号.

我们的测试场景涉如表10-1所示的参数组合.

| 场景  | 参数 1                | 参数 2                |
| --- | ------------------- | ------------------- |
| 1   | `Array{Float64, 1}` | `Array{Float64, 1}` |
| 2   | `Array{Int64, 1}`   | `Array{Int64, 1}`   |
| 3   | `Array{Int, 1}`     | `Array{Float64, 1}` |
| 4   | `Array{Float64, 2}` | `Array{Float64, 2}` |
| 5   | `Array{Number, 1}`  | `Array{Number, 1}`  |
					$表10-1$
为了测试这些场景的各种函数签名选项,我们可以构建一个测试工具函数,如下所示:
```julia
function test_harness(f, scenario, args...)
	try
		f(args...)
		println(f,"# $(scenario) success")
	catch ex
		if ex isa MethodError
			println(f,"# $(scenario) failure (method not selected)")
		else
			println(f,"# $(scenario) failure (unknown error $ex)")
		end
	end
end
```
测试工具将函数f与为特定scenario提供的参数args一起应用.如果已分派该函数,则它将在控制台中显示成功消息;否则,将显示失败消息.当我们要测试前面列出的场景时,我们可以只定义一个函数,以便我们可以轻松地执行测试:
```julia
function test_sumprod(f)
	test_harness(f,1,[1.0,2.0],[3.0,4.0]);
	test_harness(f,2,[1,2],[3,4]);
	test_harness(f,3,[1,2],[3.0,4.0]);
	test_harness(f,4,rand(2,2),rand(2,2));
	test_harness(f,5,Number[1,2.0],Number[3.0,4]);
end
```
test_sumprod函数采用一个函数并执行前面五个测试用例.现在我们都准备好了.让我们剖析每个选项,看看它们如何为我们工作.
#### 选型1 Float64的值向量
```julia
# 选项1 Float64值向量
sumprod_1(A::Vector{Float64}, B::Vector{Float64}) = sum(A .* B)
test_sumprod(sumprod_1)
#=========================================
sumprod_1 #1 success
sumprod_1# 2 failure (method not selected)
sumprod_1# 3 failure (method not selected)
sumprod_1# 4 failure (method not selected)
sumprod_1# 5 failure (method not selected)
=========================================#
```
#### 选型2 Number 实例的向量
```julia
sumprod_2(A::Vector{Number},B::Vector{Number}) = sum(A .* B)
test_sumprod(sumprod_2)
#=========================================
sumprod_2 #1 failure (method not selected)
sumprod_2 #2 failure (method not selected)
sumprod_2 #3 failure (method not selected)
sumprod_2 #4 failure (method not selected)
sumprod_2 #5 success
=========================================#
```
乍一看,使用Number作为类型参数似乎会使它更通用.事实证明,它只能接受Number类型的数组,其中每个元素可以是不同的类型,只要所有元素类型都是Number的子类型, 但是Float64值向量**不是**Number值向量的子类型.检查以下代码段.
```julia
Float64 <: Number # true
Vector{Float64} <: Vector{Number} # false
```
#### 选型3 T型向量, where {T <:Number}
```julia
sumprod_3(A::Vector{T}, B::Vector{T}) where {T <: Number} = sum(A .* B)
test_sumprod(sumprod_3)
#=========================================
sumprod_3 #1 success
sumprod_3 #2 success
sumprod_3 #3 failure (method not selected) (f,3,[1,2],[3.0,4.0]) 类型不同
sumprod_3 #4 failure (method not selected) (f,4,rand(2,2),rand(2,2)) Matrix
sumprod_3 #5 success
=========================================#
```
由于类型参数T可以是Number的任何子类型,因此此函数可以轻松处理Float64,Int64甚至Number类型的向量.不幸的是,它**不能处理不同类型**的参数

#### 选项4 类型独立的选项3
此选项与选项3的不同之处仅在于,它分别指定参数的类型.因此,该函数可以为第一个和第二个自变量接受不同的类型.该函数定义如下:
```julia
sumprod_4(A::Vector{S}, B::Vector{T}) where {S<:Number,T<:Number} = sum(A .* B)
#=========================================
test_sumprod(sumprod_5)
sumprod_4 #1 success
sumprod_4 #2 success
sumprod_4 #3 success
sumprod_4 #4 failure (method not selected)
sumprod_4 #5 success
=========================================#
```
但是无法处理矩阵.
#### 选项5 多维版本选项4
```julia
sumprod_5(A::Array{S,N}, B::Array{T,N}) where {N, S <: Number, T <: Number} = sum(A .* B)
#=========================================
julia> test_sumprod(sumprod_5)
sumprod_5 #1 success
sumprod_5 #2 success
sumprod_5 #3 success
sumprod_5 #4 success
sumprod_5 #5 success
=========================================#
```
我们终于满足了测试场景中列出的所有需求.结束了吗?也许还没有.为了便于讨论,我们可能希望支持其他类型的容器,这些容器不一定是密集数组.如果输入的是稀疏矩阵怎么办?让我们再次完善函数.
#### 选项6 抽象数组
AbstractArray是所有Julia数组容器的抽象类型.许多Julia包实现了数组接口,成为AbstractArray的子类型.如果到目前为止我们都不能使sumprod函数具有足够的通用性,而且不能支持稀疏矩阵或其他类型的数组类型的容器,那就太遗憾了.为了使它更通用,让我们将函数定义从Array转换为AbstractArray,如下所示:
```julia
sumprod_6(A::AbstractArray{S,N}, B::AbstractArray{T,N}) where
{N,S<:Number,T<:Number}=sum(A .* B)
```
签名与选项5相同,只是该函数可以使用任何AbstractArray容器类型分派.
```julia
test_sumprod(sumprod_6)
sumprod_6 #1 success
sumprod_6 #2 success
sumprod_6 #3 success
sumprod_6 #4 success
sumprod_6 #5 success
```
该函数适用于我们现有的情况.让我们再次使用稀疏矩阵类型尝试一下.
```julia
using SparseArrays
A = sparse([1,10,100],[1,10,100],[1,2,3])
100×100 SparseMatrixCSC{Int64, Int64} with 3 stored entries:
⎡⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀   ⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀.⎥
B = sparse([1,10,100],[1,10,100],[4,5,6])
100x100 SparseMatrixCSC{Int64,Int64} with 3 stored entries:
[11]=4
[10,10]=5
[100,100] =6
sumprod_6(A,B)
32
```
太棒了!即使使用稀疏矩阵类型,它现在也能很好地工作.

#### 选项7 鸭子类型
我们的最后一个选项基本上跳过了函数参数中的类型.这也称为鸭子类型,因为只要提供了两个参数,该函数就会被分派.
Julia将针对参数类型的不同变体设计并编译新版本.该函数的简单定义如下所示:
```julia
sumprod_7(A,B)=sum(A .* B)
```

小结: 

| 选项  | 签名                                                              | 是否通过测试 |
| --- | --------------------------------------------------------------- | ------ |
| 1   | `sumprod(A::Vector{Float64}, B::Vector{Float64})`               | 否      |
| 2   | `sumprod(A::Vector{Number}, B::Vector{Number})`                 | 否      |
| 3   | `sumprod(A::Vector{T}, B::Vector{T}) where T <: Number`         | 否      |
| 4   | `sumprod(A::Vector{S}, B::Vector{T}) where {ST <: Number}`      | 否      |
| 5   | `sumprod(A::Array{S,N}, B::Array{T,N}) where {N, ST <: Number}` | 是      |
| 6   | `sumprod(A::AA{S,N}, B::AA{T,N}) where {N, ST <: Number}`       | 是      |
| 7   | `sumprod(A, B)`                                                 | 是      |
从技术上讲,选项5,选项6或选项7可以适用于所有数组类型.选项6和选项7支持其他数组容器,例如稀疏矩阵.选项7适用于非AbstractArray类型,只要该类型可以**广播相乘**并求和即可.

### 10.3.2 评估性能
我们将使用具有10000个元素的2个Float64向量来对选项1,选项5,选项6和选项7的函数进行基准测试:
```julia
using BenchmarkTools
B=rand(10_000);
A=rand(10_000);
@btime sumprod_1($A, $B);
@btime sumprod_5($A, $B);
@btime sumprod_6($A, $B);
@btime sumprod_7($A, $B);
#============测试结果如下所示.=================
julia> @btime sumprod_1($A, $B);
  6.475 μs (3 allocations: 78.19 KiB)

julia> @btime sumprod_5($A, $B);
  6.625 μs (3 allocations: 78.19 KiB)

julia> @btime sumprod_6($A, $B);
  6.725 μs (3 allocations: 78.19 KiB)

julia> @btime sumprod_7($A, $B);
  6.650 μs (3 allocations: 78.19 KiB)
============================================#

```
指定函数的$Parameter Type(参数类型)$**并不会影响**函数的运行时性能.
总而言之,我们从这种反模式中学到的是,不应不必要地使函数参数变窄.当参数限制变宽时,函数可能会更加有用.可以接受并支持更多输入类型的函数会自动地更具有重用性.

下一个反模式涉及在设计**数据类型**时应如何选择**字段类型**会极大地影响系统性能.

## 10.4 非具体字段类型反模式

**非具体字段类型**反模式是**结构字段**不具体的反模式.字段的非具体类型的主要问题是它们可能会导致严重的性能问题.为了理解其原因,让我们看一下具有非具体类型和具体类型的复合类
型的内存模型,然后设计并比较这两种类型.

### 10.4.1 理解复合数据类型的内存布局
首先,让我们看一个简单的示例,用于跟踪点坐标的复合类型:

```julia
struct Point
	x
	y
end
```
如果未指定字段类型,则将其隐式解释为Any,即所有类型的超级类型,因此,前面的代码在语法上与下面的代码等效:
```julia
struct PointA
	x::Any
	y::Any
end
struct PointB
	x::UInt8
	y::UInt8
end
struct PointD
    x::Int128
    y::Int128
end

map(P -> P(0x01,0x01), [Point, PointA, PointB, PointD]) .|> sizeof # 16, 16, 2, 32
# 构造时自动转换, 但是不能 InexactError: trunc(UInt8, 111111)
map(P -> P(Int128(1), Int128(1)), [Point, PointA, PointB, PointD]) .|> sizeof #同上
```

Int128是128位整数,在内存中占用16个字节.有趣的是,即使我们在Point中携带2个Int128字段,该对象的大小仍为16个字节.
为什么?这是因为Point实际上存储了2个64位指针,每个指针占用了8个字节的存储空间.
 ```bash
 _______
| Point |
|=======|
|  x:8B |  ●---指针--->  Int128 (16个字节)
|-------|
|  y:8B |  ●---指针--->  Int128 (16个字节)
|_______|
  64位指针
# 而 point4则是
 ________
| PointD |
|========|
| x:16B  |  # Int128 (16个字节)
|--------|
| y:16B  |  # Int128 (16个字节)
|________|
  128位字段
```

### 10.4.2 设计复合类型时要考虑具体类型
从概念上讲,我们想要如下所示的东西:
```julia
struct Point
	x::Real
	y::Real
end
```
但是,由于Real是抽象类型,因此我们预期性能会差一点,就像使用Any一样.为了**利用具体类型而不牺牲支持其他数字类型的灵活性**,我们可以将Point转换为参数化类型.
```julia
struct PointR{T <:Real}
	x::T
	y::T
end
p = PointR(0x01,0x01)
PointR{UInt8}(0x01,0x01)
sizeof(p) # 2

p2=PointR(Int128(1),Int128(1))
PointR{Int128}(1,1)
sizeof(p2) # 32
```

到目前为止,我们都是在假设,struct字段中具体类型的性能要优于非具体类型.那现在了解性能差距.
### 10.4.3 比较具体字段类型和非具体字段类型的性能
基准测试函数将计算数组中所有点的中心点,如下所示:
```julia
using Statistics: mean
function center(points::AbstractVector{T}) where T
	return T(
		mean(p.x for p in points),
		mean(p.y for p in points))
end
```
此外,我们还将定义一个函数,该函数可用于为所需的任何类型建立点的数组:
```julia
make_points(T::Type, n) = [T(rand(),rand()) for _ in 1:n]
```

让我们从PointAny类型开始.我们将产生100000个点,并使用BenchmarkTools测量时间.
```julia
using BenchmarkTools
points = make_points(PointA,100_000);
@btime center($points)
7.613 ms (200004 allocations: 3.05 MiB)
PointAny(0.49910565804040874, 0.5006359192381377)
```
接下来,我们将对Point类型运行性能测试.
```julia
points = make_points(PointR,100_000);
@btime center($points)
181.800 μs (0 allocations: 0 bytes)
PointR{Float64}(0.5010449052336855, 0.49902242032732136)
```
两者之间存在巨大差异.使用参数化Point类型比使用Any作为字段类型的速度大约快25~42倍.

从非具体字段类型反模式中学到的是:
1. 对于复合类型中定义的**字段**,应使用具体类型. 
2. 将我们想要的抽象类型分解为**类型参数**兼具性能收益,支持其他数据类型的能力.

## 10.5 小结
- 海盗反模式。 海盗反模式指的是与从第三方模块扩展函数有关的不好的做法。为方便起见，我们将海盗反模式分为三种类型：I类、II类和III类。每种类型都会导致系统变得不稳定或在将来可能引发问题。

- 窄参数类型反模式。当函数自变量指定得太狭窄时，它们的可重用性就会降低。因为Julia可以将函数特化为各种参数类型，**最通用的类型可以在不牺牲性能的情况下使用**。

- 非具体字段类型反模式。论证了因为低效的内存布局，非具体类型会造成性能问题。
  解决方案: 通过使用**参数化类型**，将具体类型指定为类型参数的一部分，可以轻松解决该问题。
