
本章将介绍几种可用于提高软件鲁棒性的模式。鲁棒性指的是质量方面,也就是说,软件可以正确执行其功能吗？所有可能的情况都能得到正确处理吗？这是为关键任务系统编写代码时要考虑的极其重要的因素。

基于最小权限原则(POLP),我们将考虑向接口的客户端隐藏不必要的实现细节。

但是,Julia的数据结构是透明的一一所有字段都将自动公开并可以访问。这引起了潜在的问题,因为任何不正确的用法或改变都可能破坏系统。另外,通过直接访问这些字段,代码与对象的基础实现更加紧密地耦合在一起。那么,如果字段名称需要更改怎么办？如果某个字段需要替换为另一个字段怎么办？因此,需要应用**抽象**并将对象实现与其**官方**接口**分离**。

我们应该采用更笼统的定义一一我们不仅要覆盖尽可能多的代码行,而且还要覆盖每种可能的情况。代码覆盖率的增加将使我们对代码的正确性更有信心。

我们将这些技术分为以下几节：
- 访问器模式。
- 属性模式。
- let块模式。
- 异常处理模式。

在本章的最后,
- 你将能够通过开发自已的**访问器函数**和**属性函数**来封装数据访问。
- **隐藏全局**变量,以防止在模块**外部**进行意外访问。
- 了解各种**异常处理**技术,并了解如何重试失败的操作。

## 8.2 访问器模式

Julia对象是透明的。那是什么意思？当前,Julia语言无法将访问控制应用于对象的字段。因此,来自C++或Java背景的人们可能会感到有些不安。在本节中,我们将探索多种方法,使正在寻求更多访问控制的用户更能接受该语言。因此,也许我们应该首先定义我们的需求。在我们编写需求时,我们还将问自已为什么首先要拥有它们。

让我们考虑一下Julia程序中的任何对象:
- 有些字段需要对外界隐藏, 作为实现细节,由于将来可能会更改,因此无法使用
- 有些字段需要先验证,然后才能进行更改, 避免无效数据对于构建健壮的系统至关重要。
- 有些字段在读取之前需要触发器：这意味着直到读取值时才加载它们。
- 某些字段可能包含敏感数据,并且必须记录此类字段的使用以进行审核。

现在,我们将讨论如何满足这些需求。


### 8.2.1 getter/setter
在深入研究特定模式之前,让我们先绕道,并讨论我们如何以及为什么遇到问题。假设我们定义了一种名为**Simulation**的数据类型,以跟踪一些科学实验数据和相关统计数据。其语法如下:
```julia
mutable struct Simulation{N}
	heatmap::Array{Float64,N}
	stats::NamedTuple{(:mean,:std)}
end
```

`Simulation` 对象包含一个N维浮点值数组和一个统计值的命名元组。出于演示目的,我们将创建一个简单的函数来执行模拟并创建一个对象,如下所示：
```julia
using Distributions
function simulate(distribution, dims, n) # dims 维度数量, n维度大小
	tp = ntuple(i -> n, dims) # dims 个 n; 1000, 1000
	heatmap = rand(distribution,tp...) # 模拟热图 1000, 1000
	return Simulation{dims}(heatmap, (mean=mean(heatmap),std=std(heatmap)))
end
```

基于用户提供的分布, rand生成heatmap模拟数据, dims参数表示数组中维数,n表示每个维的大小。
这是模拟大小为1000×1000的**正态分布**二维热图的方法, 如下所示。
```julia
sim = simulate(Distributions.Normal(), 2, 1000) # 2 维 1000, 形状 1000 X 2
Simulation{2}([
	-0.5496655775471586 -1.155947629622221; ... # 1000 * 2
	0.7535381287451904 0.11303171231570075],
	(mean = -0.20976084152712213, std = 0.8252160538264388)
)
sim.heatmap # 1000x1000 Array{Float64,2};
sim.stats # (mean = 0.00011828545617957905,std = 0.9997327420929258)
```

存在一个隐式假设,即字段名称代表对象的公共接口, 但是会发生变化.

更好的约定是直接使用名词：
```julia
heatmap(s::Simulation) = s.heatmap
stats(s::Simulation) = s.stats
```

这些getter函数用于为对象定义正式的数据检索接口。如果我们需要更改基础字段的名称(甚至类型),只要不更改公共接口就可以。此外,我们甚至可以删除stats字段,并直接在stats函
数中实现统计计算。现在,对于使用此对象的任何程序,都可以轻松维护向后兼容性。

实现setter函数
对于可变类型,我们可以实现setter。可变范围将包括只能被更改的字段。对于我们的模拟项目,假设我们要允许客户端程序对热图进行某种转换,然后将其放回对象。我们可以轻松支持该用例,如以下代码片段所示：
```julia
function heatmap!(s::Simulation{N},new_heatmap::AbstractArray{Float64,N}) where {N}
	s.heatmap =new_heatmap
	s.stats=(mean=mean(new_heatmap),std=std(new_heatmap))
	return nothing
end
```

setter函数heatmap!接受Simulation对象和新的热图数组。由于stats字段包含基础热图的统计信息,因此我们必须通过重新计算统计信息并更新该字段来保持对象内的一致性。请注意,只有当我们提供setter函数时,才能保证这种一致性。
另一个好处是我们可以在setter函数中执行数据验证。例如,我们可以控制图的大小,并在热图的大小包含奇怪形状时引发错误：
```julia
function heatmap!(s::Simulation{N},new_heatmap::AbstractArray{Float64,N}) where {N}
	length(unique(size(new_heatmap)))==1 ||	error("dimensions must have same size")
	s.heatmap=new_heatmap
	s.stats=(mean =mean(new_heatmap),std=std(new_heatmap))
	return nothing
end
```

在这里,我们首先确定new_heatmap的大小,该大小应以元组形式返回。然后,我们找出该元组中有多少个唯一值。如果在元组中只有一个唯一的数字,那么我们知道该数组是正方形、立方等。否则,我们只会向调用者抛出一个错误。

### 8.2.4 编码规范约束
就像getter函数一样,setter函数充当一个公共接口,在此对象的数据可能会发生突变。在同时具有getter和setter函数之后,我们可以期望调用者通过这些接口。但是原始字段仍然可以直接访问。那么,我们如何阻止这种情况发生呢？接下来让我们探讨一下。一种可能的解决方案是通过将字段重命名为看似私有的内容来阻止直接访问字段。常见约定是在字段名称前加下划线。对于我们的示例,我们可以如下重新定义结构：
```julia
mutable struct Simulation(N)
	_heatmap::Array(Float64,N}
	_stats::NamedTuple((:mean,:std))
end
```

但是,我们中的某些人可能对此解决方案不太满意,因为使用编码约定是强制正确使用编程接口的一种非常弱的方法。这种担忧是非常有效的,尤其是当我们坚持更高的软件健壮性标准时。因此,在下一节中,我们将探索一种更强大的技术,该技术将允许我们以编程方式控制访问。

## 8.3 属性模式
### 8.3.1 延迟文件加载器介绍
假设我们正在开发一种支持延迟加载的文件加载工具。所谓延迟,我们指的是在需要内容之前才加载文件。让我们看一下下面的代码：
#可能无限递归
```julia
mutable struct FileContent
	path::AbstractString # 文件的位置
	loaded::Bool # 一个布尔值,指示文件是否已加载到内存中
	contents:: Vector{UInt8} # 包含文件内容的字节数组 
end
# 以下是相同结构的构造函数：
function FileContent(path)
	ss=lstat(path)
	return FileContent(path,false,zeros(UInt8,ss.size))
end

function load_contents!(fc::FileContent)
	open(fc.path) do io
		readbytes!(io, getfield(fc, :contents)) # fc.content # 可能无限递归
		fc.loaded=true
	end;
end
```

#lstat
```julia
julia> lstat("exist/not-exists.jl")
StatStruct for "exist/not-exists.jl"
size: N / 0 bytes 
device: 3277279 /0 
inode:5503542/ 0 
mode:0o000000(----------) / 0o100666 (-rw-rw-rw-) # 10个 1 + 3*3
nlink:0/1 uid: 0 gid:0 rdev: 0 blksz: 4096/ blocks: 
mtime:(20059 days ago) / (42 days ago)
ctime:(20059 days ago) / (42 days ago)
```

### 8.3.2 理解用于字段访问的点符号
通常,只要需要访问对象的特定字段,就可以方便地将其写为`object.fieldname`。事实证明,这种表示法实际上是`getproperty/setproperty`函数调用的语法糖。

Julia的伟大之处在于,这种执行非常透明。我们实际上可以通过使用`**Meta.lower**` 函数来查看编译器的操作,如下所示。
```julia
Meta.lower(Main, :(object.fieldname))
:($(Expr(:thunk, CodeInfo(
	1 - %1 = Base.getproperty(object,:fieldname)
	└---return %1
))))

Meta.lower(Main, :(object.fieldname = 'set-value'))
:($(Expr(:thunk, CodeInfo(
	1 -	Base.setproperty!(object,:fieldname) 
	└---return 'set-value'
))))
```

> 可以在REPL中`@edit fc.path`来查看源码, `ENV["JULIA_EDITOR"] = "vim"` 来设置编辑器

现在,让我们考虑下一部分代码。
```julia
#extend Base.getproperty to redefine the meaning of dot notation
function Base.getproperty(fc::FileContent, s::Symbol)
	direct_passthrough_fields =(:path,)
	if s in direct_passthrough_fields
		return getfield(fc,s)
	end
	if s === :contents
		!getfield(fc,:loaded) && load_contents!(fc) # `否则`, check(!sth), then
		# getfield(fc,:loaded) || load_contents!(fc) # or 若跳, check(sth) skip
		return getfield(fc,:contents)
	end
	error("Unsupported property: $s")
end

function Base.getproperty(fc:: FileContent, symbol:: Symbol)
	passed = (:path,); 
	symbol in passed && return getfield(fc, symbol);
	print(symbol, "typeof ", typeof(symbol), " !is true! ", symbol == :content)
	if symbol == :contents
		!getfield(fc, :loaded) && load_contents!(fc)
		return getfield(fc, symbol)
	end
	error("cannot access $symbol")
end              
```

> 请注意,在此函数中,我们在各处都使用了getfield。如果我们使用普通的点语法(例如fc.loaded)编写代码,则它将再次开始调用getproperty函数,并且最终可能会无限递归。


### 8.3.5 报告可访问字段
开发环境通常可以帮助开发人员正确输入字段名称。在JuliaREPL中,当我输入点字符后按两次Tab键时,它将尝试自动完成并显示可用的字段名称。
```julia
julia>fc.    # press Tab key twice
contents loadedpath
```
我们已经实现了getproperty和setproperty!函数,这个列表将不再准确。为了解决这个问题,扩展propertynames函数,如下所示：
```julia
function Base.propertynames(fc::FileContent)
	return (:path,:contents)
end
```

**Base.propertynames** 函数仅需要返回一个有效符号的元组

## 8.5 Let 模块
### 8.4. 1 网络爬虫用例介绍
假设我们必须构建一个网络爬虫,它可用于索引来自各个网站的内容。这样做的过程包括设置目标站点列表,然后启动爬虫。让我们使用以下结构创建一个模块：
```julia
module WebCrawler
using Dates

#public interface
export Target
export add_site!,crawl_sites!,current_sites,reset_crawler!

# ==insert global variables and functions here==

end #module
```
 
我们的编程接口非常简单。让我们看看如何做到这一点:
1)Target代表正在爬虫的网站的数据类型。然后,我们可以使用add_site!将新站点添加到列表中。
2)准备就绪后,我们只需调用crawl_sites!函数访问所有站点。
3)为方便起见,current_sites函数可用于查看目标站点的当前列表及其爬虫状态。
4)最后,reset_crawler!函数可用于重置网络爬虫的状态。
现在让我们看一下数据结构。Target类型用于维护目标网站的URL。它还包含有关状态和完成爬虫时间的布尔变量。该结构定义如下：
```julia
using Dates
Base.@kwdef mutable struct Target
	url::String
	finished::Bool=false
	finish_time::Union{DateTime,Nothing} = nothing
end
```

为了跟踪当前的目标站点,使用一个全局变量：`const sites = Target[]`
为了完成网络爬虫的实现,我们在模块中定义了以下函数：
```julia
function add_site!(site::Target)
	push!(sites,site)
end

function crawl_sites!()
	for s in sites
		index_site!(s)
	end
end
function current_sites()
	copy(sites)
end

function index_site!(site::Target)
	site.finished=true
	site.finish_time = now()
	println("site $(site.url) crawled.")
end

function reset_crawler!()
	empty!(sites)
end
```
要使用网络爬虫,首先,我们可以添加一些网站,如下所示。
```julia
module WebCrawler
using Dates

# public interface
export Target
export add_site!,crawl_sites!,current_sites,reset_crawler!
# ==insert global variables and functions here==
Base.@kwdef mutable struct Target
	url::String
	finished::Bool=false
	finish_time::Union{DateTime,Nothing} = nothing
end
const sites = Target[]
function add_site!(site::Target)
	push!(sites,site)
end

function crawl_sites!()
	for s in sites
		index_site!(s)
	end
end
function current_sites()
	copy(sites)
end

function index_site!(site::Target)
	site.finished=true
	site.finish_time = now()
	println("site $(site.url) crawled.")
end

function reset_crawler!()
	empty!(sites)
end
end #modulue

#######################
using Main.WebCrawler
function test()
	add_site!(Target(url="http://cnn.com"))
	add_site!(Target(url="http://yahoo.com"))
end
```
#### 隐私问题 
(Main.)WebCrawler 模块中的 sites, index_site! 没有被导出,但是仍然可以通过Main.WebCrawler.访问
### 8.4.2 使用Let 闭包将私有成员隐藏
我们的目标是隐藏全局常量sites和辅助函数index_site!, 以使它们在公共API中不可见。为此,我们可以利用let块。在模块主体中,我们可以将所有函数包装在let块中,如下所示。

```julia
let sites = Target[]
    global function add_site!(site::Target)
        push!(sites, site)
    end
    global function crawl_sites!()
        for s in sites
            index_site!(s)
        end
    end

    global function current_sites()
        copy(sites)
    end

    function index_site!(site::Target)
        site.finished = true
        site.finish_time = now()
        println("Site $(site.url) crawled.")
    end

    global function reset_crawler!()
        empty!(sites)
    end
end # let
```

### 8.4.3 多个Let (scoped Let)

```julia
# Source: Gtkutilities.jl/test/utils.jl
let c=Canvas(),win=Window(c,"Canvas1")
	Gtk.draw(c) do widget
		fil1!(widget,RGB(1,0,0))
	end
	showall(win)
end
let c=Canvas(),win=Window(c,"Canvas2")
	Gtk.draw(c) do widget
		w,h=Int(width(widget)),Int(height(widget))
		randcol=reshape(reinterpret(RGB(N0f8),rand(0x00:0xff,3,w*h)),w,h)
		copy!(widget,randcol)
	end
	showall(win)
end
let c=Canvas(),win=Window(c,"Canvas3")
	Gtk.draw(c) do widget
	w,h=Int(width(widget)),Int(height(widget))
	randnum=reshape(reinterpret(N0f8,rand(0x00:0xff,w*h)),w,h)
	copy!(widget,randnum)
	end
	showall(win)
end
```

我们在前面的代码中有一些发现：
- c变量每次绑定到一个新的Canvas对象。
- win变量每次绑定到一个具有不同标题的新Window对象。
- w、h、randcol和randnum变量是不会从其各自的let块中逸出的局部变量。

通过使用let块,测试脚本需要多长时间都没有关系。每个let块都维护自己的作用域，并且任何内容都不应从一个块泄漏到下一个块。当涉及测试代码的质量时，这种编程风格立即为开发人员提供了一些安慰，因为每个测试单元彼此独立。


## 8.5 异常处理模式
强大的软件需要强大的错误处理实践。快乐路径指的是按预期正常运行的程序执行。异常路径表示由于错误情况导致意外结果。在本节中，我们将探讨几种捕获异常并有效地从故障中恢复的方法。
```julia
function index_site!(site::Target)
	response=HTTP.get(site.url)
	site.finished=true
	site.finish_time=now()
	println("site $(site.url) crawled.Status=", response.status)
end

function try_index_site!(site::Target)
	try
		index_site!(site)
	catch ex
		println("Unable to index site:Ssite")
		if ex isa HTTP.ExceptionRequest.StatusError
			printin("HTTP status error(code=", ex.status,")")
		elseif ex isa Sockets.DNSError
			println("DNS problem:", ex)
		else
			println("Unknown error:",ex)
		end
	end
end
```

### 8.5.3在顶层处理异常
通常情况下，处理异常的另一个地方是程序的顶层。为什么？原因之一是我们可能希望避免由于未捕获的异常而导致程序崩溃。程序的顶层是捕获任何内容的最后一道门，并且程序可以选择从故障中恢复(例如进行软重置)，或者正常关闭所有资源并关闭。

计算机程序完成执行后，通常会将退出状态返回到调用该程序的外壳(shell)。在Unix中，通常的约定是指示状态为零的成功终止和状态为非零的失败终止。考虑以下伪代码：
```julia
try
# 1.do some work related to reading writing files
# 2.invoke an HTTP request to a remote web service
# 3.create a status report in PDF and save in a network drive
catch ex
	if ex isa FileNotFoundError
		println("Having trouble with reading local file")
		exit(1)
	elseif ex isa HTTPRequestError
		println("Unable.to communicate with web service")
		exit(2)
	elseif exisa NetworkDriveNotReadyError
		println("All done,except that the report cannot be saved")
		exit(3)
	else
		println("An unknown error has occurred,please report.Error=",ex)
		exit(255)
	end
end
```


从前面的代码中我们可以看到，根据设计我们可以针对不同的错误情况使用特定的状态代码退出程序，以便调用程序可以正确处理异常。
接下来，我们将看一下如何确定深度嵌套执行帧中最初引发异常的位置。 

### 8.5.4跟随栈帧
通常，函数会引发异常，但不会立即对其进行处理。然后，该异常传递到父调用函数。如果该函数也未捕获到异常，它将再次运行到下一个父调用函数。这个过程一直持续到try-catch块捕获到异常为止。此时，程序的当前栈帧（即代码当前运行的执行上下文)将处理异常。
如果我们可以看到异常最初是在哪里引发的，那将非常有用。为此，我们首先尝试了解如何检索作为栈帧数组的栈跟踪。让我们创建一组简单的嵌套函数调用，以使它们最终抛出错误。考虑
```julia
function foo1()
	foo2()
end
function foo2()
	foo3()
end
function foo3()
	throw(ErrorException("bad things happened"))
end
julia> foo1()
ERROR:bad things happened
Stacktrace:
[1] foo3() at ./REPL[12]:2
[2] foo2() at ./REPL[11]:2
[3] foo1() at./REPL[10]:2
[4] top-level scope at REPL[13]:1
```

#### 自定义异常捕获
```julia
function pretty_print_stacktrace(trace)
	for (i,v) in enumerate (trace)
		println(i," => ", v)
	end
end

function foo1()
	try
		foo2()
	catch
		println("handling error gracefully")
		pretty_print_stacktrace(stacktrace()) # 堆栈只跟踪到foo1()
		pretty_print_stacktrace(stacktrace(catch_backtrace())) # 全堆栈
	end
end
```

异常捕获块外调用 `stacktrace()` 和 `catch_backtrace`
```julia
# stacktrace 返回堆栈, 当前上下文堆栈
stacktrace()
14-element Vector{Base.StackTraces.StackFrame}:
 top-level scope at REPL[1]:1
 eval at boot.jl:430 [inlined]
 eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module) at REPL.jl:245
 repl_backend_loop(backend, get_module::Function) at REPL.jl:342
 start_repl_backend(backend, consumer::Any;get_module) at jl:327
 kwcall(::NamedTuple, ::typeof(start_repl_backend), backend, consumer) at jl:324
 run_repl(repl::REPL.AbstractREPL, consumer; backend_on_current_task::Bool, 
		  backend) at REPL.jl:483
 run_repl(repl::REPL.AbstractREPL, consumer::Any) at REPL.jl:469
 (::Base.var"#1150#1152"{Bool, Symbol, Bool})(REPL::Module) at client.jl:446
 #=invokelatest#2=# at essentials.jl:1055 [inlined]
 invokelatest at essentials.jl:1052 [inlined]
 run_main_repl(interactive::Bool, quiet::Bool, banner::Symbol, history_file::Bool,
			   color_set::Bool) at client.jl:430
 repl_main at client.jl:567 [inlined]
 _start() at client.jl:541
 
# catch_backtrace()
julia> catch_backtrace()
Union{Ptr{Nothing}, Base.InterpreterIP}[]
```

### 8.5.6重试操作
意外中断或所谓的“打嗝”（hiccups)引发异常。与其他系统或服务高度集成的系统并不少见。例如，证券交易所中的交易系统可能需要将交易执行数据发布到消息传递系统以进行下游处理。但是，如果消息传递系统仅遇到短暂中断，则该操作可能会失败。在这种情况下，最常见的方法是先停一会儿，然后再试一次。如果重试再次失败，则稍后将重试该操作，直到系统完全恢复为止。这样的重试逻辑并不难编写。在这里，我们将举一个例子。假设我们有一个随机失败的函数：
```julia
using Dates
function do_something(name::AbstractString)
	print(now(),"Let's do it ... ")
	if rand()>0.5
		println(now(), "Good job, $(name)!")
	else
		println("!")
		error(now(), "Too bad:-(")
	end
end
```

我们可以开发一个包含重试逻辑的新函数：
```julia
function do_sth_robustly(name::AbstractString;max_retry_count=3,retry_interval=2)
	retry_count=0
	while true
		try
			return do_something(name)
		catch ex
			sleep(retry_interval)
			retry_count += 1
			retry_count > max_retry_count && rethrow(ex)
		end
	end
end
```
julia的内置retry函数可以很好地解决此问题。我们可以用一行代码来实现完全相同的功能:
`retry(do_something,delays=fi11(2.0,3))("John")`
- retry函数将一个函数作为第一个参数。
- delays关键字参数可以是任何支持迭代接口的对象。如由三个元素(2.0)组成的数组
- retry函数的返回值是一个匿名函数，它可以接受任意数量的参数
- retry最坏调用次数 是n + 1
- retry的默认模式 Exponent1alBack0ff 指数$5^{k}$ 增长

#### ExponentialBackOff:
```julia
ExponentialBackoff(;n=1,first_delay=.05,max_delay=10.0,factor=5.0), jitter=0.1)
```

关键字参数n表示重试的次数，在前面的代码中我们使用10的值。0.05秒后进行第一次重试。然后，对于每次重试，延迟时间将增加5倍，直到达到最长10秒。增长率可能会有10%的波动。retry函数通常被忽略，但是它是使系统更健壮的一种非常方便且强大的方法。发生错误时很容易引发异常。但这不是处理错误情况的唯一方法。在下一节中，我们将讨论异常与正常否定条件的概念。

### 8.5.7 异常和nothing

