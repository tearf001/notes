# 推送机器人配置说明

## 前提 

在群中,新建`机器人`

![image-20250401194329395](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250401194329395.png)

## 使用方式

在终端某个群组添加机器人之后,创建者可以在机器人详情页看到该机器人特有的`webhookurl`.
本文包含两种endpoints:


6989691348998302941
- 发送消息: `http://imtwo.zdxlz.com/im-external/v1/webhook/send?key=$key` 
- 上传文件: `https://imtwo.zdxlz.com/im-external/v1/webhook/upload-attachment?key=$key`
  
>webhook地址有测试和生产地址之分.以上是生产地址.
   key是 群ID, 比如 `60000000000000000001`
   **(特别注意:一定要保护好机器人的webhook地址,避免泄露!补救措施页很简单,重建机器人)**



开发者可以按以下说明向`发送消息`地址发起HTTP POST 请求,即可实现通过HTTP发送群消息. 
以下是用curl工具往群组推送文本消息的**示例**(注意要将url替换成你的机器人webhook地址,content必须是utf8编码)

```bash
curl -X POST --location "http://imtwo.zdxlz.com/im-external/v1/webhook/send?key=...key..." \
    -H "...headers..." \
    -d '...playload...'
```

- 当前自定义机器人支持文本(text), 图文(news) , 图片(image),文件(file)四种消息类型.
- image和file类型消息需要先上传文件(上传文件endpoint), 得到 文件id之后,才能发送消息.



以下为详细的技术文档.

## 消息类型及数据格式

### 文本类型(text)

- 请求示例

```json
// payload
{
    "type": "text",
    "textMsg": {
        "content": "合肥今日天气:29度,大部分多云,降雨概率:60%",
        "isMentioned":true,
        "mentionType":2,
        "mentionedMobileList":["phone_number#1","phone_number#2"]
    }
}
// curl 测试:
curl -X POST --location "http://imtwo.zdxlz.com/im-external/v1/webhook/send?key=60000000000000000001" \
    -H "Content-Type: application/json" \
    -d '{
            "type": "text",
            "textMsg": {
                "content": "来自王新海的PC测试消息, 群成员至少3人...",
                "isMentioned":true,
		        "mentionType":2,
		        "mentionedMobileList":["phone_number#1","phone_number@2"]
            }
        }'
```

荷载说明:

| 参数                  | 是否必填 | 说明                                    |
| ------------------- | ---- | ------------------------------------- |
| type                | 是    | 消息类型,此时固定为text                        |
| content             | 是    | 消息内容                                  |
| isMentioned         | 否    | 是否包含@功能,true为包含,false为不包含             |
| mentionType         | 否    | @类型,1为@所有人,2为@部分人,isMentioned为true则必填 |
| mentionedMobileList | 否    | @人员的手机号,mentionType为2则必填              |


### 图文混合(news)

- 请求示例 

```json
{
      "type": "news",
      "news": {
        "info": {
          "title": "今年春节有好礼相送",
          "description": "点击图片领取礼品",
          "url": "https://www.baidu.com",
          "picUrl": "http://img.sccnn.com/bimg/341/34669.jpg"
        }
      }
 }
 // 测试同上, 仅参数不同, 略
```

|参数|是否必填|说明|
|---|---|---|
|type|是|消息类型,此时固定为news|
|title|是|标题,不超过128个字节,超过会自动截断|
|description|否|描述,不超过512个字节,超过会自动截断|
|url|是|点击后跳转的链接.|
|picUrl|否|图片的链接.|

### 图片类型(image)

- 请求示例
>   需要上传文件得到的fileId:
```bash
curl -X POST --location "http://imtwo.zdxlz.com/im-external/v1/webhook/send?key=60000000000000000001" \
    -H "Content-Type: application/json" \
    -d '{
      "type":"image",
      "imageMsg":{
        "fileId":"31f42a827c65443c8bc25f9d9e5d91e4",
        "height": 455,
        "width": 1296
      }
  }'
```

| 参数   | 是否必填 | 说明                     |
| ------ | -------- | ------------------------ |
| type   | 是       | 消息类型,此时固定为image |
| fileId | 是       | 图片上传返回的fileId.    |
| height | 否       | 图片高度.                |
| width  | 否       | 图片宽度.                |

### 文件类型(file)
-  请求示例
>   需要上传文件得到的fileId; 一次只能发送一个文件,实际上多文件, 因此需要一个脚本来批处理.
```bash
curl -X POST --location "http://imtwo.zdxlz.com/im-external/v1/webhook/send?key=60000000000000000001" \
    -H "Content-Type: application/json" \
    -d '{
      "type":"image",
      "imageMsg":{
        "fileId":"31f42a827c65443c8bc25f9d9e5d91e4",
        "height": 455,
        "width": 1296
      }
  }'
```

| 参数     | 是否必填 | 说明                  |
| ------ | ---- | ------------------- |
| type   | 是    | 消息类型,此时固定为file      |
| fileId | 是    | 文件id,通过下文的文件上传接口获取. |
## image/file 文件上传

- 请求地址 
  使用 `文件上传`地址. 即: `https://imtwo.zdxlz.com/im-external/v1/webhook/upload-attachment?key=60000000000000000001`
  key 包含其中
- 请求谓词
  POST
### 请求头参数

| 参数名           | 必选  | 类型   | 说明                  | 值                                            |
| :------------ | :-- | :--- | ------------------- | -------------------------------------------- |
| Content-Type: | 是   | 字符串  | multipart/form-data | multipart/form-data; boundary=WebAppBoundary |
| type          | 是   | int  | 对应文件类型:1 图片, 2文件    | 1 \| 2                                       |
| file          | 是   | file | 文件二进制流              | file=@path/to/filename;filename=filename     |
| mime          | 是   | MIME | 多媒体类型枚举             | text/plain  image/png等                       |
### 返回响应格式:

| 参数名  | 必选  | 类型     | 说明                |
| :--- | :-- | :----- | ----------------- |
| id   | 是   | String | 文件id              |
| name | 是   | String | 文件名称              |
| type | 是   | String | 文件类型.zip,.txt ... |
| size | 是   | String | 文件大小              |

### 先上传后发送示例:
```json
export KEY='6989691348998302941'
export FILETYPE='file'
export CODE=1
export MIME='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'

filename='abc.xlsx'
file=path/to/$filename

curl -X POST --location "https://imtwo.zdxlz.com/im-external/v1/webhook/upload-attachment?key=$KEY&type=$CODE" \
-H "Content-Type: multipart/form-data; boundary=WebAppBoundary" \
-F "file=@$file;filename=$filename;type=$MIME"

response=$(curl -X POST "https://imtwo.zdxlz.com/im-external/v1/webhook/upload-attachment?key=$KEY&type=$CODE" \
        -H "Content-Type: multipart/form-data; boundary=WebAppBoundary" \
        -F "file=@$file;filename=$filename;type=$MIME")

// response.get("data").get("id"); a33b7dbc395d40fa9347463d1f680f6f
fileid=$(echo "$response" | jq -r '.fileid')

curl -X POST --location "http://imtwo.zdxlz.com/im-external/v1/webhook/send?key=60000000000000000001" \
    -H "Content-Type: application/json" \
    -d '{
      "type":"$(FILE)TYPE",
      "$(FILETYPE)Msg":{
        "fileId":"$fileid"
      },
      "mentionType":1
  }'
```
#### 批处理版本(bash )
```bash
#!/bin/bash

# 定义 KEY
export KEY='6989691348998302941'

# 定义文件列表(用 Bash 数组模拟)
declare -a FILELIST=(
    "file=1.png type=file code=1 mime=image/png"
    "file=周改善中北路中南分局0322.xlsx type=file code=2 mime=application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
)

# 循环处理每个文件
for entry in "${FILELIST[@]}"; do
    # 解析每一项的参数
    eval $entry  # 将字符串解析为变量

    # 第一个 curl 请求:上传文件
    response=$(curl -X POST "https://imtwo.zdxlz.com/im-external/v1/webhook/upload-attachment?key=$KEY&type=$code" \
        -H "Content-Type: multipart/form-data; boundary=WebAppBoundary" \
        -F "file=@$file;filename=$file;type=$mime")

    # 假设响应是 JSON,提取 fileid(需要 jq 工具)
    fileid=$(echo "$response" | jq -r '.fileid')  # 假设 JSON 中有 "fileid" 字段

    # 第二个 curl 请求:发送消息
    curl -X POST "http://imtwo.zdxlz.com/im-external/v1/webhook/send?key=$KEY" \
        -H "Content-Type: application/json" \
        -d "{
            \"type\": \"$type\",
            \"${type}Msg\": {
                \"fileId\": \"$fileid\"
            },
            \"mentionType\": 1
        }"
done
```




- 返回数据
  
    ```json
    {
          "ok": true,
          "code": 200,
          "data": {
            "id": "ce34fd4a5b0043efa86c37b33e4da0ca", //文件id
            "name": "test.jpg",
            "type": ".jpg",
            "size": 318182
          },
          "message": "成功"
    }
    ```
    

### **上传文件限制**

- **文件大小不超过30M**

- 消息发送频率限制: 每个机器人发送的消息不能超过20条/分钟.


# 接受机器人

# IM发送到第三方机器人的消息格式

## 消息数据格式文本

```json
{
    "type": "text",
    "callBackUrl": "https://impre.zdxlz.com/im-external/v1/webhook/send?key=60000000000000000001", // 回调url
    "callBackMethod": "POST", // 回调请求方式
    "phone":"18800001111",
    "groupId":"123456",
    "tenantId": 1,   //租户id,不传默认为1    
    "robotId":"aaa123456", //对话机器人id
    "textMsg": {
                "content": "查询合肥天气"
    }
}
```

# 第三方将结果发送给IM的回调接口

## 使用方式

#### 1.对话消息

##### 1.1 文本消息

```json
curl -X POST --location "https://{host}/im-external/v1/webhook/send?key=60000000000000000001" \
    -H "Content-Type: application/json" \
    -d '{
    "type": "text",
    "textMsg": {
    "content": "合肥今日天气:29度,大部分多云,降雨概率:60%",
        "isMentioned":true,                     //是否包含@
        "mentionType":2,
        "mentionedMobileList":["18800001111"], //IM发送的phone
        "groupId":"123456"                     //IM发送的groupId
        
    }
}'
```

##### 1.2 图片消息

```json
curl -X POST --location "https://{host}/im-external/v1/webhook/send?key=60000000000000000001" \
    -H "Content-Type: application/json" \
    -d '{
    "type": "image",
    "imageMsg": {
        "fileId":"aa11bb22cc33",
        "height": 455,
        "width": 1296,
        "groupId":"123456",       				 //IM发送的groupId
        "isMentioned":true,						 //是否包含@
        "mentionedMobileList":["18800001111"]	 //IM发送的phone
        
    }
}'
```

##### 1.3 文件消息

```json
curl -X POST --location "https://{host}/im-external/v1/webhook/send?key=60000000000000000001" \
    -H "Content-Type: application/json" \
    -d '{
    "type": "file",
    "fileMsg":{
        "fileId":"aa11bb22cc33",
        "groupId":"123456",
        "isMentioned":true,
        "mentionedMobileList":["18800001111"]
      }        
    }
}'
```

**说明**:

如果为对话机器人,IM会调用第三方接口,把回调地址callBackUrl,提问人手机号phone,提问人所在群组groupId,租户id和需要提问的信息发送给第三方机器人,第三方机器人按上述格式发送给回调接口.

其中,isMentioned : 是否包含@,此时固定为true;

mentionType:1为@所有人,2为@部分人,此时固定为2;(图片消息,文件消息不需要这个字段);

mentionedMobileList :为@人员的手机号列表,此时为唯一的IM发送的"phone";

groupId : 为消息发送到的群组id,此时为IM发送的groupId.

#### 2.推送消息

```json
curl -X POST --location "https://{host}/im-external/v1/webhook/send?key=60000000000000000001" \
    -H "Content-Type: application/json" \
    -d '{
    "type": "text",
    "textMsg": {
    "content": "合肥今日天气:29度,大部分多云,降雨概率:60%",
    "isMentioned":true,                     //是否包含@
    "mentionType":2,
    "mentionedMobileList":["18800001111","18800002222"],                   
    }
}'
```

**说明:**

推送消息和推送机器人功能相同,可以发送文本,图片,文件等,具体配置参考推送机器人说明文档.


生产
X-APP-ID:143167f755238d434914bf30271c580d
X-APP-KEY:cf329b1a391b9591ea15ced5efebd6a2
API调用路径:http://10.128.86.64:8000/serviceAgent/rest/zdxlz/im-external/v1/webhook/send
测试
X-APP-ID:62e6dc3744686bd2db585aa5b19dd7c5
X-APP-KEY:de11352e52ee65613859bf45288837ee
API调用路径:http://10.128.91.38:20501/serviceAgent/rest/zdxlz/im-external/v1/webhook/send 

# 新接口
```bash
curl -X POST \
  -H "X-APP-ID: 62e6dc3744686bd2db585aa5b19dd7c5" \
  -H "X-APP-KEY: de11352e52ee65613859bf45288837ee" \
  -H "Content-Type: application/json" \
  -d '{
            "type": "text",
            "textMsg": {
                "content": "合肥今日天气:29度,大部分多云,降雨概率:60%"
            }
        }' \
  http://10.128.91.38:20501/serviceAgent/rest/zdxlz/im-external/v1/webhook/send?key=de11352e52ee65613859bf45288837ee


#prod

curl -X POST \
  -H "X-APP-ID: 143167f755238d434914bf30271c580d" \
  -H "X-APP-KEY: cf329b1a391b9591ea15ced5efebd6a2" \
  -H "Content-Type: application/json" \
  -d '{
            "type": "text",
            "textMsg": {
                "content": "合肥今日天气:29度,大部分多云,降雨概率:60%"
            }
        }' \
  http://10.128.86.64:8000/serviceAgent/rest/zdxlz/im-external/v1/webhook/send?key=6989691348998302941


```

placeholders

```js  
//api/dbq/1.0/endpoints/32
const rdata = await fetch('https://jsonplaceholder.typicode.com/users').then(res => res.json());
const categories = rdata.map(s => s.address.city);
const dataPoints = rdata.map(s => ({ value: s.address.geo.lng, name: s.address.city }))
const data = { categories, dataPoints }

curl 'http://133.0.109.121:31850/api/v3/dbq/1.0/endpoints/17' \
  -H 'Accept: */*' \
  -H 'Accept-Language: zh-CN,zh;q=0.9,en;q=0.8' \
  -H 'Connection: keep-alive' \
  -H 'Sec-Fetch-Dest: empty' \
  -H 'Sec-Fetch-Mode: cors' \
  -H 'Sec-Fetch-Site: none' \
  -H 'Sec-Fetch-Storage-Access: active' \
  -H '___internal-request-id: d8fffb66-bc69-4c62-b9a2-d8530f6cbf52' \
  -H 'content-type: application/json' \
  -H 'sec-ch-ua: "Chromium";v="134", "Not:A-Brand";v="24", "Google Chrome";v="134"' \
  -H 'sec-ch-ua-mobile: ?0' \
  -H 'sec-ch-ua-platform: "Windows"' \
  -H 'x-client-id: VIZAPP_FOR_THE_HORD' \
  -H 'x-client-secret: hQjNlNXYi9FbyV3Xn5WayR3U' \
  --data-raw $'{ \n  "deptId": "3",\n  "appId": "1830790098809835520"\n}'
```

api/dbq/1.0/endpoints/32
```js
const url = location.origin+'/api/dbq/1.0/endpoints/32?user=3'
console.log('url', url)
const rdata = await fetch(url).then(res => res.json());
console.log('rdata', data)
const data = rdata;
```


我正在构建一个沙盒应用, 根据HTML5的不同部分组装成模板, 它包括4个部分,html,css, js, data; data专用于数据获取, 它可以是普通对象,也可以是代码块(async). 为了让它工作, 我用了一个模板 @templates 来 拼装最终的HTML, 并把他们作为iframe的srcdoc. 目前工作良好, 基于它的实现有 @SandboxIde @Preview. 但是现在有一个问题, 通过 `srcdoc` 属性提供的 HTML 内容会被解析到一个**唯一的、不透明的源 (opaque origin)** 中, 用它来跨越API请求(fetch), 会遇到CORS问题,我尝试了https://jsonplaceholder.typicode.com这样的公有API, OK.但是,在我的sveltekit项目中, 有一个用于处理数据请求的端点 src\routes\api\dbq\1.0\endpoints\[id]\+server.ts, 则不行. 现在大概有3种方案
1. 让 `iframe` 和父窗口同源 我**必须**放弃使用 `srcdoc`，转而使用 `src`  属性，通过新建另一个endpoint(同源)来生成动态HTML;
2. 正确的设置CORS, 我对sveltekit不太熟悉, 不知道仅需要在端点上设置CORS就够,还是 全局地设置?
3. **修改父窗口 SvelteKit 组件 (+page.svelte 或包含 iframe 的组件):**

- 添加事件监听器来接收来自 iframe 的消息。    
- 当收到代理请求消息时，使用 SvelteKit 的 fetch (它会携带正确的源信息) 向 localhost:4000(父DOM所在的同源API endpoint) 发起请求。    
- 将结果通过 postMessage 发回给 iframe。
    

```html //svelte
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';

  let iframeElement: HTMLIFrameElement;
  const svelteKitOrigin = 'http://localhost:4000'; // 应动态获取 window.location.origin

  function handleMessageFromIframe(event: MessageEvent) {
    // 安全校验：确保消息来自嵌入的 iframe (源为 null) 且是我们期望的类型
     if (event.source !== iframeElement?.contentWindow) {//注意：iframe 的 event.origin 在 srcdoc 下是 null
         console.warn("消息来源不是预期的 iframe contentWindow");
         return;
     }

    if (event.data && event.data.type === 'proxyFetch') {
      const { url, options } = event.data.payload;
      console.log(`收到来自 iframe 的代理请求: ${options?.method || 'GET'} ${url}`);
      // 使用 SvelteKit 的 fetch 发起请求
      fetch(url, { ...options, credentials: 'omit' })//通常不发送凭证，除非明确需要安全. 'include' 如果需要 cookie
        .then(async (response) => {
          if (!response.ok) {
            // 尝试读取错误信息
            const errorText = await response.text().catch(() => '无法读取错误详情');
            throw new Error(`HTTP error ${response.status}: ${errorText}`);
          }
          // 假设是 JSON 响应
          return response.json();
        })
        .then(data => {
          // 将成功结果发回给 iframe
           if (iframeElement?.contentWindow) {
                iframeElement.contentWindow.postMessage({ type: 'proxyFetchResponse', success: true, data: data }, svelteKitOrigin); // 使用父窗口源作为目标源
           }
        })
        .catch(error => {
          console.error("代理请求失败:", error);
          // 将错误信息发回给 iframe
          if (iframeElement?.contentWindow) {
               iframeElement.contentWindow.postMessage({ type: 'proxyFetchResponse', success: false, error: error.message || '未知错误' }, svelteKitOrigin);
          }
        });
    }
  }

  onMount(() => {
    window.addEventListener('message', handleMessageFromIframe);
  });

  onDestroy(() => {
    window.removeEventListener('message', handleMessageFromIframe);
  });

  // --- 其他你的组件逻辑，例如 enhancedAppPreview 和 handleIframeLoad ---
  function enhancedAppPreview(app: any): string {
    // ... 你生成 srcdoc HTML/JS 的逻辑 ...
    // 确保生成的 JS 包含上面 iframe 部分的 postMessage 代码
    return `<html>...</html>`;
  }
   function handleIframeLoad(itemId: string | number) {
       console.log(`Iframe for item ${itemId} loaded.`);
       // 可能需要在此处或稍后通知 iframe 父窗口已准备好接收消息
   }
   let sandApp = { id: 1,  name: 'Test App', html: '...', js:'...', css: '...', data: '' }}; // 沙盒模型数据
   
</script>

<!-- iframe 预览 -->
<iframe
    bind:this={iframeElement}
    id={frameId}
    title={sandApp?.name || "未命名应用"}
    class="w-full h-full border-0"
    srcdoc={enhancedAppPreview(item.app)}
    onload={(e) => handleIframeLoad(item.id)}
    loading="lazy"
></iframe>
```

# postmessage
```js
    // 注入代理Fetch支持   
    const proxyFetchScript =` 
      // 替换原生fetch以支持代理请求
      const originalFetch = window.fetch;
      let requestCounter = 0;      
      window.fetch = function proxyFetch(url, options = {}) {
        // 检查是否是同源请求或者已支持CORS的请求
        const isSameOrigin = url.startsWith('/') || url.startsWith(window.location.origin);        
        if (isSameOrigin) {
          const requestId = Date.now() + '-' + (requestCounter++); // 请求ID. 保持唯一
          return new Promise((resolve, reject) => {
            // 设置响应处理器
            function responseHandler(event) {
              if (event.data && event.data.type === 'proxyFetchResponse' && event.data.requestId === requestId) {
                window.removeEventListener('message', responseHandler); // 移除消息响应处理器
                if (event.data.success) {
                  // 创建一个模拟的Response对象
                  const responseInit = {
                    status: 200,
                    statusText: 'OK',
                    headers: new Headers({'Content-Type': 'application/json'})
                  };
                  
                  const responseBody = typeof event.data.data === 'string' 
                    ? event.data.data 
                    : JSON.stringify(event.data.data);
                    
                  const response = new Response(responseBody, responseInit);                  
                  // 添加json()方法
                  const originalJson = response.json;
                  response.json = () => {
                    if (typeof event.data.data === 'object') {
                      return Promise.resolve(event.data.data);
                    }
                    return originalJson.call(response);
                  };
                  
                  resolve(response);
                } else {
                  reject(new Error(event.data.error || '代理请求失败'));
                }
              }
            }
            
            // 添加消息监听
            window.addEventListener('message', responseHandler);            
            // 发送代理请求
            window.parent.postMessage({
              type: 'proxyFetch',
              payload: {
                url: url,
                options: options,
                requestId: requestId
              }
            }, '*');
          });
        }        
        // 对于其他请求，使用原始fetch
        return originalFetch(url, options);
      };
    `;
```