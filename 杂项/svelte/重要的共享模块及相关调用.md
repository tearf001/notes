# scope.js
1. **核心类**：
    - `Binding` 类：表示一个标识符绑定
        - 记录变量的声明位置、类型、引用和状态
        - 追踪变量是否被修改(`mutated`)或重新赋值(`reassigned`)
        - 支持特殊的 props 别名系统
    - `Scope` 类：实现作用域的核心逻辑
        - 维护当前作用域的声明(`declarations`)和引用(`references`)
        - 支持作用域嵌套(`parent`)
        - 通过 `#porous` 标记是否允许 `var` 声明"穿透"
        - 提供变量查找、声明和引用追踪等功能
    - `ScopeRoot` 类：作为顶层作用域
        - 处理命名冲突
        - 生成唯一标识符名称
2. **主要功能**：
    - `create_scopes` 函数：遍历 AST 创建作用域树
    - 支持多种作用域类型：
        - 块级作用域
        - 组件作用域
        - 函数作用域
3. **特殊处理**：
    - 支持解构赋值
    - 处理 Svelte 特有的反应式声明
    - 处理插槽(slot)作用域
    - 支持 rune（Svelte 5 的新特性）
4. **作用域分析过程**：
    - 遍历 AST 节点
    - 为不同类型的节点创建对应作用域
    - 收集变量声明和引用
    - 处理作用域嵌套关系
    - 分析变量可见性

这个实现展示了 Svelte 5 如何处理：

- 变量声明和访问
- 作用域嵌套和继承
- 变量提升（通过 porous 作用域）
- 命名冲突解决
- 反应式系统的作用域要求

这是编译器中的关键部分，为后续的代码生成和优化提供了必要的语义信息。

# 第一阶段
解析
# 第二阶段
分析
# 第三阶段
编译输出.
`packages\svelte\src\compiler\phases\3-transform\client\transform-client.js`  中包含
```ts
client_component 函数
	/** @type {ComponentClientTransformState} */
	const state = {
		analysis,
		options,
		scope: analysis.module.scope,
		scopes: analysis.module.scopes,
		is_instance: false,
		hoisted: [b.import_all('$', 'svelte/internal/client')],
		node: /** @type {any} */ (null), // populated by the root node
		metadata: {
			context: {
				template_needs_import_node: false,
				template_contains_script_tag: false
			},
			namespace: options.namespace,
			bound_contenteditable: false
		},
		events: new Set(),
		public_state: new Map(),
		private_state: new Map(),
		transform: {},
		in_constructor: false,
		instance_level_snippets: [],
		module_level_snippets: [],

		// these are set inside the `Fragment` visitor, and cannot be used until then
		init: /** @type {any} */ (null),
		update: /** @type {any} */ (null),
		expressions: /** @type {any} */ (null),
		after_update: /** @type {any} */ (null),
		template: /** @type {any} */ (null),
		locations: /** @type {any} */ (null)
	};

	const module = /** @type {ESTree.Program} */ (
		walk(/** @type {AST.SvelteNode} */ (analysis.module.ast), state, visitors)
	);

	const instance_state = {
		...state,
		transform: { ...state.transform },
		scope: analysis.instance.scope,
		scopes: analysis.instance.scopes,
		is_instance: true
	};

	const instance = /** @type {ESTree.Program} */ (
		walk(/** @type {AST.SvelteNode} */ (analysis.instance.ast), instance_state, visitors)
	);

	const template = /** @type {ESTree.Program} */ (
		walk(
			/** @type {AST.SvelteNode} */ (analysis.template.ast),
			{
				...state,
				transform: instance_state.transform,
				scope: analysis.instance.scope,
				scopes: analysis.template.scopes
			},
			visitors
		)
	);
	//...
    for (const [name, binding] of analysis.instance.scope.declarations) {
	    if (binding.kind === 'legacy_reactive') {
            legacy_reactive_declarations.push(
                b.const(name, b.call('$.mutable_state', undefined, analysis.immutable ? b.true : undefined))
            );
        }

        if (binding.kind === 'store_sub') {
            if (store_setup.length === 0) {
                needs_store_cleanup = true;
                store_setup.push(
                    b.const(b.array_pattern([b.id('$$stores'), b.id('$$cleanup')]), b.call('$.setup_stores'))
                );
            }
            // We're creating an arrow function that gets the store value which minifies better for two or more references
            const store_reference = build_getter(b.id(name.slice(1)), instance_state);
            const store_get = b.call('$.store_get', store_reference, b.literal(name), b.id('$$stores'));
            store_setup.push(
                b.const(
                    binding.node,
                    dev // 开发期间
					? b.thunk(b.sequence([b.call('$.validate_store', store_reference,b.literal(name.slice(1))),store_get]))
					: b.thunk(store_get)
                )
            );

        }
```

## 变量申明
`packages\svelte\src\compiler\phases\3-transform\client\visitors\VariableDeclaration.js`
```js
//import * as b from builders
export function VariableDeclaration(node: VariableDeclaration, context: ComponentContext) {
	const declarations = []; // VariableDeclarator[]
	if (context.state.analysis.runes) {
	}else{
		遍历 node.declarations as declarator
		const bindings = context.state.scope.get_bindings(declarator); // Binding[]
		const has_state = bindings.some((binding) => binding.kind === 'state');
		const has_props = bindings.some((binding) => binding.kind === 'bindable_prop');
		如果绑定没有状态,也没有可绑定的prop
			如果 declarator 有初始化,且是一个提升函数 // 创建const 表达式 继续
				context.state.hoisted.push(b.const(declarator.id, context.visit(init))); continue;
			否则 context.visit(declarator) 进入 变量申明数组, continue;
		有 has_props
			不是 标识符?! 把 let 导出到 props . 作者说非常非常 weird
			// export let { x: foo, z: [bar]} 意味着 foo, bar 叶子 才是props name 而不是 x,z
			实现: 创建临时作用域, 处理它, 进入数组
			continue;
		剩下有状态的 declarations.push(
                ...create_state_declarators( // 旧代码, 传统模式
                    declarator,
                    context.state, (declarator.init && context.visit(declarator.init)) //表达式
                ));
	}
	数组空,返回b.empty;
	返回{...node, declarations}
}
// 创建状态申明, 传统模式. 
function create_state_declarators(declarator, {scope, analysis}, value){
	declarator 已经是 标识符, 
		返回: [b.declarator(declarator.id, b.call('$.mutable_state', value, analysis.immutable ? b.true : undefined))]
	临时作用域中 创建并返回 [b.declarator(b.id(tmp), extract_paths(declarator.id).map(path=>{
			const value = path.expression?.(b.id(tmp));
            const binding = scope.get(/** @type {Identifier} */ (path.node).name);
            return b.declarator(
                path.node,
                binding?.kind === 'state' 
	                ? b.call('$.mutable_state', value, analysis.immutable ? b.true : undefined)
                    : value
			);}))]
}


```