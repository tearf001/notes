## 选择开发范式

这一点对于 Solid 开发来说尤其重要，因为 Solid 支持各种主流数据驱动开发范式

**在没有领域驱动文件结构/微前端支持情况下，请勿混用多种范式**

> 简单来说，就是 Solid 同时支持 React 风格，[React immer 风格](https://zhida.zhihu.com/search?content_id=238632870&content_type=Article&match_order=1&q=React+immer+%E9%A3%8E%E6%A0%BC&zhida_source=entity)，Vue/mobx 风格，以及 cycle/rx 风

下面以示例代码来介绍不同风格：

### Vue/mobx 风格

特点是**对于对象可以使用等号变更其内部**

```js
const data = createMutable({
   value:1
})
// 与 vue reactive 完全相同
const value = createSignal(0)
// 与 vue ref 有区别，只能代理单值

const memo = createMemo(()=>data.value)
// 逻辑与 vue computed 相同，但是返回的 memo 需要 memo() 调用后使用
```

总结起来一句话：

1. reactive -> createMutable，ref -> createSignal，computed -> createMemo，watchEffect -> createEffect
2. createSignal 只能放单值（对象的话需要***变更引用***）
3. createMemo 返回 signal，需要调用才能使用，而 createMutable 不需要

换言之，只要区分了 Vue 和 solid 在这种写法下的不同点（3个），再加上 jsx 和 template 的区别，你能直接上手 Solid 开发

但是，请注意，**能在任意位置修改对象中的引用属性，这在数据驱动操作中实际上并不推荐**, Solid 本身不推荐此风格写法：

> [solidjs.com/docs/latest/api#createmutable](https://link.zhihu.com/?target=https%3A//www.solidjs.com/docs/latest/api%23createmutable)  
> ***可变状态可以在任何地方传递和改变，这会使跟踪变得更难，也更容易打破单向流。一般建议改用`createStore`。`produce`修饰符可以提供许多相同的好处而没有任何缺点。*

### React 风格

此处的 react 风格，指的是 react reasonml 或 immutable.js 风格，即 react 本 react

特点是**修改对象时采用函数，非常灵活且稳定, 且尽可能将数据统一管理**：

```tsx
const [store, setStore] = createStore({
   value:{
      value:1
   }
})
// 修改时采用函数
setStore("value","value",1)
setStore("value","value",pre=>pre+1)
```

这种写法实际上是 React 极力推荐的写法，但是数据结构***中途变更***（比如多出 store.value.a.b.c）会造成混乱, ts可以**检测问题**, 但是无法***refactor***

### React immer 风格

其特点是**进行对象内部修改，但将其修改限制在了每一个具体赋值函数内部**（类比 vuex 的 mutation）

```tsx
const [state, setState] = useStore({ value:1 })
const [data, setData] = useSignal({ value:1 })

// 使用
state.value
data().value

// 修改
setStore(produce(draft=>{
   draft.value ++
}))
setData(produce(draft=>{
   draft.value ++
}))
```

此种用法下，你**可以完全丢弃掉 useStore 这个 api**

因为 **signal 可以配合 produce，且能够覆盖单值**

这也是 Solid 最为推荐的风格，是平衡的艺术.

请注意，**不管是 React 还是 React immer 风格，都不需要传入依赖数组**

## [cycle/rx 风格](https://zhida.zhihu.com/search?content_id=238632870&content_type=Article&match_order=1&q=cycle%2Frx+%E9%A3%8E%E6%A0%BC&zhida_source=entity)

其特点是 **主逻辑基于 Rx.js 或其他流式工具**

> 函数式响应式流编程（简称流式编程），简单来说，React 和 Vue 倡导单向数据流，是为了一致  
> 而流式编程，即我在最后渲染时打平成单向数据流即可，在此之前，我用事件驱动的思想，搞出一堆流来  
> 不同于数据驱动，事件驱动方便追踪流程（事件1->事件2...）  
> 用于**高难度异步和大架构通讯**

```js
// 一个用于监听 rx 的工具函数. 订阅辅助函数, 给val$设置一个初值, 然后得到跟踪后的值
function subscribe(val$, initialValue){
    const [value,setValue] = createSignal(initialValue)
    val$.subscribe(val=>{
        setValue(val)
    })
    return value
}

function Compo(){
    const ev$ = interface(1).pipe(pairwise())
    const $a = subscribe(ev$,[val1, val2])
    return <div>{$a()[0]}</div> /*val1*/ 
}
```

在 rx.js 面前，单向数据流都只是其子集（别人都多条流，复合流即流中有流，怎么可能不支持单向流 reduce）

因此此时 Solid 完全沦为配角，有真 rx.js 能力的人，原生也是随便写的，肯定也不会计较 Solid 中的体验了

> 注意  
> 很多同仁说，rx 同样 react 和 vue 也能支持  
> 但是这其实不对，因为 react 很多逻辑和生态与 react 本身调度耦合，尤其是 **rx.js 本身就要处理密集异步才出场，密集异步下，react 性能笋干爆炸**，自然也就无法和 rx 很好配合  
> Vue 也是如此，其**默认的 proxy 异步也会导致数据创建性能损耗**，而尤大早期的基于 vue2 的 vue-rx 框架也没有及时更新到最新版本，或者说 rx 对于 vue 来说本来侵入性就大  
> 但是 **Solid signal 不同，其和 rx.js 完美契合**，甚至主用 rx 的框架 Angular 也有 signal 写法，完全不用担心

### 小结

风格四选一，个人认为可以将其分为四个梯度：

1. 优先选择纯 signal 的 react immer 风格，此风格平衡了各种场景
2. 如果需要兼容其他框架（比如作为微前端基座），优先考虑兼容性
3. 如果应用难度很高，复杂度很高，耦合非常严重，开发人员水平奇高，优先 cycle/rx 风格
4. 如果应用难度一般，复杂度一般，但是异步和流程较多，交互要求高，优先 react 和 react immer 风格
5. 如果难度一般，没有啥特别复杂的逻辑，优先 vue/mobx 风格提高效率

> 为了简单有效展示 Solid 特性，后文都将采用 vue/mobx 风格  
> 此种风格绝大多数人都看得懂，如果计较说此种风格不喜欢，你可以靠自己转成其他风格代码

当然，这些只是浅见而已，打游戏的都知道，**熟练度 > 版本**，主要还是看开发者本身适应哪种风格